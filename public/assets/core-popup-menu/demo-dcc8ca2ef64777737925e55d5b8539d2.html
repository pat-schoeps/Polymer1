<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<style shim-shadowdom="">
/*******************************
          Flex Layout
*******************************/

html /deep/ [layout][horizontal], html /deep/ [layout][vertical] {
  display: -ms-flexbox;
  display: -webkit-flex;
  display: flex;
}

html /deep/ [layout][horizontal][inline], html /deep/ [layout][vertical][inline] {
  display: -ms-inline-flexbox;
  display: -webkit-inline-flex;
  display: inline-flex;
}

html /deep/ [layout][horizontal] {
  -ms-flex-direction: row;
  -webkit-flex-direction: row;
  flex-direction: row;
}

html /deep/ [layout][horizontal][reverse] {
  -ms-flex-direction: row-reverse;
  -webkit-flex-direction: row-reverse;
  flex-direction: row-reverse;
}

html /deep/ [layout][vertical] {
  -ms-flex-direction: column;
  -webkit-flex-direction: column;
  flex-direction: column;
}

html /deep/ [layout][vertical][reverse] {
  -ms-flex-direction: column-reverse;
  -webkit-flex-direction: column-reverse;
  flex-direction: column-reverse;
}

html /deep/ [layout][wrap] {
  -ms-flex-wrap: wrap;
  -webkit-flex-wrap: wrap;
  flex-wrap: wrap;
}

html /deep/ [layout][wrap-reverse] {
  -ms-flex-wrap: wrap-reverse;
  -webkit-flex-wrap: wrap-reverse;
  flex-wrap: wrap-reverse;
}

html /deep/ [flex] {
  -ms-flex: 1 1 0.000000001px;
  -webkit-flex: 1;
  flex: 1;
  -webkit-flex-basis: 0.000000001px;
  flex-basis: 0.000000001px;
}

html /deep/ [vertical][layout] > [flex][auto-vertical], html /deep/ [vertical][layout]::shadow [flex][auto-vertical] {
  -ms-flex: 1 1 auto;
  -webkit-flex-basis: auto;
  flex-basis: auto;
}

html /deep/ [flex][auto] {
  -ms-flex: 1 1 auto;
  -webkit-flex-basis: auto;
  flex-basis: auto;
}

html /deep/ [flex][none] {
  -ms-flex: none;
  -webkit-flex: none;
  flex: none;
}

html /deep/ [flex][one] {
  -ms-flex: 1;
  -webkit-flex: 1;
  flex: 1;
}

html /deep/ [flex][two] {
  -ms-flex: 2;
  -webkit-flex: 2;
  flex: 2;
}

html /deep/ [flex][three] {
  -ms-flex: 3;
  -webkit-flex: 3;
  flex: 3;
}

html /deep/ [flex][four] {
  -ms-flex: 4;
  -webkit-flex: 4;
  flex: 4;
}

html /deep/ [flex][five] {
  -ms-flex: 5;
  -webkit-flex: 5;
  flex: 5;
}

html /deep/ [flex][six] {
  -ms-flex: 6;
  -webkit-flex: 6;
  flex: 6;
}

html /deep/ [flex][seven] {
  -ms-flex: 7;
  -webkit-flex: 7;
  flex: 7;
}

html /deep/ [flex][eight] {
  -ms-flex: 8;
  -webkit-flex: 8;
  flex: 8;
}

html /deep/ [flex][nine] {
  -ms-flex: 9;
  -webkit-flex: 9;
  flex: 9;
}

html /deep/ [flex][ten] {
  -ms-flex: 10;
  -webkit-flex: 10;
  flex: 10;
}

html /deep/ [flex][eleven] {
  -ms-flex: 11;
  -webkit-flex: 11;
  flex: 11;
}

html /deep/ [flex][twelve] {
  -ms-flex: 12;
  -webkit-flex: 12;
  flex: 12;
}

/* alignment in cross axis */

html /deep/ [layout][start] {
  -ms-flex-align: start;
  -webkit-align-items: flex-start;
  align-items: flex-start;
}

html /deep/ [layout][center], html /deep/ [layout][center-center] {
  -ms-flex-align: center;
  -webkit-align-items: center;
  align-items: center;
}

html /deep/ [layout][end] {
  -ms-flex-align: end;
  -webkit-align-items: flex-end;
  align-items: flex-end;
}

/* alignment in main axis */

html /deep/ [layout][start-justified] {
  -ms-flex-pack: start;
  -webkit-justify-content: flex-start;
  justify-content: flex-start;
}

html /deep/ [layout][center-justified], html /deep/ [layout][center-center] {
  -ms-flex-pack: center;
  -webkit-justify-content: center;
  justify-content: center;
}

html /deep/ [layout][end-justified] {
  -ms-flex-pack: end;
  -webkit-justify-content: flex-end;
  justify-content: flex-end;
}

html /deep/ [layout][around-justified] {
  -ms-flex-pack: distribute;
  -webkit-justify-content: space-around;
  justify-content: space-around;
}

html /deep/ [layout][justified] {
  -ms-flex-pack: justify;
  -webkit-justify-content: space-between;
  justify-content: space-between;
}

/* self alignment */

html /deep/ [self-start] {
  -ms-align-self: flex-start;
  -webkit-align-self: flex-start;
  align-self: flex-start;
}

html /deep/ [self-center] {
  -ms-align-self: center;
  -webkit-align-self: center;
  align-self: center;
}

html /deep/ [self-end] {
  -ms-align-self: flex-end;
  -webkit-align-self: flex-end;
  align-self: flex-end;
}

html /deep/ [self-stretch] {
  -ms-align-self: stretch;
  -webkit-align-self: stretch;
  align-self: stretch;
}

/*******************************
          Other Layout
*******************************/

html /deep/ [block] {
  display: block;
}

/* ie support for hidden */
html /deep/ [hidden] {
  display: none !important;
}

html /deep/ [relative] {
  position: relative;
}

html /deep/ [fit] {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}

body[fullbleed] {
  margin: 0;
  height: 100vh;
}

/*******************************
            Other
*******************************/

html /deep/ [segment], html /deep/ segment {
  display: block;
  position: relative;
  -webkit-box-sizing: border-box;
  -ms-box-sizing: border-box;
  box-sizing: border-box;
  margin: 1em 0.5em;
  padding: 1em;
  background-color: white;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1);
  box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1);
  border-radius: 5px 5px 5px 5px;
}

</style>
<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->



<script>/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
// @version 0.5.1
window.PolymerGestures = {};

(function(scope) {
  var HAS_FULL_PATH = false;

  // test for full event path support
  var pathTest = document.createElement('meta');
  if (pathTest.createShadowRoot) {
    var sr = pathTest.createShadowRoot();
    var s = document.createElement('span');
    sr.appendChild(s);
    pathTest.addEventListener('testpath', function(ev) {
      if (ev.path) {
        // if the span is in the event path, then path[0] is the real source for all events
        HAS_FULL_PATH = ev.path[0] === s;
      }
      ev.stopPropagation();
    });
    var ev = new CustomEvent('testpath', {bubbles: true});
    // must add node to DOM to trigger event listener
    document.head.appendChild(pathTest);
    s.dispatchEvent(ev);
    pathTest.parentNode.removeChild(pathTest);
    sr = s = null;
  }
  pathTest = null;

  var target = {
    shadow: function(inEl) {
      if (inEl) {
        return inEl.shadowRoot || inEl.webkitShadowRoot;
      }
    },
    canTarget: function(shadow) {
      return shadow && Boolean(shadow.elementFromPoint);
    },
    targetingShadow: function(inEl) {
      var s = this.shadow(inEl);
      if (this.canTarget(s)) {
        return s;
      }
    },
    olderShadow: function(shadow) {
      var os = shadow.olderShadowRoot;
      if (!os) {
        var se = shadow.querySelector('shadow');
        if (se) {
          os = se.olderShadowRoot;
        }
      }
      return os;
    },
    allShadows: function(element) {
      var shadows = [], s = this.shadow(element);
      while(s) {
        shadows.push(s);
        s = this.olderShadow(s);
      }
      return shadows;
    },
    searchRoot: function(inRoot, x, y) {
      var t, st, sr, os;
      if (inRoot) {
        t = inRoot.elementFromPoint(x, y);
        if (t) {
          // found element, check if it has a ShadowRoot
          sr = this.targetingShadow(t);
        } else if (inRoot !== document) {
          // check for sibling roots
          sr = this.olderShadow(inRoot);
        }
        // search other roots, fall back to light dom element
        return this.searchRoot(sr, x, y) || t;
      }
    },
    owner: function(element) {
      if (!element) {
        return document;
      }
      var s = element;
      // walk up until you hit the shadow root or document
      while (s.parentNode) {
        s = s.parentNode;
      }
      // the owner element is expected to be a Document or ShadowRoot
      if (s.nodeType != Node.DOCUMENT_NODE && s.nodeType != Node.DOCUMENT_FRAGMENT_NODE) {
        s = document;
      }
      return s;
    },
    findTarget: function(inEvent) {
      if (HAS_FULL_PATH && inEvent.path && inEvent.path.length) {
        return inEvent.path[0];
      }
      var x = inEvent.clientX, y = inEvent.clientY;
      // if the listener is in the shadow root, it is much faster to start there
      var s = this.owner(inEvent.target);
      // if x, y is not in this root, fall back to document search
      if (!s.elementFromPoint(x, y)) {
        s = document;
      }
      return this.searchRoot(s, x, y);
    },
    findTouchAction: function(inEvent) {
      var n;
      if (HAS_FULL_PATH && inEvent.path && inEvent.path.length) {
        var path = inEvent.path;
        for (var i = 0; i < path.length; i++) {
          n = path[i];
          if (n.nodeType === Node.ELEMENT_NODE && n.hasAttribute('touch-action')) {
            return n.getAttribute('touch-action');
          }
        }
      } else {
        n = inEvent.target;
        while(n) {
          if (n.nodeType === Node.ELEMENT_NODE && n.hasAttribute('touch-action')) {
            return n.getAttribute('touch-action');
          }
          n = n.parentNode || n.host;
        }
      }
      // auto is default
      return "auto";
    },
    LCA: function(a, b) {
      if (a === b) {
        return a;
      }
      if (a && !b) {
        return a;
      }
      if (b && !a) {
        return b;
      }
      if (!b && !a) {
        return document;
      }
      // fast case, a is a direct descendant of b or vice versa
      if (a.contains && a.contains(b)) {
        return a;
      }
      if (b.contains && b.contains(a)) {
        return b;
      }
      var adepth = this.depth(a);
      var bdepth = this.depth(b);
      var d = adepth - bdepth;
      if (d >= 0) {
        a = this.walk(a, d);
      } else {
        b = this.walk(b, -d);
      }
      while (a && b && a !== b) {
        a = a.parentNode || a.host;
        b = b.parentNode || b.host;
      }
      return a;
    },
    walk: function(n, u) {
      for (var i = 0; n && (i < u); i++) {
        n = n.parentNode || n.host;
      }
      return n;
    },
    depth: function(n) {
      var d = 0;
      while(n) {
        d++;
        n = n.parentNode || n.host;
      }
      return d;
    },
    deepContains: function(a, b) {
      var common = this.LCA(a, b);
      // if a is the common ancestor, it must "deeply" contain b
      return common === a;
    },
    insideNode: function(node, x, y) {
      var rect = node.getBoundingClientRect();
      return (rect.left <= x) && (x <= rect.right) && (rect.top <= y) && (y <= rect.bottom);
    },
    path: function(event) {
      var p;
      if (HAS_FULL_PATH && event.path && event.path.length) {
        p = event.path;
      } else {
        p = [];
        var n = this.findTarget(event);
        while (n) {
          p.push(n);
          n = n.parentNode || n.host;
        }
      }
      return p;
    }
  };
  scope.targetFinding = target;
  /**
   * Given an event, finds the "deepest" node that could have been the original target before ShadowDOM retargetting
   *
   * @param {Event} Event An event object with clientX and clientY properties
   * @return {Element} The probable event origninator
   */
  scope.findTarget = target.findTarget.bind(target);
  /**
   * Determines if the "container" node deeply contains the "containee" node, including situations where the "containee" is contained by one or more ShadowDOM
   * roots.
   *
   * @param {Node} container
   * @param {Node} containee
   * @return {Boolean}
   */
  scope.deepContains = target.deepContains.bind(target);

  /**
   * Determines if the x/y position is inside the given node.
   *
   * Example:
   *
   *     function upHandler(event) {
   *       var innode = PolymerGestures.insideNode(event.target, event.clientX, event.clientY);
   *       if (innode) {
   *         // wait for tap?
   *       } else {
   *         // tap will never happen
   *       }
   *     }
   *
   * @param {Node} node
   * @param {Number} x Screen X position
   * @param {Number} y screen Y position
   * @return {Boolean}
   */
  scope.insideNode = target.insideNode;

})(window.PolymerGestures);

(function() {
  function shadowSelector(v) {
    return 'html /deep/ ' + selector(v);
  }
  function selector(v) {
    return '[touch-action="' + v + '"]';
  }
  function rule(v) {
    return '{ -ms-touch-action: ' + v + '; touch-action: ' + v + ';}';
  }
  var attrib2css = [
    'none',
    'auto',
    'pan-x',
    'pan-y',
    {
      rule: 'pan-x pan-y',
      selectors: [
        'pan-x pan-y',
        'pan-y pan-x'
      ]
    },
    'manipulation'
  ];
  var styles = '';
  // only install stylesheet if the browser has touch action support
  var hasTouchAction = typeof document.head.style.touchAction === 'string';
  // only add shadow selectors if shadowdom is supported
  var hasShadowRoot = !window.ShadowDOMPolyfill && document.head.createShadowRoot;

  if (hasTouchAction) {
    attrib2css.forEach(function(r) {
      if (String(r) === r) {
        styles += selector(r) + rule(r) + '\n';
        if (hasShadowRoot) {
          styles += shadowSelector(r) + rule(r) + '\n';
        }
      } else {
        styles += r.selectors.map(selector) + rule(r.rule) + '\n';
        if (hasShadowRoot) {
          styles += r.selectors.map(shadowSelector) + rule(r.rule) + '\n';
        }
      }
    });

    var el = document.createElement('style');
    el.textContent = styles;
    document.head.appendChild(el);
  }
})();

/**
 * This is the constructor for new PointerEvents.
 *
 * New Pointer Events must be given a type, and an optional dictionary of
 * initialization properties.
 *
 * Due to certain platform requirements, events returned from the constructor
 * identify as MouseEvents.
 *
 * @constructor
 * @param {String} inType The type of the event to create.
 * @param {Object} [inDict] An optional dictionary of initial event properties.
 * @return {Event} A new PointerEvent of type `inType` and initialized with properties from `inDict`.
 */
(function(scope) {

  var MOUSE_PROPS = [
    'bubbles',
    'cancelable',
    'view',
    'detail',
    'screenX',
    'screenY',
    'clientX',
    'clientY',
    'ctrlKey',
    'altKey',
    'shiftKey',
    'metaKey',
    'button',
    'relatedTarget',
    'pageX',
    'pageY'
  ];

  var MOUSE_DEFAULTS = [
    false,
    false,
    null,
    null,
    0,
    0,
    0,
    0,
    false,
    false,
    false,
    false,
    0,
    null,
    0,
    0
  ];

  var NOP_FACTORY = function(){ return function(){}; };

  var eventFactory = {
    // TODO(dfreedm): this is overridden by tap recognizer, needs review
    preventTap: NOP_FACTORY,
    makeBaseEvent: function(inType, inDict) {
      var e = document.createEvent('Event');
      e.initEvent(inType, inDict.bubbles || false, inDict.cancelable || false);
      e.preventTap = eventFactory.preventTap(e);
      return e;
    },
    makeGestureEvent: function(inType, inDict) {
      inDict = inDict || Object.create(null);

      var e = this.makeBaseEvent(inType, inDict);
      for (var i = 0, keys = Object.keys(inDict), k; i < keys.length; i++) {
        k = keys[i];
        e[k] = inDict[k];
      }
      return e;
    },
    makePointerEvent: function(inType, inDict) {
      inDict = inDict || Object.create(null);

      var e = this.makeBaseEvent(inType, inDict);
      // define inherited MouseEvent properties
      for(var i = 0, p; i < MOUSE_PROPS.length; i++) {
        p = MOUSE_PROPS[i];
        e[p] = inDict[p] || MOUSE_DEFAULTS[i];
      }
      e.buttons = inDict.buttons || 0;

      // Spec requires that pointers without pressure specified use 0.5 for down
      // state and 0 for up state.
      var pressure = 0;
      if (inDict.pressure) {
        pressure = inDict.pressure;
      } else {
        pressure = e.buttons ? 0.5 : 0;
      }

      // add x/y properties aliased to clientX/Y
      e.x = e.clientX;
      e.y = e.clientY;

      // define the properties of the PointerEvent interface
      e.pointerId = inDict.pointerId || 0;
      e.width = inDict.width || 0;
      e.height = inDict.height || 0;
      e.pressure = pressure;
      e.tiltX = inDict.tiltX || 0;
      e.tiltY = inDict.tiltY || 0;
      e.pointerType = inDict.pointerType || '';
      e.hwTimestamp = inDict.hwTimestamp || 0;
      e.isPrimary = inDict.isPrimary || false;
      e._source = inDict._source || '';
      return e;
    }
  };

  scope.eventFactory = eventFactory;
})(window.PolymerGestures);

/**
 * This module implements an map of pointer states
 */
(function(scope) {
  var USE_MAP = window.Map && window.Map.prototype.forEach;
  var POINTERS_FN = function(){ return this.size; };
  function PointerMap() {
    if (USE_MAP) {
      var m = new Map();
      m.pointers = POINTERS_FN;
      return m;
    } else {
      this.keys = [];
      this.values = [];
    }
  }

  PointerMap.prototype = {
    set: function(inId, inEvent) {
      var i = this.keys.indexOf(inId);
      if (i > -1) {
        this.values[i] = inEvent;
      } else {
        this.keys.push(inId);
        this.values.push(inEvent);
      }
    },
    has: function(inId) {
      return this.keys.indexOf(inId) > -1;
    },
    'delete': function(inId) {
      var i = this.keys.indexOf(inId);
      if (i > -1) {
        this.keys.splice(i, 1);
        this.values.splice(i, 1);
      }
    },
    get: function(inId) {
      var i = this.keys.indexOf(inId);
      return this.values[i];
    },
    clear: function() {
      this.keys.length = 0;
      this.values.length = 0;
    },
    // return value, key, map
    forEach: function(callback, thisArg) {
      this.values.forEach(function(v, i) {
        callback.call(thisArg, v, this.keys[i], this);
      }, this);
    },
    pointers: function() {
      return this.keys.length;
    }
  };

  scope.PointerMap = PointerMap;
})(window.PolymerGestures);

(function(scope) {
  var CLONE_PROPS = [
    // MouseEvent
    'bubbles',
    'cancelable',
    'view',
    'detail',
    'screenX',
    'screenY',
    'clientX',
    'clientY',
    'ctrlKey',
    'altKey',
    'shiftKey',
    'metaKey',
    'button',
    'relatedTarget',
    // DOM Level 3
    'buttons',
    // PointerEvent
    'pointerId',
    'width',
    'height',
    'pressure',
    'tiltX',
    'tiltY',
    'pointerType',
    'hwTimestamp',
    'isPrimary',
    // event instance
    'type',
    'target',
    'currentTarget',
    'which',
    'pageX',
    'pageY',
    'timeStamp',
    // gesture addons
    'preventTap',
    'tapPrevented',
    '_source'
  ];

  var CLONE_DEFAULTS = [
    // MouseEvent
    false,
    false,
    null,
    null,
    0,
    0,
    0,
    0,
    false,
    false,
    false,
    false,
    0,
    null,
    // DOM Level 3
    0,
    // PointerEvent
    0,
    0,
    0,
    0,
    0,
    0,
    '',
    0,
    false,
    // event instance
    '',
    null,
    null,
    0,
    0,
    0,
    0,
    function(){},
    false
  ];

  var HAS_SVG_INSTANCE = (typeof SVGElementInstance !== 'undefined');

  var eventFactory = scope.eventFactory;

  // set of recognizers to run for the currently handled event
  var currentGestures;

  /**
   * This module is for normalizing events. Mouse and Touch events will be
   * collected here, and fire PointerEvents that have the same semantics, no
   * matter the source.
   * Events fired:
   *   - pointerdown: a pointing is added
   *   - pointerup: a pointer is removed
   *   - pointermove: a pointer is moved
   *   - pointerover: a pointer crosses into an element
   *   - pointerout: a pointer leaves an element
   *   - pointercancel: a pointer will no longer generate events
   */
  var dispatcher = {
    IS_IOS: false,
    pointermap: new scope.PointerMap(),
    requiredGestures: new scope.PointerMap(),
    eventMap: Object.create(null),
    // Scope objects for native events.
    // This exists for ease of testing.
    eventSources: Object.create(null),
    eventSourceList: [],
    gestures: [],
    // map gesture event -> {listeners: int, index: gestures[int]}
    dependencyMap: {
      // make sure down and up are in the map to trigger "register"
      down: {listeners: 0, index: -1},
      up: {listeners: 0, index: -1}
    },
    gestureQueue: [],
    /**
     * Add a new event source that will generate pointer events.
     *
     * `inSource` must contain an array of event names named `events`, and
     * functions with the names specified in the `events` array.
     * @param {string} name A name for the event source
     * @param {Object} source A new source of platform events.
     */
    registerSource: function(name, source) {
      var s = source;
      var newEvents = s.events;
      if (newEvents) {
        newEvents.forEach(function(e) {
          if (s[e]) {
            this.eventMap[e] = s[e].bind(s);
          }
        }, this);
        this.eventSources[name] = s;
        this.eventSourceList.push(s);
      }
    },
    registerGesture: function(name, source) {
      var obj = Object.create(null);
      obj.listeners = 0;
      obj.index = this.gestures.length;
      for (var i = 0, g; i < source.exposes.length; i++) {
        g = source.exposes[i].toLowerCase();
        this.dependencyMap[g] = obj;
      }
      this.gestures.push(source);
    },
    register: function(element, initial) {
      var l = this.eventSourceList.length;
      for (var i = 0, es; (i < l) && (es = this.eventSourceList[i]); i++) {
        // call eventsource register
        es.register.call(es, element, initial);
      }
    },
    unregister: function(element) {
      var l = this.eventSourceList.length;
      for (var i = 0, es; (i < l) && (es = this.eventSourceList[i]); i++) {
        // call eventsource register
        es.unregister.call(es, element);
      }
    },
    // EVENTS
    down: function(inEvent) {
      this.requiredGestures.set(inEvent.pointerId, currentGestures);
      this.fireEvent('down', inEvent);
    },
    move: function(inEvent) {
      // pipe move events into gesture queue directly
      inEvent.type = 'move';
      this.fillGestureQueue(inEvent);
    },
    up: function(inEvent) {
      this.fireEvent('up', inEvent);
      this.requiredGestures.delete(inEvent.pointerId);
    },
    cancel: function(inEvent) {
      inEvent.tapPrevented = true;
      this.fireEvent('up', inEvent);
      this.requiredGestures.delete(inEvent.pointerId);
    },
    addGestureDependency: function(node, currentGestures) {
      var gesturesWanted = node._pgEvents;
      if (gesturesWanted && currentGestures) {
        var gk = Object.keys(gesturesWanted);
        for (var i = 0, r, ri, g; i < gk.length; i++) {
          // gesture
          g = gk[i];
          if (gesturesWanted[g] > 0) {
            // lookup gesture recognizer
            r = this.dependencyMap[g];
            // recognizer index
            ri = r ? r.index : -1;
            currentGestures[ri] = true;
          }
        }
      }
    },
    // LISTENER LOGIC
    eventHandler: function(inEvent) {
      // This is used to prevent multiple dispatch of events from
      // platform events. This can happen when two elements in different scopes
      // are set up to create pointer events, which is relevant to Shadow DOM.

      var type = inEvent.type;

      // only generate the list of desired events on "down"
      if (type === 'touchstart' || type === 'mousedown' || type === 'pointerdown' || type === 'MSPointerDown') {
        if (!inEvent._handledByPG) {
          currentGestures = {};
        }

        // in IOS mode, there is only a listener on the document, so this is not re-entrant
        if (this.IS_IOS) {
          var ev = inEvent;
          if (type === 'touchstart') {
            var ct = inEvent.changedTouches[0];
            // set up a fake event to give to the path builder
            ev = {target: inEvent.target, clientX: ct.clientX, clientY: ct.clientY, path: inEvent.path};
          }
          // use event path if available, otherwise build a path from target finding
          var nodes = inEvent.path || scope.targetFinding.path(ev);
          for (var i = 0, n; i < nodes.length; i++) {
            n = nodes[i];
            this.addGestureDependency(n, currentGestures);
          }
        } else {
          this.addGestureDependency(inEvent.currentTarget, currentGestures);
        }
      }

      if (inEvent._handledByPG) {
        return;
      }
      var fn = this.eventMap && this.eventMap[type];
      if (fn) {
        fn(inEvent);
      }
      inEvent._handledByPG = true;
    },
    // set up event listeners
    listen: function(target, events) {
      for (var i = 0, l = events.length, e; (i < l) && (e = events[i]); i++) {
        this.addEvent(target, e);
      }
    },
    // remove event listeners
    unlisten: function(target, events) {
      for (var i = 0, l = events.length, e; (i < l) && (e = events[i]); i++) {
        this.removeEvent(target, e);
      }
    },
    addEvent: function(target, eventName) {
      target.addEventListener(eventName, this.boundHandler);
    },
    removeEvent: function(target, eventName) {
      target.removeEventListener(eventName, this.boundHandler);
    },
    // EVENT CREATION AND TRACKING
    /**
     * Creates a new Event of type `inType`, based on the information in
     * `inEvent`.
     *
     * @param {string} inType A string representing the type of event to create
     * @param {Event} inEvent A platform event with a target
     * @return {Event} A PointerEvent of type `inType`
     */
    makeEvent: function(inType, inEvent) {
      var e = eventFactory.makePointerEvent(inType, inEvent);
      e.preventDefault = inEvent.preventDefault;
      e.tapPrevented = inEvent.tapPrevented;
      e._target = e._target || inEvent.target;
      return e;
    },
    // make and dispatch an event in one call
    fireEvent: function(inType, inEvent) {
      var e = this.makeEvent(inType, inEvent);
      return this.dispatchEvent(e);
    },
    /**
     * Returns a snapshot of inEvent, with writable properties.
     *
     * @param {Event} inEvent An event that contains properties to copy.
     * @return {Object} An object containing shallow copies of `inEvent`'s
     *    properties.
     */
    cloneEvent: function(inEvent) {
      var eventCopy = Object.create(null), p;
      for (var i = 0; i < CLONE_PROPS.length; i++) {
        p = CLONE_PROPS[i];
        eventCopy[p] = inEvent[p] || CLONE_DEFAULTS[i];
        // Work around SVGInstanceElement shadow tree
        // Return the <use> element that is represented by the instance for Safari, Chrome, IE.
        // This is the behavior implemented by Firefox.
        if (p === 'target' || p === 'relatedTarget') {
          if (HAS_SVG_INSTANCE && eventCopy[p] instanceof SVGElementInstance) {
            eventCopy[p] = eventCopy[p].correspondingUseElement;
          }
        }
      }
      // keep the semantics of preventDefault
      eventCopy.preventDefault = function() {
        inEvent.preventDefault();
      };
      return eventCopy;
    },
    /**
     * Dispatches the event to its target.
     *
     * @param {Event} inEvent The event to be dispatched.
     * @return {Boolean} True if an event handler returns true, false otherwise.
     */
    dispatchEvent: function(inEvent) {
      var t = inEvent._target;
      if (t) {
        t.dispatchEvent(inEvent);
        // clone the event for the gesture system to process
        // clone after dispatch to pick up gesture prevention code
        var clone = this.cloneEvent(inEvent);
        clone.target = t;
        this.fillGestureQueue(clone);
      }
    },
    gestureTrigger: function() {
      // process the gesture queue
      for (var i = 0, e, rg; i < this.gestureQueue.length; i++) {
        e = this.gestureQueue[i];
        rg = e._requiredGestures;
        if (rg) {
          for (var j = 0, g, fn; j < this.gestures.length; j++) {
            // only run recognizer if an element in the source event's path is listening for those gestures
            if (rg[j]) {
              g = this.gestures[j];
              fn = g[e.type];
              if (fn) {
                fn.call(g, e);
              }
            }
          }
        }
      }
      this.gestureQueue.length = 0;
    },
    fillGestureQueue: function(ev) {
      // only trigger the gesture queue once
      if (!this.gestureQueue.length) {
        requestAnimationFrame(this.boundGestureTrigger);
      }
      ev._requiredGestures = this.requiredGestures.get(ev.pointerId);
      this.gestureQueue.push(ev);
    }
  };
  dispatcher.boundHandler = dispatcher.eventHandler.bind(dispatcher);
  dispatcher.boundGestureTrigger = dispatcher.gestureTrigger.bind(dispatcher);
  scope.dispatcher = dispatcher;

  /**
   * Listen for `gesture` on `node` with the `handler` function
   *
   * If `handler` is the first listener for `gesture`, the underlying gesture recognizer is then enabled.
   *
   * @param {Element} node
   * @param {string} gesture
   * @return Boolean `gesture` is a valid gesture
   */
  scope.activateGesture = function(node, gesture) {
    var g = gesture.toLowerCase();
    var dep = dispatcher.dependencyMap[g];
    if (dep) {
      var recognizer = dispatcher.gestures[dep.index];
      if (!node._pgListeners) {
        dispatcher.register(node);
        node._pgListeners = 0;
      }
      // TODO(dfreedm): re-evaluate bookkeeping to avoid using attributes
      if (recognizer) {
        var touchAction = recognizer.defaultActions && recognizer.defaultActions[g];
        var actionNode;
        switch(node.nodeType) {
          case Node.ELEMENT_NODE:
            actionNode = node;
          break;
          case Node.DOCUMENT_FRAGMENT_NODE:
            actionNode = node.host;
          break;
          default:
            actionNode = null;
          break;
        }
        if (touchAction && actionNode && !actionNode.hasAttribute('touch-action')) {
          actionNode.setAttribute('touch-action', touchAction);
        }
      }
      if (!node._pgEvents) {
        node._pgEvents = {};
      }
      node._pgEvents[g] = (node._pgEvents[g] || 0) + 1;
      node._pgListeners++;
    }
    return Boolean(dep);
  };

  /**
   *
   * Listen for `gesture` from `node` with `handler` function.
   *
   * @param {Element} node
   * @param {string} gesture
   * @param {Function} handler
   * @param {Boolean} capture
   */
  scope.addEventListener = function(node, gesture, handler, capture) {
    if (handler) {
      scope.activateGesture(node, gesture);
      node.addEventListener(gesture, handler, capture);
    }
  };

  /**
   * Tears down the gesture configuration for `node`
   *
   * If `handler` is the last listener for `gesture`, the underlying gesture recognizer is disabled.
   *
   * @param {Element} node
   * @param {string} gesture
   * @return Boolean `gesture` is a valid gesture
   */
  scope.deactivateGesture = function(node, gesture) {
    var g = gesture.toLowerCase();
    var dep = dispatcher.dependencyMap[g];
    if (dep) {
      if (node._pgListeners > 0) {
        node._pgListeners--;
      }
      if (node._pgListeners === 0) {
        dispatcher.unregister(node);
      }
      if (node._pgEvents) {
        if (node._pgEvents[g] > 0) {
          node._pgEvents[g]--;
        } else {
          node._pgEvents[g] = 0;
        }
      }
    }
    return Boolean(dep);
  };

  /**
   * Stop listening for `gesture` from `node` with `handler` function.
   *
   * @param {Element} node
   * @param {string} gesture
   * @param {Function} handler
   * @param {Boolean} capture
   */
  scope.removeEventListener = function(node, gesture, handler, capture) {
    if (handler) {
      scope.deactivateGesture(node, gesture);
      node.removeEventListener(gesture, handler, capture);
    }
  };
})(window.PolymerGestures);

(function (scope) {
  var dispatcher = scope.dispatcher;
  var pointermap = dispatcher.pointermap;
  // radius around touchend that swallows mouse events
  var DEDUP_DIST = 25;

  var WHICH_TO_BUTTONS = [0, 1, 4, 2];

  var CURRENT_BUTTONS = 0;
  var HAS_BUTTONS = false;
  try {
    HAS_BUTTONS = new MouseEvent('test', {buttons: 1}).buttons === 1;
  } catch (e) {}

  // handler block for native mouse events
  var mouseEvents = {
    POINTER_ID: 1,
    POINTER_TYPE: 'mouse',
    events: [
      'mousedown',
      'mousemove',
      'mouseup'
    ],
    exposes: [
      'down',
      'up',
      'move'
    ],
    register: function(target) {
      dispatcher.listen(target, this.events);
    },
    unregister: function(target) {
      if (target === document) {
        return;
      }
      dispatcher.unlisten(target, this.events);
    },
    lastTouches: [],
    // collide with the global mouse listener
    isEventSimulatedFromTouch: function(inEvent) {
      var lts = this.lastTouches;
      var x = inEvent.clientX, y = inEvent.clientY;
      for (var i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {
        // simulated mouse events will be swallowed near a primary touchend
        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DIST && dy <= DEDUP_DIST) {
          return true;
        }
      }
    },
    prepareEvent: function(inEvent) {
      var e = dispatcher.cloneEvent(inEvent);
      e.pointerId = this.POINTER_ID;
      e.isPrimary = true;
      e.pointerType = this.POINTER_TYPE;
      e._source = 'mouse';
      if (!HAS_BUTTONS) {
        var type = inEvent.type;
        var bit = WHICH_TO_BUTTONS[inEvent.which] || 0;
        if (type === 'mousedown') {
          CURRENT_BUTTONS |= bit;
        } else if (type === 'mouseup') {
          CURRENT_BUTTONS &= ~bit;
        }
        e.buttons = CURRENT_BUTTONS;
      }
      return e;
    },
    mousedown: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var p = pointermap.has(this.POINTER_ID);
        var e = this.prepareEvent(inEvent);
        e.target = scope.findTarget(inEvent);
        pointermap.set(this.POINTER_ID, e.target);
        dispatcher.down(e);
      }
    },
    mousemove: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var target = pointermap.get(this.POINTER_ID);
        if (target) {
          var e = this.prepareEvent(inEvent);
          e.target = target;
          // handle case where we missed a mouseup
          if ((HAS_BUTTONS ? e.buttons : e.which) === 0) {
            if (!HAS_BUTTONS) {
              CURRENT_BUTTONS = e.buttons = 0;
            }
            dispatcher.cancel(e);
            this.cleanupMouse(e.buttons);
          } else {
            dispatcher.move(e);
          }
        }
      }
    },
    mouseup: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        e.relatedTarget = scope.findTarget(inEvent);
        e.target = pointermap.get(this.POINTER_ID);
        dispatcher.up(e);
        this.cleanupMouse(e.buttons);
      }
    },
    cleanupMouse: function(buttons) {
      if (buttons === 0) {
        pointermap.delete(this.POINTER_ID);
      }
    }
  };

  scope.mouseEvents = mouseEvents;
})(window.PolymerGestures);

(function(scope) {
  var dispatcher = scope.dispatcher;
  var allShadows = scope.targetFinding.allShadows.bind(scope.targetFinding);
  var pointermap = dispatcher.pointermap;
  var touchMap = Array.prototype.map.call.bind(Array.prototype.map);
  // This should be long enough to ignore compat mouse events made by touch
  var DEDUP_TIMEOUT = 2500;
  var DEDUP_DIST = 25;
  var CLICK_COUNT_TIMEOUT = 200;
  var HYSTERESIS = 20;
  var ATTRIB = 'touch-action';
  // TODO(dfreedm): disable until http://crbug.com/399765 is resolved
  // var HAS_TOUCH_ACTION = ATTRIB in document.head.style;
  var HAS_TOUCH_ACTION = false;

  // handler block for native touch events
  var touchEvents = {
    IS_IOS: false,
    events: [
      'touchstart',
      'touchmove',
      'touchend',
      'touchcancel'
    ],
    exposes: [
      'down',
      'up',
      'move'
    ],
    register: function(target, initial) {
      if (this.IS_IOS ? initial : !initial) {
        dispatcher.listen(target, this.events);
      }
    },
    unregister: function(target) {
      if (!this.IS_IOS) {
        dispatcher.unlisten(target, this.events);
      }
    },
    scrollTypes: {
      EMITTER: 'none',
      XSCROLLER: 'pan-x',
      YSCROLLER: 'pan-y',
    },
    touchActionToScrollType: function(touchAction) {
      var t = touchAction;
      var st = this.scrollTypes;
      if (t === st.EMITTER) {
        return 'none';
      } else if (t === st.XSCROLLER) {
        return 'X';
      } else if (t === st.YSCROLLER) {
        return 'Y';
      } else {
        return 'XY';
      }
    },
    POINTER_TYPE: 'touch',
    firstTouch: null,
    isPrimaryTouch: function(inTouch) {
      return this.firstTouch === inTouch.identifier;
    },
    setPrimaryTouch: function(inTouch) {
      // set primary touch if there no pointers, or the only pointer is the mouse
      if (pointermap.pointers() === 0 || (pointermap.pointers() === 1 && pointermap.has(1))) {
        this.firstTouch = inTouch.identifier;
        this.firstXY = {X: inTouch.clientX, Y: inTouch.clientY};
        this.firstTarget = inTouch.target;
        this.scrolling = null;
        this.cancelResetClickCount();
      }
    },
    removePrimaryPointer: function(inPointer) {
      if (inPointer.isPrimary) {
        this.firstTouch = null;
        this.firstXY = null;
        this.resetClickCount();
      }
    },
    clickCount: 0,
    resetId: null,
    resetClickCount: function() {
      var fn = function() {
        this.clickCount = 0;
        this.resetId = null;
      }.bind(this);
      this.resetId = setTimeout(fn, CLICK_COUNT_TIMEOUT);
    },
    cancelResetClickCount: function() {
      if (this.resetId) {
        clearTimeout(this.resetId);
      }
    },
    typeToButtons: function(type) {
      var ret = 0;
      if (type === 'touchstart' || type === 'touchmove') {
        ret = 1;
      }
      return ret;
    },
    findTarget: function(touch, id) {
      if (this.currentTouchEvent.type === 'touchstart') {
        if (this.isPrimaryTouch(touch)) {
          var fastPath = {
            clientX: touch.clientX,
            clientY: touch.clientY,
            path: this.currentTouchEvent.path,
            target: this.currentTouchEvent.target
          };
          return scope.findTarget(fastPath);
        } else {
          return scope.findTarget(touch);
        }
      }
      // reuse target we found in touchstart
      return pointermap.get(id);
    },
    touchToPointer: function(inTouch) {
      var cte = this.currentTouchEvent;
      var e = dispatcher.cloneEvent(inTouch);
      // Spec specifies that pointerId 1 is reserved for Mouse.
      // Touch identifiers can start at 0.
      // Add 2 to the touch identifier for compatibility.
      var id = e.pointerId = inTouch.identifier + 2;
      e.target = this.findTarget(inTouch, id);
      e.bubbles = true;
      e.cancelable = true;
      e.detail = this.clickCount;
      e.buttons = this.typeToButtons(cte.type);
      e.width = inTouch.webkitRadiusX || inTouch.radiusX || 0;
      e.height = inTouch.webkitRadiusY || inTouch.radiusY || 0;
      e.pressure = inTouch.webkitForce || inTouch.force || 0.5;
      e.isPrimary = this.isPrimaryTouch(inTouch);
      e.pointerType = this.POINTER_TYPE;
      e._source = 'touch';
      // forward touch preventDefaults
      var self = this;
      e.preventDefault = function() {
        self.scrolling = false;
        self.firstXY = null;
        cte.preventDefault();
      };
      return e;
    },
    processTouches: function(inEvent, inFunction) {
      var tl = inEvent.changedTouches;
      this.currentTouchEvent = inEvent;
      for (var i = 0, t, p; i < tl.length; i++) {
        t = tl[i];
        p = this.touchToPointer(t);
        if (inEvent.type === 'touchstart') {
          pointermap.set(p.pointerId, p.target);
        }
        if (pointermap.has(p.pointerId)) {
          inFunction.call(this, p);
        }
        if (inEvent.type === 'touchend' || inEvent._cancel) {
          this.cleanUpPointer(p);
        }
      }
    },
    // For single axis scrollers, determines whether the element should emit
    // pointer events or behave as a scroller
    shouldScroll: function(inEvent) {
      if (this.firstXY) {
        var ret;
        var touchAction = scope.targetFinding.findTouchAction(inEvent);
        var scrollAxis = this.touchActionToScrollType(touchAction);
        if (scrollAxis === 'none') {
          // this element is a touch-action: none, should never scroll
          ret = false;
        } else if (scrollAxis === 'XY') {
          // this element should always scroll
          ret = true;
        } else {
          var t = inEvent.changedTouches[0];
          // check the intended scroll axis, and other axis
          var a = scrollAxis;
          var oa = scrollAxis === 'Y' ? 'X' : 'Y';
          var da = Math.abs(t['client' + a] - this.firstXY[a]);
          var doa = Math.abs(t['client' + oa] - this.firstXY[oa]);
          // if delta in the scroll axis > delta other axis, scroll instead of
          // making events
          ret = da >= doa;
        }
        return ret;
      }
    },
    findTouch: function(inTL, inId) {
      for (var i = 0, l = inTL.length, t; i < l && (t = inTL[i]); i++) {
        if (t.identifier === inId) {
          return true;
        }
      }
    },
    // In some instances, a touchstart can happen without a touchend. This
    // leaves the pointermap in a broken state.
    // Therefore, on every touchstart, we remove the touches that did not fire a
    // touchend event.
    // To keep state globally consistent, we fire a
    // pointercancel for this "abandoned" touch
    vacuumTouches: function(inEvent) {
      var tl = inEvent.touches;
      // pointermap.pointers() should be < tl.length here, as the touchstart has not
      // been processed yet.
      if (pointermap.pointers() >= tl.length) {
        var d = [];
        pointermap.forEach(function(value, key) {
          // Never remove pointerId == 1, which is mouse.
          // Touch identifiers are 2 smaller than their pointerId, which is the
          // index in pointermap.
          if (key !== 1 && !this.findTouch(tl, key - 2)) {
            var p = value;
            d.push(p);
          }
        }, this);
        d.forEach(function(p) {
          this.cancel(p);
          pointermap.delete(p.pointerId);
        });
      }
    },
    touchstart: function(inEvent) {
      this.vacuumTouches(inEvent);
      this.setPrimaryTouch(inEvent.changedTouches[0]);
      this.dedupSynthMouse(inEvent);
      if (!this.scrolling) {
        this.clickCount++;
        this.processTouches(inEvent, this.down);
      }
    },
    down: function(inPointer) {
      dispatcher.down(inPointer);
    },
    touchmove: function(inEvent) {
      if (HAS_TOUCH_ACTION) {
        // touchevent.cancelable == false is sent when the page is scrolling under native Touch Action in Chrome 36
        // https://groups.google.com/a/chromium.org/d/msg/input-dev/wHnyukcYBcA/b9kmtwM1jJQJ
        if (inEvent.cancelable) {
          this.processTouches(inEvent, this.move);
        }
      } else {
        if (!this.scrolling) {
          if (this.scrolling === null && this.shouldScroll(inEvent)) {
            this.scrolling = true;
          } else {
            this.scrolling = false;
            inEvent.preventDefault();
            this.processTouches(inEvent, this.move);
          }
        } else if (this.firstXY) {
          var t = inEvent.changedTouches[0];
          var dx = t.clientX - this.firstXY.X;
          var dy = t.clientY - this.firstXY.Y;
          var dd = Math.sqrt(dx * dx + dy * dy);
          if (dd >= HYSTERESIS) {
            this.touchcancel(inEvent);
            this.scrolling = true;
            this.firstXY = null;
          }
        }
      }
    },
    move: function(inPointer) {
      dispatcher.move(inPointer);
    },
    touchend: function(inEvent) {
      this.dedupSynthMouse(inEvent);
      this.processTouches(inEvent, this.up);
    },
    up: function(inPointer) {
      inPointer.relatedTarget = scope.findTarget(inPointer);
      dispatcher.up(inPointer);
    },
    cancel: function(inPointer) {
      dispatcher.cancel(inPointer);
    },
    touchcancel: function(inEvent) {
      inEvent._cancel = true;
      this.processTouches(inEvent, this.cancel);
    },
    cleanUpPointer: function(inPointer) {
      pointermap['delete'](inPointer.pointerId);
      this.removePrimaryPointer(inPointer);
    },
    // prevent synth mouse events from creating pointer events
    dedupSynthMouse: function(inEvent) {
      var lts = scope.mouseEvents.lastTouches;
      var t = inEvent.changedTouches[0];
      // only the primary finger will synth mouse events
      if (this.isPrimaryTouch(t)) {
        // remember x/y of last touch
        var lt = {x: t.clientX, y: t.clientY};
        lts.push(lt);
        var fn = (function(lts, lt){
          var i = lts.indexOf(lt);
          if (i > -1) {
            lts.splice(i, 1);
          }
        }).bind(null, lts, lt);
        setTimeout(fn, DEDUP_TIMEOUT);
      }
    }
  };

  // prevent "ghost clicks" that come from elements that were removed in a touch handler
  var STOP_PROP_FN = Event.prototype.stopImmediatePropagation || Event.prototype.stopPropagation;
  document.addEventListener('click', function(ev) {
    var x = ev.clientX, y = ev.clientY;
    // check if a click is within DEDUP_DIST px radius of the touchstart
    var closeTo = function(touch) {
      var dx = Math.abs(x - touch.x), dy = Math.abs(y - touch.y);
      return (dx <= DEDUP_DIST && dy <= DEDUP_DIST);
    };
    // if click coordinates are close to touch coordinates, assume the click came from a touch
    var wasTouched = scope.mouseEvents.lastTouches.some(closeTo);
    // if the click came from touch, and the touchstart target is not in the path of the click event,
    // then the touchstart target was probably removed, and the click should be "busted"
    var path = scope.targetFinding.path(ev);
    if (wasTouched) {
      for (var i = 0; i < path.length; i++) {
        if (path[i] === touchEvents.firstTarget) {
          return;
        }
      }
      ev.preventDefault();
      STOP_PROP_FN.call(ev);
    }
  }, true);

  scope.touchEvents = touchEvents;
})(window.PolymerGestures);

(function(scope) {
  var dispatcher = scope.dispatcher;
  var pointermap = dispatcher.pointermap;
  var HAS_BITMAP_TYPE = window.MSPointerEvent && typeof window.MSPointerEvent.MSPOINTER_TYPE_MOUSE === 'number';
  var msEvents = {
    events: [
      'MSPointerDown',
      'MSPointerMove',
      'MSPointerUp',
      'MSPointerCancel',
    ],
    register: function(target) {
      dispatcher.listen(target, this.events);
    },
    unregister: function(target) {
      if (target === document) {
        return;
      }
      dispatcher.unlisten(target, this.events);
    },
    POINTER_TYPES: [
      '',
      'unavailable',
      'touch',
      'pen',
      'mouse'
    ],
    prepareEvent: function(inEvent) {
      var e = inEvent;
      e = dispatcher.cloneEvent(inEvent);
      if (HAS_BITMAP_TYPE) {
        e.pointerType = this.POINTER_TYPES[inEvent.pointerType];
      }
      e._source = 'ms';
      return e;
    },
    cleanup: function(id) {
      pointermap['delete'](id);
    },
    MSPointerDown: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      e.target = scope.findTarget(inEvent);
      pointermap.set(inEvent.pointerId, e.target);
      dispatcher.down(e);
    },
    MSPointerMove: function(inEvent) {
      var target = pointermap.get(inEvent.pointerId);
      if (target) {
        var e = this.prepareEvent(inEvent);
        e.target = target;
        dispatcher.move(e);
      }
    },
    MSPointerUp: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      e.relatedTarget = scope.findTarget(inEvent);
      e.target = pointermap.get(e.pointerId);
      dispatcher.up(e);
      this.cleanup(inEvent.pointerId);
    },
    MSPointerCancel: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      e.relatedTarget = scope.findTarget(inEvent);
      e.target = pointermap.get(e.pointerId);
      dispatcher.cancel(e);
      this.cleanup(inEvent.pointerId);
    }
  };

  scope.msEvents = msEvents;
})(window.PolymerGestures);

(function(scope) {
  var dispatcher = scope.dispatcher;
  var pointermap = dispatcher.pointermap;
  var pointerEvents = {
    events: [
      'pointerdown',
      'pointermove',
      'pointerup',
      'pointercancel'
    ],
    prepareEvent: function(inEvent) {
      var e = dispatcher.cloneEvent(inEvent);
      e._source = 'pointer';
      return e;
    },
    register: function(target) {
      dispatcher.listen(target, this.events);
    },
    unregister: function(target) {
      if (target === document) {
        return;
      }
      dispatcher.unlisten(target, this.events);
    },
    cleanup: function(id) {
      pointermap['delete'](id);
    },
    pointerdown: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      e.target = scope.findTarget(inEvent);
      pointermap.set(e.pointerId, e.target);
      dispatcher.down(e);
    },
    pointermove: function(inEvent) {
      var target = pointermap.get(inEvent.pointerId);
      if (target) {
        var e = this.prepareEvent(inEvent);
        e.target = target;
        dispatcher.move(e);
      }
    },
    pointerup: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      e.relatedTarget = scope.findTarget(inEvent);
      e.target = pointermap.get(e.pointerId);
      dispatcher.up(e);
      this.cleanup(inEvent.pointerId);
    },
    pointercancel: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      e.relatedTarget = scope.findTarget(inEvent);
      e.target = pointermap.get(e.pointerId);
      dispatcher.cancel(e);
      this.cleanup(inEvent.pointerId);
    }
  };

  scope.pointerEvents = pointerEvents;
})(window.PolymerGestures);

/**
 * This module contains the handlers for native platform events.
 * From here, the dispatcher is called to create unified pointer events.
 * Included are touch events (v1), mouse events, and MSPointerEvents.
 */
(function(scope) {

  var dispatcher = scope.dispatcher;
  var nav = window.navigator;

  if (window.PointerEvent) {
    dispatcher.registerSource('pointer', scope.pointerEvents);
  } else if (nav.msPointerEnabled) {
    dispatcher.registerSource('ms', scope.msEvents);
  } else {
    dispatcher.registerSource('mouse', scope.mouseEvents);
    if (window.ontouchstart !== undefined) {
      dispatcher.registerSource('touch', scope.touchEvents);
    }
  }

  // Work around iOS bugs https://bugs.webkit.org/show_bug.cgi?id=135628 and https://bugs.webkit.org/show_bug.cgi?id=136506
  var ua = navigator.userAgent;
  var IS_IOS = ua.match(/iPad|iPhone|iPod/) && 'ontouchstart' in window;

  dispatcher.IS_IOS = IS_IOS;
  scope.touchEvents.IS_IOS = IS_IOS;

  dispatcher.register(document, true);
})(window.PolymerGestures);

/**
 * This event denotes the beginning of a series of tracking events.
 *
 * @module PointerGestures
 * @submodule Events
 * @class trackstart
 */
/**
 * Pixels moved in the x direction since trackstart.
 * @type Number
 * @property dx
 */
/**
 * Pixes moved in the y direction since trackstart.
 * @type Number
 * @property dy
 */
/**
 * Pixels moved in the x direction since the last track.
 * @type Number
 * @property ddx
 */
/**
 * Pixles moved in the y direction since the last track.
 * @type Number
 * @property ddy
 */
/**
 * The clientX position of the track gesture.
 * @type Number
 * @property clientX
 */
/**
 * The clientY position of the track gesture.
 * @type Number
 * @property clientY
 */
/**
 * The pageX position of the track gesture.
 * @type Number
 * @property pageX
 */
/**
 * The pageY position of the track gesture.
 * @type Number
 * @property pageY
 */
/**
 * The screenX position of the track gesture.
 * @type Number
 * @property screenX
 */
/**
 * The screenY position of the track gesture.
 * @type Number
 * @property screenY
 */
/**
 * The last x axis direction of the pointer.
 * @type Number
 * @property xDirection
 */
/**
 * The last y axis direction of the pointer.
 * @type Number
 * @property yDirection
 */
/**
 * A shared object between all tracking events.
 * @type Object
 * @property trackInfo
 */
/**
 * The element currently under the pointer.
 * @type Element
 * @property relatedTarget
 */
/**
 * The type of pointer that make the track gesture.
 * @type String
 * @property pointerType
 */
/**
 *
 * This event fires for all pointer movement being tracked.
 *
 * @class track
 * @extends trackstart
 */
/**
 * This event fires when the pointer is no longer being tracked.
 *
 * @class trackend
 * @extends trackstart
 */

 (function(scope) {
   var dispatcher = scope.dispatcher;
   var eventFactory = scope.eventFactory;
   var pointermap = new scope.PointerMap();
   var track = {
     events: [
       'down',
       'move',
       'up',
     ],
     exposes: [
      'trackstart',
      'track',
      'trackx',
      'tracky',
      'trackend'
     ],
     defaultActions: {
       'track': 'none',
       'trackx': 'pan-y',
       'tracky': 'pan-x'
     },
     WIGGLE_THRESHOLD: 4,
     clampDir: function(inDelta) {
       return inDelta > 0 ? 1 : -1;
     },
     calcPositionDelta: function(inA, inB) {
       var x = 0, y = 0;
       if (inA && inB) {
         x = inB.pageX - inA.pageX;
         y = inB.pageY - inA.pageY;
       }
       return {x: x, y: y};
     },
     fireTrack: function(inType, inEvent, inTrackingData) {
       var t = inTrackingData;
       var d = this.calcPositionDelta(t.downEvent, inEvent);
       var dd = this.calcPositionDelta(t.lastMoveEvent, inEvent);
       if (dd.x) {
         t.xDirection = this.clampDir(dd.x);
       } else if (inType === 'trackx') {
         return;
       }
       if (dd.y) {
         t.yDirection = this.clampDir(dd.y);
       } else if (inType === 'tracky') {
         return;
       }
       var gestureProto = {
         bubbles: true,
         cancelable: true,
         trackInfo: t.trackInfo,
         relatedTarget: inEvent.relatedTarget,
         pointerType: inEvent.pointerType,
         pointerId: inEvent.pointerId,
         _source: 'track'
       };
       if (inType !== 'tracky') {
         gestureProto.x = inEvent.x;
         gestureProto.dx = d.x;
         gestureProto.ddx = dd.x;
         gestureProto.clientX = inEvent.clientX;
         gestureProto.pageX = inEvent.pageX;
         gestureProto.screenX = inEvent.screenX;
         gestureProto.xDirection = t.xDirection;
       }
       if (inType !== 'trackx') {
         gestureProto.dy = d.y;
         gestureProto.ddy = dd.y;
         gestureProto.y = inEvent.y;
         gestureProto.clientY = inEvent.clientY;
         gestureProto.pageY = inEvent.pageY;
         gestureProto.screenY = inEvent.screenY;
         gestureProto.yDirection = t.yDirection;
       }
       var e = eventFactory.makeGestureEvent(inType, gestureProto);
       t.downTarget.dispatchEvent(e);
     },
     down: function(inEvent) {
       if (inEvent.isPrimary && (inEvent.pointerType === 'mouse' ? inEvent.buttons === 1 : true)) {
         var p = {
           downEvent: inEvent,
           downTarget: inEvent.target,
           trackInfo: {},
           lastMoveEvent: null,
           xDirection: 0,
           yDirection: 0,
           tracking: false
         };
         pointermap.set(inEvent.pointerId, p);
       }
     },
     move: function(inEvent) {
       var p = pointermap.get(inEvent.pointerId);
       if (p) {
         if (!p.tracking) {
           var d = this.calcPositionDelta(p.downEvent, inEvent);
           var move = d.x * d.x + d.y * d.y;
           // start tracking only if finger moves more than WIGGLE_THRESHOLD
           if (move > this.WIGGLE_THRESHOLD) {
             p.tracking = true;
             p.lastMoveEvent = p.downEvent;
             this.fireTrack('trackstart', inEvent, p);
           }
         }
         if (p.tracking) {
           this.fireTrack('track', inEvent, p);
           this.fireTrack('trackx', inEvent, p);
           this.fireTrack('tracky', inEvent, p);
         }
         p.lastMoveEvent = inEvent;
       }
     },
     up: function(inEvent) {
       var p = pointermap.get(inEvent.pointerId);
       if (p) {
         if (p.tracking) {
           this.fireTrack('trackend', inEvent, p);
         }
         pointermap.delete(inEvent.pointerId);
       }
     }
   };
   dispatcher.registerGesture('track', track);
 })(window.PolymerGestures);

/**
 * This event is fired when a pointer is held down for 200ms.
 *
 * @module PointerGestures
 * @submodule Events
 * @class hold
 */
/**
 * Type of pointer that made the holding event.
 * @type String
 * @property pointerType
 */
/**
 * Screen X axis position of the held pointer
 * @type Number
 * @property clientX
 */
/**
 * Screen Y axis position of the held pointer
 * @type Number
 * @property clientY
 */
/**
 * Type of pointer that made the holding event.
 * @type String
 * @property pointerType
 */
/**
 * This event is fired every 200ms while a pointer is held down.
 *
 * @class holdpulse
 * @extends hold
 */
/**
 * Milliseconds pointer has been held down.
 * @type Number
 * @property holdTime
 */
/**
 * This event is fired when a held pointer is released or moved.
 *
 * @class release
 */

(function(scope) {
  var dispatcher = scope.dispatcher;
  var eventFactory = scope.eventFactory;
  var hold = {
    // wait at least HOLD_DELAY ms between hold and pulse events
    HOLD_DELAY: 200,
    // pointer can move WIGGLE_THRESHOLD pixels before not counting as a hold
    WIGGLE_THRESHOLD: 16,
    events: [
      'down',
      'move',
      'up',
    ],
    exposes: [
      'hold',
      'holdpulse',
      'release'
    ],
    heldPointer: null,
    holdJob: null,
    pulse: function() {
      var hold = Date.now() - this.heldPointer.timeStamp;
      var type = this.held ? 'holdpulse' : 'hold';
      this.fireHold(type, hold);
      this.held = true;
    },
    cancel: function() {
      clearInterval(this.holdJob);
      if (this.held) {
        this.fireHold('release');
      }
      this.held = false;
      this.heldPointer = null;
      this.target = null;
      this.holdJob = null;
    },
    down: function(inEvent) {
      if (inEvent.isPrimary && !this.heldPointer) {
        this.heldPointer = inEvent;
        this.target = inEvent.target;
        this.holdJob = setInterval(this.pulse.bind(this), this.HOLD_DELAY);
      }
    },
    up: function(inEvent) {
      if (this.heldPointer && this.heldPointer.pointerId === inEvent.pointerId) {
        this.cancel();
      }
    },
    move: function(inEvent) {
      if (this.heldPointer && this.heldPointer.pointerId === inEvent.pointerId) {
        var x = inEvent.clientX - this.heldPointer.clientX;
        var y = inEvent.clientY - this.heldPointer.clientY;
        if ((x * x + y * y) > this.WIGGLE_THRESHOLD) {
          this.cancel();
        }
      }
    },
    fireHold: function(inType, inHoldTime) {
      var p = {
        bubbles: true,
        cancelable: true,
        pointerType: this.heldPointer.pointerType,
        pointerId: this.heldPointer.pointerId,
        x: this.heldPointer.clientX,
        y: this.heldPointer.clientY,
        _source: 'hold'
      };
      if (inHoldTime) {
        p.holdTime = inHoldTime;
      }
      var e = eventFactory.makeGestureEvent(inType, p);
      this.target.dispatchEvent(e);
    }
  };
  dispatcher.registerGesture('hold', hold);
})(window.PolymerGestures);

/**
 * This event is fired when a pointer quickly goes down and up, and is used to
 * denote activation.
 *
 * Any gesture event can prevent the tap event from being created by calling
 * `event.preventTap`.
 *
 * Any pointer event can prevent the tap by setting the `tapPrevented` property
 * on itself.
 *
 * @module PointerGestures
 * @submodule Events
 * @class tap
 */
/**
 * X axis position of the tap.
 * @property x
 * @type Number
 */
/**
 * Y axis position of the tap.
 * @property y
 * @type Number
 */
/**
 * Type of the pointer that made the tap.
 * @property pointerType
 * @type String
 */
(function(scope) {
  var dispatcher = scope.dispatcher;
  var eventFactory = scope.eventFactory;
  var pointermap = new scope.PointerMap();
  var tap = {
    events: [
      'down',
      'up'
    ],
    exposes: [
      'tap'
    ],
    down: function(inEvent) {
      if (inEvent.isPrimary && !inEvent.tapPrevented) {
        pointermap.set(inEvent.pointerId, {
          target: inEvent.target,
          buttons: inEvent.buttons,
          x: inEvent.clientX,
          y: inEvent.clientY
        });
      }
    },
    shouldTap: function(e, downState) {
      var tap = true;
      if (e.pointerType === 'mouse') {
        // only allow left click to tap for mouse
        tap = (e.buttons ^ 1) && (downState.buttons & 1);
      }
      return tap && !e.tapPrevented;
    },
    up: function(inEvent) {
      var start = pointermap.get(inEvent.pointerId);
      if (start && this.shouldTap(inEvent, start)) {
        // up.relatedTarget is target currently under finger
        var t = scope.targetFinding.LCA(start.target, inEvent.relatedTarget);
        if (t) {
          var e = eventFactory.makeGestureEvent('tap', {
            bubbles: true,
            cancelable: true,
            x: inEvent.clientX,
            y: inEvent.clientY,
            detail: inEvent.detail,
            pointerType: inEvent.pointerType,
            pointerId: inEvent.pointerId,
            altKey: inEvent.altKey,
            ctrlKey: inEvent.ctrlKey,
            metaKey: inEvent.metaKey,
            shiftKey: inEvent.shiftKey,
            _source: 'tap'
          });
          t.dispatchEvent(e);
        }
      }
      pointermap.delete(inEvent.pointerId);
    }
  };
  // patch eventFactory to remove id from tap's pointermap for preventTap calls
  eventFactory.preventTap = function(e) {
    return function() {
      e.tapPrevented = true;
      pointermap.delete(e.pointerId);
    };
  };
  dispatcher.registerGesture('tap', tap);
})(window.PolymerGestures);

/*
 * Basic strategy: find the farthest apart points, use as diameter of circle
 * react to size change and rotation of the chord
 */

/**
 * @module pointer-gestures
 * @submodule Events
 * @class pinch
 */
/**
 * Scale of the pinch zoom gesture
 * @property scale
 * @type Number
 */
/**
 * Center X position of pointers causing pinch
 * @property centerX
 * @type Number
 */
/**
 * Center Y position of pointers causing pinch
 * @property centerY
 * @type Number
 */

/**
 * @module pointer-gestures
 * @submodule Events
 * @class rotate
 */
/**
 * Angle (in degrees) of rotation. Measured from starting positions of pointers.
 * @property angle
 * @type Number
 */
/**
 * Center X position of pointers causing rotation
 * @property centerX
 * @type Number
 */
/**
 * Center Y position of pointers causing rotation
 * @property centerY
 * @type Number
 */
(function(scope) {
  var dispatcher = scope.dispatcher;
  var eventFactory = scope.eventFactory;
  var pointermap = new scope.PointerMap();
  var RAD_TO_DEG = 180 / Math.PI;
  var pinch = {
    events: [
      'down',
      'up',
      'move',
      'cancel'
    ],
    exposes: [
      'pinch',
      'rotate'
    ],
    defaultActions: {
      'pinch': 'none',
      'rotate': 'none'
    },
    reference: {},
    down: function(inEvent) {
      pointermap.set(inEvent.pointerId, inEvent);
      if (pointermap.pointers() == 2) {
        var points = this.calcChord();
        var angle = this.calcAngle(points);
        this.reference = {
          angle: angle,
          diameter: points.diameter,
          target: scope.targetFinding.LCA(points.a.target, points.b.target)
        };
      }
    },
    up: function(inEvent) {
      var p = pointermap.get(inEvent.pointerId);
      if (p) {
        pointermap.delete(inEvent.pointerId);
      }
    },
    move: function(inEvent) {
      if (pointermap.has(inEvent.pointerId)) {
        pointermap.set(inEvent.pointerId, inEvent);
        if (pointermap.pointers() > 1) {
          this.calcPinchRotate();
        }
      }
    },
    cancel: function(inEvent) {
        this.up(inEvent);
    },
    firePinch: function(diameter, points) {
      var zoom = diameter / this.reference.diameter;
      var e = eventFactory.makeGestureEvent('pinch', {
        bubbles: true,
        cancelable: true,
        scale: zoom,
        centerX: points.center.x,
        centerY: points.center.y,
        _source: 'pinch'
      });
      this.reference.target.dispatchEvent(e);
    },
    fireRotate: function(angle, points) {
      var diff = Math.round((angle - this.reference.angle) % 360);
      var e = eventFactory.makeGestureEvent('rotate', {
        bubbles: true,
        cancelable: true,
        angle: diff,
        centerX: points.center.x,
        centerY: points.center.y,
        _source: 'pinch'
      });
      this.reference.target.dispatchEvent(e);
    },
    calcPinchRotate: function() {
      var points = this.calcChord();
      var diameter = points.diameter;
      var angle = this.calcAngle(points);
      if (diameter != this.reference.diameter) {
        this.firePinch(diameter, points);
      }
      if (angle != this.reference.angle) {
        this.fireRotate(angle, points);
      }
    },
    calcChord: function() {
      var pointers = [];
      pointermap.forEach(function(p) {
        pointers.push(p);
      });
      var dist = 0;
      // start with at least two pointers
      var points = {a: pointers[0], b: pointers[1]};
      var x, y, d;
      for (var i = 0; i < pointers.length; i++) {
        var a = pointers[i];
        for (var j = i + 1; j < pointers.length; j++) {
          var b = pointers[j];
          x = Math.abs(a.clientX - b.clientX);
          y = Math.abs(a.clientY - b.clientY);
          d = x + y;
          if (d > dist) {
            dist = d;
            points = {a: a, b: b};
          }
        }
      }
      x = Math.abs(points.a.clientX + points.b.clientX) / 2;
      y = Math.abs(points.a.clientY + points.b.clientY) / 2;
      points.center = { x: x, y: y };
      points.diameter = dist;
      return points;
    },
    calcAngle: function(points) {
      var x = points.a.clientX - points.b.clientX;
      var y = points.a.clientY - points.b.clientY;
      return (360 + Math.atan2(y, x) * RAD_TO_DEG) % 360;
    }
  };
  dispatcher.registerGesture('pinch', pinch);
})(window.PolymerGestures);

(function (global) {
    'use strict';

    var Token,
        TokenName,
        Syntax,
        Messages,
        source,
        index,
        length,
        delegate,
        lookahead,
        state;

    Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8
    };

    TokenName = {};
    TokenName[Token.BooleanLiteral] = 'Boolean';
    TokenName[Token.EOF] = '<end>';
    TokenName[Token.Identifier] = 'Identifier';
    TokenName[Token.Keyword] = 'Keyword';
    TokenName[Token.NullLiteral] = 'Null';
    TokenName[Token.NumericLiteral] = 'Numeric';
    TokenName[Token.Punctuator] = 'Punctuator';
    TokenName[Token.StringLiteral] = 'String';

    Syntax = {
        ArrayExpression: 'ArrayExpression',
        BinaryExpression: 'BinaryExpression',
        CallExpression: 'CallExpression',
        ConditionalExpression: 'ConditionalExpression',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        Identifier: 'Identifier',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        ObjectExpression: 'ObjectExpression',
        Program: 'Program',
        Property: 'Property',
        ThisExpression: 'ThisExpression',
        UnaryExpression: 'UnaryExpression'
    };

    // Error messages should be identical to V8.
    Messages = {
        UnexpectedToken:  'Unexpected token %0',
        UnknownLabel: 'Undefined label \'%0\'',
        Redeclaration: '%0 \'%1\' has already been declared'
    };

    // Ensure the condition is true, otherwise throw an error.
    // This is only to have a better contract semantic, i.e. another safety net
    // to catch a logic error. The condition shall be fulfilled in normal case.
    // Do NOT use this to enforce a certain condition on any user input.

    function assert(condition, message) {
        if (!condition) {
            throw new Error('ASSERT: ' + message);
        }
    }

    function isDecimalDigit(ch) {
        return (ch >= 48 && ch <= 57);   // 0..9
    }


    // 7.2 White Space

    function isWhiteSpace(ch) {
        return (ch === 32) ||  // space
            (ch === 9) ||      // tab
            (ch === 0xB) ||
            (ch === 0xC) ||
            (ch === 0xA0) ||
            (ch >= 0x1680 && '\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\uFEFF'.indexOf(String.fromCharCode(ch)) > 0);
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === 10) || (ch === 13) || (ch === 0x2028) || (ch === 0x2029);
    }

    // 7.6 Identifier Names and Identifiers

    function isIdentifierStart(ch) {
        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 97 && ch <= 122);          // a..z
    }

    function isIdentifierPart(ch) {
        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 97 && ch <= 122) ||        // a..z
            (ch >= 48 && ch <= 57);           // 0..9
    }

    // 7.6.1.1 Keywords

    function isKeyword(id) {
        return (id === 'this')
    }

    // 7.4 Comments

    function skipWhitespace() {
        while (index < length && isWhiteSpace(source.charCodeAt(index))) {
           ++index;
        }
    }

    function getIdentifier() {
        var start, ch;

        start = index++;
        while (index < length) {
            ch = source.charCodeAt(index);
            if (isIdentifierPart(ch)) {
                ++index;
            } else {
                break;
            }
        }

        return source.slice(start, index);
    }

    function scanIdentifier() {
        var start, id, type;

        start = index;

        id = getIdentifier();

        // There is no keyword or literal with only one character.
        // Thus, it must be an identifier.
        if (id.length === 1) {
            type = Token.Identifier;
        } else if (isKeyword(id)) {
            type = Token.Keyword;
        } else if (id === 'null') {
            type = Token.NullLiteral;
        } else if (id === 'true' || id === 'false') {
            type = Token.BooleanLiteral;
        } else {
            type = Token.Identifier;
        }

        return {
            type: type,
            value: id,
            range: [start, index]
        };
    }


    // 7.7 Punctuators

    function scanPunctuator() {
        var start = index,
            code = source.charCodeAt(index),
            code2,
            ch1 = source[index],
            ch2;

        switch (code) {

        // Check for most common single-character punctuators.
        case 46:   // . dot
        case 40:   // ( open bracket
        case 41:   // ) close bracket
        case 59:   // ; semicolon
        case 44:   // , comma
        case 123:  // { open curly brace
        case 125:  // } close curly brace
        case 91:   // [
        case 93:   // ]
        case 58:   // :
        case 63:   // ?
            ++index;
            return {
                type: Token.Punctuator,
                value: String.fromCharCode(code),
                range: [start, index]
            };

        default:
            code2 = source.charCodeAt(index + 1);

            // '=' (char #61) marks an assignment or comparison operator.
            if (code2 === 61) {
                switch (code) {
                case 37:  // %
                case 38:  // &
                case 42:  // *:
                case 43:  // +
                case 45:  // -
                case 47:  // /
                case 60:  // <
                case 62:  // >
                case 124: // |
                    index += 2;
                    return {
                        type: Token.Punctuator,
                        value: String.fromCharCode(code) + String.fromCharCode(code2),
                        range: [start, index]
                    };

                case 33: // !
                case 61: // =
                    index += 2;

                    // !== and ===
                    if (source.charCodeAt(index) === 61) {
                        ++index;
                    }
                    return {
                        type: Token.Punctuator,
                        value: source.slice(start, index),
                        range: [start, index]
                    };
                default:
                    break;
                }
            }
            break;
        }

        // Peek more characters.

        ch2 = source[index + 1];

        // Other 2-character punctuators: && ||

        if (ch1 === ch2 && ('&|'.indexOf(ch1) >= 0)) {
            index += 2;
            return {
                type: Token.Punctuator,
                value: ch1 + ch2,
                range: [start, index]
            };
        }

        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
            ++index;
            return {
                type: Token.Punctuator,
                value: ch1,
                range: [start, index]
            };
        }

        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
    }

    // 7.8.3 Numeric Literals
    function scanNumericLiteral() {
        var number, start, ch;

        ch = source[index];
        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
            'Numeric literal must start with a decimal digit or a decimal point');

        start = index;
        number = '';
        if (ch !== '.') {
            number = source[index++];
            ch = source[index];

            // Hex number starts with '0x'.
            // Octal number starts with '0'.
            if (number === '0') {
                // decimal number starts with '0' such as '09' is illegal.
                if (ch && isDecimalDigit(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            }

            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === '.') {
            number += source[index++];
            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === 'e' || ch === 'E') {
            number += source[index++];

            ch = source[index];
            if (ch === '+' || ch === '-') {
                number += source[index++];
            }
            if (isDecimalDigit(source.charCodeAt(index))) {
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
            } else {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.NumericLiteral,
            value: parseFloat(number),
            range: [start, index]
        };
    }

    // 7.8.4 String Literals

    function scanStringLiteral() {
        var str = '', quote, start, ch, octal = false;

        quote = source[index];
        assert((quote === '\'' || quote === '"'),
            'String literal must starts with a quote');

        start = index;
        ++index;

        while (index < length) {
            ch = source[index++];

            if (ch === quote) {
                quote = '';
                break;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case 'n':
                        str += '\n';
                        break;
                    case 'r':
                        str += '\r';
                        break;
                    case 't':
                        str += '\t';
                        break;
                    case 'b':
                        str += '\b';
                        break;
                    case 'f':
                        str += '\f';
                        break;
                    case 'v':
                        str += '\x0B';
                        break;

                    default:
                        str += ch;
                        break;
                    }
                } else {
                    if (ch ===  '\r' && source[index] === '\n') {
                        ++index;
                    }
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                break;
            } else {
                str += ch;
            }
        }

        if (quote !== '') {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.StringLiteral,
            value: str,
            octal: octal,
            range: [start, index]
        };
    }

    function isIdentifierName(token) {
        return token.type === Token.Identifier ||
            token.type === Token.Keyword ||
            token.type === Token.BooleanLiteral ||
            token.type === Token.NullLiteral;
    }

    function advance() {
        var ch;

        skipWhitespace();

        if (index >= length) {
            return {
                type: Token.EOF,
                range: [index, index]
            };
        }

        ch = source.charCodeAt(index);

        // Very common: ( and ) and ;
        if (ch === 40 || ch === 41 || ch === 58) {
            return scanPunctuator();
        }

        // String literal starts with single quote (#39) or double quote (#34).
        if (ch === 39 || ch === 34) {
            return scanStringLiteral();
        }

        if (isIdentifierStart(ch)) {
            return scanIdentifier();
        }

        // Dot (.) char #46 can also start a floating-point number, hence the need
        // to check the next character.
        if (ch === 46) {
            if (isDecimalDigit(source.charCodeAt(index + 1))) {
                return scanNumericLiteral();
            }
            return scanPunctuator();
        }

        if (isDecimalDigit(ch)) {
            return scanNumericLiteral();
        }

        return scanPunctuator();
    }

    function lex() {
        var token;

        token = lookahead;
        index = token.range[1];

        lookahead = advance();

        index = token.range[1];

        return token;
    }

    function peek() {
        var pos;

        pos = index;
        lookahead = advance();
        index = pos;
    }

    // Throw an exception

    function throwError(token, messageFormat) {
        var error,
            args = Array.prototype.slice.call(arguments, 2),
            msg = messageFormat.replace(
                /%(\d)/g,
                function (whole, index) {
                    assert(index < args.length, 'Message reference must be in range');
                    return args[index];
                }
            );

        error = new Error(msg);
        error.index = index;
        error.description = msg;
        throw error;
    }

    // Throw an exception because of the token.

    function throwUnexpected(token) {
        throwError(token, Messages.UnexpectedToken, token.value);
    }

    // Expect the next token to match the specified punctuator.
    // If not, an exception will be thrown.

    function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
            throwUnexpected(token);
        }
    }

    // Return true if the next token matches the specified punctuator.

    function match(value) {
        return lookahead.type === Token.Punctuator && lookahead.value === value;
    }

    // Return true if the next token matches the specified keyword

    function matchKeyword(keyword) {
        return lookahead.type === Token.Keyword && lookahead.value === keyword;
    }

    function consumeSemicolon() {
        // Catch the very common case first: immediately a semicolon (char #59).
        if (source.charCodeAt(index) === 59) {
            lex();
            return;
        }

        skipWhitespace();

        if (match(';')) {
            lex();
            return;
        }

        if (lookahead.type !== Token.EOF && !match('}')) {
            throwUnexpected(lookahead);
        }
    }

    // 11.1.4 Array Initialiser

    function parseArrayInitialiser() {
        var elements = [];

        expect('[');

        while (!match(']')) {
            if (match(',')) {
                lex();
                elements.push(null);
            } else {
                elements.push(parseExpression());

                if (!match(']')) {
                    expect(',');
                }
            }
        }

        expect(']');

        return delegate.createArrayExpression(elements);
    }

    // 11.1.5 Object Initialiser

    function parseObjectPropertyKey() {
        var token;

        skipWhitespace();
        token = lex();

        // Note: This function is called only from parseObjectProperty(), where
        // EOF and Punctuator tokens are already filtered out.
        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
            return delegate.createLiteral(token);
        }

        return delegate.createIdentifier(token.value);
    }

    function parseObjectProperty() {
        var token, key;

        token = lookahead;
        skipWhitespace();

        if (token.type === Token.EOF || token.type === Token.Punctuator) {
            throwUnexpected(token);
        }

        key = parseObjectPropertyKey();
        expect(':');
        return delegate.createProperty('init', key, parseExpression());
    }

    function parseObjectInitialiser() {
        var properties = [];

        expect('{');

        while (!match('}')) {
            properties.push(parseObjectProperty());

            if (!match('}')) {
                expect(',');
            }
        }

        expect('}');

        return delegate.createObjectExpression(properties);
    }

    // 11.1.6 The Grouping Operator

    function parseGroupExpression() {
        var expr;

        expect('(');

        expr = parseExpression();

        expect(')');

        return expr;
    }


    // 11.1 Primary Expressions

    function parsePrimaryExpression() {
        var type, token, expr;

        if (match('(')) {
            return parseGroupExpression();
        }

        type = lookahead.type;

        if (type === Token.Identifier) {
            expr = delegate.createIdentifier(lex().value);
        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
            expr = delegate.createLiteral(lex());
        } else if (type === Token.Keyword) {
            if (matchKeyword('this')) {
                lex();
                expr = delegate.createThisExpression();
            }
        } else if (type === Token.BooleanLiteral) {
            token = lex();
            token.value = (token.value === 'true');
            expr = delegate.createLiteral(token);
        } else if (type === Token.NullLiteral) {
            token = lex();
            token.value = null;
            expr = delegate.createLiteral(token);
        } else if (match('[')) {
            expr = parseArrayInitialiser();
        } else if (match('{')) {
            expr = parseObjectInitialiser();
        }

        if (expr) {
            return expr;
        }

        throwUnexpected(lex());
    }

    // 11.2 Left-Hand-Side Expressions

    function parseArguments() {
        var args = [];

        expect('(');

        if (!match(')')) {
            while (index < length) {
                args.push(parseExpression());
                if (match(')')) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        return args;
    }

    function parseNonComputedProperty() {
        var token;

        token = lex();

        if (!isIdentifierName(token)) {
            throwUnexpected(token);
        }

        return delegate.createIdentifier(token.value);
    }

    function parseNonComputedMember() {
        expect('.');

        return parseNonComputedProperty();
    }

    function parseComputedMember() {
        var expr;

        expect('[');

        expr = parseExpression();

        expect(']');

        return expr;
    }

    function parseLeftHandSideExpression() {
        var expr, args, property;

        expr = parsePrimaryExpression();

        while (true) {
            if (match('[')) {
                property = parseComputedMember();
                expr = delegate.createMemberExpression('[', expr, property);
            } else if (match('.')) {
                property = parseNonComputedMember();
                expr = delegate.createMemberExpression('.', expr, property);
            } else if (match('(')) {
                args = parseArguments();
                expr = delegate.createCallExpression(expr, args);
            } else {
                break;
            }
        }

        return expr;
    }

    // 11.3 Postfix Expressions

    var parsePostfixExpression = parseLeftHandSideExpression;

    // 11.4 Unary Operators

    function parseUnaryExpression() {
        var token, expr;

        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
            expr = parsePostfixExpression();
        } else if (match('+') || match('-') || match('!')) {
            token = lex();
            expr = parseUnaryExpression();
            expr = delegate.createUnaryExpression(token.value, expr);
        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
            throwError({}, Messages.UnexpectedToken);
        } else {
            expr = parsePostfixExpression();
        }

        return expr;
    }

    function binaryPrecedence(token) {
        var prec = 0;

        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
            return 0;
        }

        switch (token.value) {
        case '||':
            prec = 1;
            break;

        case '&&':
            prec = 2;
            break;

        case '==':
        case '!=':
        case '===':
        case '!==':
            prec = 6;
            break;

        case '<':
        case '>':
        case '<=':
        case '>=':
        case 'instanceof':
            prec = 7;
            break;

        case 'in':
            prec = 7;
            break;

        case '+':
        case '-':
            prec = 9;
            break;

        case '*':
        case '/':
        case '%':
            prec = 11;
            break;

        default:
            break;
        }

        return prec;
    }

    // 11.5 Multiplicative Operators
    // 11.6 Additive Operators
    // 11.7 Bitwise Shift Operators
    // 11.8 Relational Operators
    // 11.9 Equality Operators
    // 11.10 Binary Bitwise Operators
    // 11.11 Binary Logical Operators

    function parseBinaryExpression() {
        var expr, token, prec, stack, right, operator, left, i;

        left = parseUnaryExpression();

        token = lookahead;
        prec = binaryPrecedence(token);
        if (prec === 0) {
            return left;
        }
        token.prec = prec;
        lex();

        right = parseUnaryExpression();

        stack = [left, token, right];

        while ((prec = binaryPrecedence(lookahead)) > 0) {

            // Reduce: make a binary expression from the three topmost entries.
            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
                right = stack.pop();
                operator = stack.pop().value;
                left = stack.pop();
                expr = delegate.createBinaryExpression(operator, left, right);
                stack.push(expr);
            }

            // Shift.
            token = lex();
            token.prec = prec;
            stack.push(token);
            expr = parseUnaryExpression();
            stack.push(expr);
        }

        // Final reduce to clean-up the stack.
        i = stack.length - 1;
        expr = stack[i];
        while (i > 1) {
            expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
            i -= 2;
        }

        return expr;
    }


    // 11.12 Conditional Operator

    function parseConditionalExpression() {
        var expr, consequent, alternate;

        expr = parseBinaryExpression();

        if (match('?')) {
            lex();
            consequent = parseConditionalExpression();
            expect(':');
            alternate = parseConditionalExpression();

            expr = delegate.createConditionalExpression(expr, consequent, alternate);
        }

        return expr;
    }

    // Simplification since we do not support AssignmentExpression.
    var parseExpression = parseConditionalExpression;

    // Polymer Syntax extensions

    // Filter ::
    //   Identifier
    //   Identifier "(" ")"
    //   Identifier "(" FilterArguments ")"

    function parseFilter() {
        var identifier, args;

        identifier = lex();

        if (identifier.type !== Token.Identifier) {
            throwUnexpected(identifier);
        }

        args = match('(') ? parseArguments() : [];

        return delegate.createFilter(identifier.value, args);
    }

    // Filters ::
    //   "|" Filter
    //   Filters "|" Filter

    function parseFilters() {
        while (match('|')) {
            lex();
            parseFilter();
        }
    }

    // TopLevel ::
    //   LabelledExpressions
    //   AsExpression
    //   InExpression
    //   FilterExpression

    // AsExpression ::
    //   FilterExpression as Identifier

    // InExpression ::
    //   Identifier, Identifier in FilterExpression
    //   Identifier in FilterExpression

    // FilterExpression ::
    //   Expression
    //   Expression Filters

    function parseTopLevel() {
        skipWhitespace();
        peek();

        var expr = parseExpression();
        if (expr) {
            if (lookahead.value === ',' || lookahead.value == 'in' &&
                       expr.type === Syntax.Identifier) {
                parseInExpression(expr);
            } else {
                parseFilters();
                if (lookahead.value === 'as') {
                    parseAsExpression(expr);
                } else {
                    delegate.createTopLevel(expr);
                }
            }
        }

        if (lookahead.type !== Token.EOF) {
            throwUnexpected(lookahead);
        }
    }

    function parseAsExpression(expr) {
        lex();  // as
        var identifier = lex().value;
        delegate.createAsExpression(expr, identifier);
    }

    function parseInExpression(identifier) {
        var indexName;
        if (lookahead.value === ',') {
            lex();
            if (lookahead.type !== Token.Identifier)
                throwUnexpected(lookahead);
            indexName = lex().value;
        }

        lex();  // in
        var expr = parseExpression();
        parseFilters();
        delegate.createInExpression(identifier.name, indexName, expr);
    }

    function parse(code, inDelegate) {
        delegate = inDelegate;
        source = code;
        index = 0;
        length = source.length;
        lookahead = null;
        state = {
            labelSet: {}
        };

        return parseTopLevel();
    }

    global.esprima = {
        parse: parse
    };
})(this);

// Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
// This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
// The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
// The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
// Code distributed by Google as part of the polymer project is also
// subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt

(function (global) {
  'use strict';

  function prepareBinding(expressionText, name, node, filterRegistry) {
    var expression;
    try {
      expression = getExpression(expressionText);
      if (expression.scopeIdent &&
          (node.nodeType !== Node.ELEMENT_NODE ||
           node.tagName !== 'TEMPLATE' ||
           (name !== 'bind' && name !== 'repeat'))) {
        throw Error('as and in can only be used within <template bind/repeat>');
      }
    } catch (ex) {
      console.error('Invalid expression syntax: ' + expressionText, ex);
      return;
    }

    return function(model, node, oneTime) {
      var binding = expression.getBinding(model, filterRegistry, oneTime);
      if (expression.scopeIdent && binding) {
        node.polymerExpressionScopeIdent_ = expression.scopeIdent;
        if (expression.indexIdent)
          node.polymerExpressionIndexIdent_ = expression.indexIdent;
      }

      return binding;
    }
  }

  // TODO(rafaelw): Implement simple LRU.
  var expressionParseCache = Object.create(null);

  function getExpression(expressionText) {
    var expression = expressionParseCache[expressionText];
    if (!expression) {
      var delegate = new ASTDelegate();
      esprima.parse(expressionText, delegate);
      expression = new Expression(delegate);
      expressionParseCache[expressionText] = expression;
    }
    return expression;
  }

  function Literal(value) {
    this.value = value;
    this.valueFn_ = undefined;
  }

  Literal.prototype = {
    valueFn: function() {
      if (!this.valueFn_) {
        var value = this.value;
        this.valueFn_ = function() {
          return value;
        }
      }

      return this.valueFn_;
    }
  }

  function IdentPath(name) {
    this.name = name;
    this.path = Path.get(name);
  }

  IdentPath.prototype = {
    valueFn: function() {
      if (!this.valueFn_) {
        var name = this.name;
        var path = this.path;
        this.valueFn_ = function(model, observer) {
          if (observer)
            observer.addPath(model, path);

          return path.getValueFrom(model);
        }
      }

      return this.valueFn_;
    },

    setValue: function(model, newValue) {
      if (this.path.length == 1);
        model = findScope(model, this.path[0]);

      return this.path.setValueFrom(model, newValue);
    }
  };

  function MemberExpression(object, property, accessor) {
    this.computed = accessor == '[';

    this.dynamicDeps = typeof object == 'function' ||
                       object.dynamicDeps ||
                       (this.computed && !(property instanceof Literal));

    this.simplePath =
        !this.dynamicDeps &&
        (property instanceof IdentPath || property instanceof Literal) &&
        (object instanceof MemberExpression || object instanceof IdentPath);

    this.object = this.simplePath ? object : getFn(object);
    this.property = !this.computed || this.simplePath ?
        property : getFn(property);
  }

  MemberExpression.prototype = {
    get fullPath() {
      if (!this.fullPath_) {

        var parts = this.object instanceof MemberExpression ?
            this.object.fullPath.slice() : [this.object.name];
        parts.push(this.property instanceof IdentPath ?
            this.property.name : this.property.value);
        this.fullPath_ = Path.get(parts);
      }

      return this.fullPath_;
    },

    valueFn: function() {
      if (!this.valueFn_) {
        var object = this.object;

        if (this.simplePath) {
          var path = this.fullPath;

          this.valueFn_ = function(model, observer) {
            if (observer)
              observer.addPath(model, path);

            return path.getValueFrom(model);
          };
        } else if (!this.computed) {
          var path = Path.get(this.property.name);

          this.valueFn_ = function(model, observer, filterRegistry) {
            var context = object(model, observer, filterRegistry);

            if (observer)
              observer.addPath(context, path);

            return path.getValueFrom(context);
          }
        } else {
          // Computed property.
          var property = this.property;

          this.valueFn_ = function(model, observer, filterRegistry) {
            var context = object(model, observer, filterRegistry);
            var propName = property(model, observer, filterRegistry);
            if (observer)
              observer.addPath(context, [propName]);

            return context ? context[propName] : undefined;
          };
        }
      }
      return this.valueFn_;
    },

    setValue: function(model, newValue) {
      if (this.simplePath) {
        this.fullPath.setValueFrom(model, newValue);
        return newValue;
      }

      var object = this.object(model);
      var propName = this.property instanceof IdentPath ? this.property.name :
          this.property(model);
      return object[propName] = newValue;
    }
  };

  function Filter(name, args) {
    this.name = name;
    this.args = [];
    for (var i = 0; i < args.length; i++) {
      this.args[i] = getFn(args[i]);
    }
  }

  Filter.prototype = {
    transform: function(model, observer, filterRegistry, toModelDirection,
                        initialArgs) {
      var fn = filterRegistry[this.name];
      var context = model;
      if (fn) {
        context = undefined;
      } else {
        fn = context[this.name];
        if (!fn) {
          console.error('Cannot find function or filter: ' + this.name);
          return;
        }
      }

      // If toModelDirection is falsey, then the "normal" (dom-bound) direction
      // is used. Otherwise, it looks for a 'toModel' property function on the
      // object.
      if (toModelDirection) {
        fn = fn.toModel;
      } else if (typeof fn.toDOM == 'function') {
        fn = fn.toDOM;
      }

      if (typeof fn != 'function') {
        console.error('Cannot find function or filter: ' + this.name);
        return;
      }

      var args = initialArgs || [];
      for (var i = 0; i < this.args.length; i++) {
        args.push(getFn(this.args[i])(model, observer, filterRegistry));
      }

      return fn.apply(context, args);
    }
  };

  function notImplemented() { throw Error('Not Implemented'); }

  var unaryOperators = {
    '+': function(v) { return +v; },
    '-': function(v) { return -v; },
    '!': function(v) { return !v; }
  };

  var binaryOperators = {
    '+': function(l, r) { return l+r; },
    '-': function(l, r) { return l-r; },
    '*': function(l, r) { return l*r; },
    '/': function(l, r) { return l/r; },
    '%': function(l, r) { return l%r; },
    '<': function(l, r) { return l<r; },
    '>': function(l, r) { return l>r; },
    '<=': function(l, r) { return l<=r; },
    '>=': function(l, r) { return l>=r; },
    '==': function(l, r) { return l==r; },
    '!=': function(l, r) { return l!=r; },
    '===': function(l, r) { return l===r; },
    '!==': function(l, r) { return l!==r; },
    '&&': function(l, r) { return l&&r; },
    '||': function(l, r) { return l||r; },
  };

  function getFn(arg) {
    return typeof arg == 'function' ? arg : arg.valueFn();
  }

  function ASTDelegate() {
    this.expression = null;
    this.filters = [];
    this.deps = {};
    this.currentPath = undefined;
    this.scopeIdent = undefined;
    this.indexIdent = undefined;
    this.dynamicDeps = false;
  }

  ASTDelegate.prototype = {
    createUnaryExpression: function(op, argument) {
      if (!unaryOperators[op])
        throw Error('Disallowed operator: ' + op);

      argument = getFn(argument);

      return function(model, observer, filterRegistry) {
        return unaryOperators[op](argument(model, observer, filterRegistry));
      };
    },

    createBinaryExpression: function(op, left, right) {
      if (!binaryOperators[op])
        throw Error('Disallowed operator: ' + op);

      left = getFn(left);
      right = getFn(right);

      switch (op) {
        case '||':
          this.dynamicDeps = true;
          return function(model, observer, filterRegistry) {
            return left(model, observer, filterRegistry) ||
                right(model, observer, filterRegistry);
          };
        case '&&':
          this.dynamicDeps = true;
          return function(model, observer, filterRegistry) {
            return left(model, observer, filterRegistry) &&
                right(model, observer, filterRegistry);
          };
      }

      return function(model, observer, filterRegistry) {
        return binaryOperators[op](left(model, observer, filterRegistry),
                                   right(model, observer, filterRegistry));
      };
    },

    createConditionalExpression: function(test, consequent, alternate) {
      test = getFn(test);
      consequent = getFn(consequent);
      alternate = getFn(alternate);

      this.dynamicDeps = true;

      return function(model, observer, filterRegistry) {
        return test(model, observer, filterRegistry) ?
            consequent(model, observer, filterRegistry) :
            alternate(model, observer, filterRegistry);
      }
    },

    createIdentifier: function(name) {
      var ident = new IdentPath(name);
      ident.type = 'Identifier';
      return ident;
    },

    createMemberExpression: function(accessor, object, property) {
      var ex = new MemberExpression(object, property, accessor);
      if (ex.dynamicDeps)
        this.dynamicDeps = true;
      return ex;
    },

    createCallExpression: function(expression, args) {
      if (!(expression instanceof IdentPath))
        throw Error('Only identifier function invocations are allowed');

      var filter = new Filter(expression.name, args);

      return function(model, observer, filterRegistry) {
        return filter.transform(model, observer, filterRegistry, false);
      };
    },

    createLiteral: function(token) {
      return new Literal(token.value);
    },

    createArrayExpression: function(elements) {
      for (var i = 0; i < elements.length; i++)
        elements[i] = getFn(elements[i]);

      return function(model, observer, filterRegistry) {
        var arr = []
        for (var i = 0; i < elements.length; i++)
          arr.push(elements[i](model, observer, filterRegistry));
        return arr;
      }
    },

    createProperty: function(kind, key, value) {
      return {
        key: key instanceof IdentPath ? key.name : key.value,
        value: value
      };
    },

    createObjectExpression: function(properties) {
      for (var i = 0; i < properties.length; i++)
        properties[i].value = getFn(properties[i].value);

      return function(model, observer, filterRegistry) {
        var obj = {};
        for (var i = 0; i < properties.length; i++)
          obj[properties[i].key] =
              properties[i].value(model, observer, filterRegistry);
        return obj;
      }
    },

    createFilter: function(name, args) {
      this.filters.push(new Filter(name, args));
    },

    createAsExpression: function(expression, scopeIdent) {
      this.expression = expression;
      this.scopeIdent = scopeIdent;
    },

    createInExpression: function(scopeIdent, indexIdent, expression) {
      this.expression = expression;
      this.scopeIdent = scopeIdent;
      this.indexIdent = indexIdent;
    },

    createTopLevel: function(expression) {
      this.expression = expression;
    },

    createThisExpression: notImplemented
  }

  function ConstantObservable(value) {
    this.value_ = value;
  }

  ConstantObservable.prototype = {
    open: function() { return this.value_; },
    discardChanges: function() { return this.value_; },
    deliver: function() {},
    close: function() {},
  }

  function Expression(delegate) {
    this.scopeIdent = delegate.scopeIdent;
    this.indexIdent = delegate.indexIdent;

    if (!delegate.expression)
      throw Error('No expression found.');

    this.expression = delegate.expression;
    getFn(this.expression); // forces enumeration of path dependencies

    this.filters = delegate.filters;
    this.dynamicDeps = delegate.dynamicDeps;
  }

  Expression.prototype = {
    getBinding: function(model, filterRegistry, oneTime) {
      if (oneTime)
        return this.getValue(model, undefined, filterRegistry);

      var observer = new CompoundObserver();
      // captures deps.
      var firstValue = this.getValue(model, observer, filterRegistry);
      var firstTime = true;
      var self = this;

      function valueFn() {
        // deps cannot have changed on first value retrieval.
        if (firstTime) {
          firstTime = false;
          return firstValue;
        }

        if (self.dynamicDeps)
          observer.startReset();

        var value = self.getValue(model,
                                  self.dynamicDeps ? observer : undefined,
                                  filterRegistry);
        if (self.dynamicDeps)
          observer.finishReset();

        return value;
      }

      function setValueFn(newValue) {
        self.setValue(model, newValue, filterRegistry);
        return newValue;
      }

      return new ObserverTransform(observer, valueFn, setValueFn, true);
    },

    getValue: function(model, observer, filterRegistry) {
      var value = getFn(this.expression)(model, observer, filterRegistry);
      for (var i = 0; i < this.filters.length; i++) {
        value = this.filters[i].transform(model, observer, filterRegistry,
            false, [value]);
      }

      return value;
    },

    setValue: function(model, newValue, filterRegistry) {
      var count = this.filters ? this.filters.length : 0;
      while (count-- > 0) {
        newValue = this.filters[count].transform(model, undefined,
            filterRegistry, true, [newValue]);
      }

      if (this.expression.setValue)
        return this.expression.setValue(model, newValue);
    }
  }

  /**
   * Converts a style property name to a css property name. For example:
   * "WebkitUserSelect" to "-webkit-user-select"
   */
  function convertStylePropertyName(name) {
    return String(name).replace(/[A-Z]/g, function(c) {
      return '-' + c.toLowerCase();
    });
  }

  var parentScopeName = '@' + Math.random().toString(36).slice(2);

  // Single ident paths must bind directly to the appropriate scope object.
  // I.e. Pushed values in two-bindings need to be assigned to the actual model
  // object.
  function findScope(model, prop) {
    while (model[parentScopeName] &&
           !Object.prototype.hasOwnProperty.call(model, prop)) {
      model = model[parentScopeName];
    }

    return model;
  }

  function isLiteralExpression(pathString) {
    switch (pathString) {
      case '':
        return false;

      case 'false':
      case 'null':
      case 'true':
        return true;
    }

    if (!isNaN(Number(pathString)))
      return true;

    return false;
  };

  function PolymerExpressions() {}

  PolymerExpressions.prototype = {
    // "built-in" filters
    styleObject: function(value) {
      var parts = [];
      for (var key in value) {
        parts.push(convertStylePropertyName(key) + ': ' + value[key]);
      }
      return parts.join('; ');
    },

    tokenList: function(value) {
      var tokens = [];
      for (var key in value) {
        if (value[key])
          tokens.push(key);
      }
      return tokens.join(' ');
    },

    // binding delegate API
    prepareInstancePositionChanged: function(template) {
      var indexIdent = template.polymerExpressionIndexIdent_;
      if (!indexIdent)
        return;

      return function(templateInstance, index) {
        templateInstance.model[indexIdent] = index;
      };
    },

    prepareBinding: function(pathString, name, node) {
      var path = Path.get(pathString);

      if (!isLiteralExpression(pathString) && path.valid) {
        if (path.length == 1) {
          return function(model, node, oneTime) {
            if (oneTime)
              return path.getValueFrom(model);

            var scope = findScope(model, path[0]);
            return new PathObserver(scope, path);
          };
        }
        return; // bail out early if pathString is simple path.
      }

      return prepareBinding(pathString, name, node, this);
    },

    prepareInstanceModel: function(template) {
      var scopeName = template.polymerExpressionScopeIdent_;
      if (!scopeName)
        return;

      var parentScope = template.templateInstance ?
          template.templateInstance.model :
          template.model;

      var indexName = template.polymerExpressionIndexIdent_;

      return function(model) {
        return createScopeObject(parentScope, model, scopeName, indexName);
      };
    }
  };

  var createScopeObject = ('__proto__' in {}) ?
    function(parentScope, model, scopeName, indexName) {
      var scope = {};
      scope[scopeName] = model;
      scope[indexName] = undefined;
      scope[parentScopeName] = parentScope;
      scope.__proto__ = parentScope;
      return scope;
    } :
    function(parentScope, model, scopeName, indexName) {
      var scope = Object.create(parentScope);
      Object.defineProperty(scope, scopeName,
          { value: model, configurable: true, writable: true });
      Object.defineProperty(scope, indexName,
          { value: undefined, configurable: true, writable: true });
      Object.defineProperty(scope, parentScopeName,
          { value: parentScope, configurable: true, writable: true });
      return scope;
    };

  global.PolymerExpressions = PolymerExpressions;
  PolymerExpressions.getExpression = getExpression;
})(this);

Polymer = {
  version: '0.5.1'
};

// TODO(sorvell): this ensures Polymer is an object and not a function
// Platform is currently defining it as a function to allow for async loading
// of polymer; once we refine the loading process this likely goes away.
if (typeof window.Polymer === 'function') {
  Polymer = {};
}


(function(scope) {

  function withDependencies(task, depends) {
    depends = depends || [];
    if (!depends.map) {
      depends = [depends];
    }
    return task.apply(this, depends.map(marshal));
  }

  function module(name, dependsOrFactory, moduleFactory) {
    var module;
    switch (arguments.length) {
      case 0:
        return;
      case 1:
        module = null;
        break;
      case 2:
        // dependsOrFactory is `factory` in this case
        module = dependsOrFactory.apply(this);
        break;
      default:
        // dependsOrFactory is `depends` in this case
        module = withDependencies(moduleFactory, dependsOrFactory);
        break;
    }
    modules[name] = module;
  };

  function marshal(name) {
    return modules[name];
  }

  var modules = {};

  function using(depends, task) {
    HTMLImports.whenImportsReady(function() {
      withDependencies(task, depends);
    });
  };

  // exports

  scope.marshal = marshal;
  // `module` confuses commonjs detectors
  scope.modularize = module;
  scope.using = using;

})(window);

/*
	Build only script.

  Ensures scripts needed for basic x-platform compatibility
  will be run when platform.js is not loaded.
 */
if (!window.WebComponents) {

/*
	On supported platforms, platform.js is not needed. To retain compatibility
	with the polyfills, we stub out minimal functionality.
 */
if (!window.WebComponents) {

  WebComponents = {
  	flush: function() {},
    flags: {log: {}}
  };

  Platform = WebComponents;

  CustomElements = {
  	useNative: true,
    ready: true,
    takeRecords: function() {},
    instanceof: function(obj, base) {
      return obj instanceof base;
    }
  };
  
  HTMLImports = {
  	useNative: true
  };

  
  addEventListener('HTMLImportsLoaded', function() {
    document.dispatchEvent(
      new CustomEvent('WebComponentsReady', {bubbles: true})
    );
  });


  // ShadowDOM
  ShadowDOMPolyfill = null;
  wrap = unwrap = function(n){
    return n;
  };

}

/*
  Create polyfill scope and feature detect native support.
*/
window.HTMLImports = window.HTMLImports || {flags:{}};

(function(scope) {

/**
  Basic setup and simple module executer. We collect modules and then execute
  the code later, only if it's necessary for polyfilling.
*/
var IMPORT_LINK_TYPE = 'import';
var useNative = Boolean(IMPORT_LINK_TYPE in document.createElement('link'));

/**
  Support `currentScript` on all browsers as `document._currentScript.`

  NOTE: We cannot polyfill `document.currentScript` because it's not possible
  both to override and maintain the ability to capture the native value.
  Therefore we choose to expose `_currentScript` both when native imports
  and the polyfill are in use.
*/
// NOTE: ShadowDOMPolyfill intrusion.
var hasShadowDOMPolyfill = Boolean(window.ShadowDOMPolyfill);
var wrap = function(node) {
  return hasShadowDOMPolyfill ? ShadowDOMPolyfill.wrapIfNeeded(node) : node;
};
var rootDocument = wrap(document);

var currentScriptDescriptor = {
  get: function() {
    var script = HTMLImports.currentScript || document.currentScript ||
        // NOTE: only works when called in synchronously executing code.
        // readyState should check if `loading` but IE10 is
        // interactive when scripts run so we cheat.
        (document.readyState !== 'complete' ?
        document.scripts[document.scripts.length - 1] : null);
    return wrap(script);
  },
  configurable: true
};

Object.defineProperty(document, '_currentScript', currentScriptDescriptor);
Object.defineProperty(rootDocument, '_currentScript', currentScriptDescriptor);

/**
  Add support for the `HTMLImportsLoaded` event and the `HTMLImports.whenReady`
  method. This api is necessary because unlike the native implementation,
  script elements do not force imports to resolve. Instead, users should wrap
  code in either an `HTMLImportsLoaded` hander or after load time in an
  `HTMLImports.whenReady(callback)` call.

  NOTE: This module also supports these apis under the native implementation.
  Therefore, if this file is loaded, the same code can be used under both
  the polyfill and native implementation.
 */

var isIE = /Trident/.test(navigator.userAgent);

// call a callback when all HTMLImports in the document at call time
// (or at least document ready) have loaded.
// 1. ensure the document is in a ready state (has dom), then
// 2. watch for loading of imports and call callback when done
function whenReady(callback, doc) {
  doc = doc || rootDocument;
  // if document is loading, wait and try again
  whenDocumentReady(function() {
    watchImportsLoad(callback, doc);
  }, doc);
}

// call the callback when the document is in a ready state (has dom)
var requiredReadyState = isIE ? 'complete' : 'interactive';
var READY_EVENT = 'readystatechange';
function isDocumentReady(doc) {
  return (doc.readyState === 'complete' ||
      doc.readyState === requiredReadyState);
}

// call <callback> when we ensure the document is in a ready state
function whenDocumentReady(callback, doc) {
  if (!isDocumentReady(doc)) {
    var checkReady = function() {
      if (doc.readyState === 'complete' ||
          doc.readyState === requiredReadyState) {
        doc.removeEventListener(READY_EVENT, checkReady);
        whenDocumentReady(callback, doc);
      }
    };
    doc.addEventListener(READY_EVENT, checkReady);
  } else if (callback) {
    callback();
  }
}

function markTargetLoaded(event) {
  event.target.__loaded = true;
}

// call <callback> when we ensure all imports have loaded
function watchImportsLoad(callback, doc) {
  var imports = doc.querySelectorAll('link[rel=import]');
  var loaded = 0, l = imports.length;
  function checkDone(d) {
    if ((loaded == l) && callback) {
       callback();
    }
  }
  function loadedImport(e) {
    markTargetLoaded(e);
    loaded++;
    checkDone();
  }
  if (l) {
    for (var i=0, imp; (i<l) && (imp=imports[i]); i++) {
      if (isImportLoaded(imp)) {
        loadedImport.call(imp, {target: imp});
      } else {
        imp.addEventListener('load', loadedImport);
        imp.addEventListener('error', loadedImport);
      }
    }
  } else {
    checkDone();
  }
}

// NOTE: test for native imports loading is based on explicitly watching
// all imports (see below).
// However, we cannot rely on this entirely without watching the entire document
// for import links. For perf reasons, currently only head is watched.
// Instead, we fallback to checking if the import property is available
// and the document is not itself loading.
function isImportLoaded(link) {
  return useNative ? link.__loaded ||
      (link.import && link.import.readyState !== 'loading') :
      link.__importParsed;
}

// TODO(sorvell): Workaround for
// https://www.w3.org/Bugs/Public/show_bug.cgi?id=25007, should be removed when
// this bug is addressed.
// (1) Install a mutation observer to see when HTMLImports have loaded
// (2) if this script is run during document load it will watch any existing
// imports for loading.
//
// NOTE: The workaround has restricted functionality: (1) it's only compatible
// with imports that are added to document.head since the mutation observer
// watches only head for perf reasons, (2) it requires this script
// to run before any imports have completed loading.
if (useNative) {
  new MutationObserver(function(mxns) {
    for (var i=0, l=mxns.length, m; (i < l) && (m=mxns[i]); i++) {
      if (m.addedNodes) {
        handleImports(m.addedNodes);
      }
    }
  }).observe(document.head, {childList: true});

  function handleImports(nodes) {
    for (var i=0, l=nodes.length, n; (i<l) && (n=nodes[i]); i++) {
      if (isImport(n)) {
        handleImport(n);
      }
    }
  }

  function isImport(element) {
    return element.localName === 'link' && element.rel === 'import';
  }

  function handleImport(element) {
    var loaded = element.import;
    if (loaded) {
      markTargetLoaded({target: element});
    } else {
      element.addEventListener('load', markTargetLoaded);
      element.addEventListener('error', markTargetLoaded);
    }
  }

  // make sure to catch any imports that are in the process of loading
  // when this script is run.
  (function() {
    if (document.readyState === 'loading') {
      var imports = document.querySelectorAll('link[rel=import]');
      for (var i=0, l=imports.length, imp; (i<l) && (imp=imports[i]); i++) {
        handleImport(imp);
      }
    }
  })();

}

// Fire the 'HTMLImportsLoaded' event when imports in document at load time
// have loaded. This event is required to simulate the script blocking
// behavior of native imports. A main document script that needs to be sure
// imports have loaded should wait for this event.
whenReady(function() {
  HTMLImports.ready = true;
  HTMLImports.readyTime = new Date().getTime();
  rootDocument.dispatchEvent(
    new CustomEvent('HTMLImportsLoaded', {bubbles: true})
  );
});

// exports
scope.IMPORT_LINK_TYPE = IMPORT_LINK_TYPE;
scope.useNative = useNative;
scope.rootDocument = rootDocument;
scope.whenReady = whenReady;
scope.isIE = isIE;

})(HTMLImports);

(function(scope) {

  // TODO(sorvell): It's desireable to provide a default stylesheet 
  // that's convenient for styling unresolved elements, but
  // it's cumbersome to have to include this manually in every page.
  // It would make sense to put inside some HTMLImport but 
  // the HTMLImports polyfill does not allow loading of stylesheets 
  // that block rendering. Therefore this injection is tolerated here.
  var style = document.createElement('style');
  style.textContent = ''
      + 'body {'
      + 'transition: opacity ease-in 0.2s;' 
      + ' } \n'
      + 'body[unresolved] {'
      + 'opacity: 0; display: block; overflow: hidden;' 
      + ' } \n'
      ;
  var head = document.querySelector('head');
  head.insertBefore(style, head.firstChild);

})(Platform);

/*
	Build only script.

  Ensures scripts needed for basic x-platform compatibility
  will be run when platform.js is not loaded.
 */
}
(function(global) {
  'use strict';

  var testingExposeCycleCount = global.testingExposeCycleCount;

  // Detect and do basic sanity checking on Object/Array.observe.
  function detectObjectObserve() {
    if (typeof Object.observe !== 'function' ||
        typeof Array.observe !== 'function') {
      return false;
    }

    var records = [];

    function callback(recs) {
      records = recs;
    }

    var test = {};
    var arr = [];
    Object.observe(test, callback);
    Array.observe(arr, callback);
    test.id = 1;
    test.id = 2;
    delete test.id;
    arr.push(1, 2);
    arr.length = 0;

    Object.deliverChangeRecords(callback);
    if (records.length !== 5)
      return false;

    if (records[0].type != 'add' ||
        records[1].type != 'update' ||
        records[2].type != 'delete' ||
        records[3].type != 'splice' ||
        records[4].type != 'splice') {
      return false;
    }

    Object.unobserve(test, callback);
    Array.unobserve(arr, callback);

    return true;
  }

  var hasObserve = detectObjectObserve();

  function detectEval() {
    // Don't test for eval if we're running in a Chrome App environment.
    // We check for APIs set that only exist in a Chrome App context.
    if (typeof chrome !== 'undefined' && chrome.app && chrome.app.runtime) {
      return false;
    }

    // Firefox OS Apps do not allow eval. This feature detection is very hacky
    // but even if some other platform adds support for this function this code
    // will continue to work.
    if (typeof navigator != 'undefined' && navigator.getDeviceStorage) {
      return false;
    }

    try {
      var f = new Function('', 'return true;');
      return f();
    } catch (ex) {
      return false;
    }
  }

  var hasEval = detectEval();

  function isIndex(s) {
    return +s === s >>> 0 && s !== '';
  }

  function toNumber(s) {
    return +s;
  }

  function isObject(obj) {
    return obj === Object(obj);
  }

  var numberIsNaN = global.Number.isNaN || function(value) {
    return typeof value === 'number' && global.isNaN(value);
  }

  function areSameValue(left, right) {
    if (left === right)
      return left !== 0 || 1 / left === 1 / right;
    if (numberIsNaN(left) && numberIsNaN(right))
      return true;

    return left !== left && right !== right;
  }

  var createObject = ('__proto__' in {}) ?
    function(obj) { return obj; } :
    function(obj) {
      var proto = obj.__proto__;
      if (!proto)
        return obj;
      var newObject = Object.create(proto);
      Object.getOwnPropertyNames(obj).forEach(function(name) {
        Object.defineProperty(newObject, name,
                             Object.getOwnPropertyDescriptor(obj, name));
      });
      return newObject;
    };

  var identStart = '[\$_a-zA-Z]';
  var identPart = '[\$_a-zA-Z0-9]';
  var identRegExp = new RegExp('^' + identStart + '+' + identPart + '*' + '$');

  function getPathCharType(char) {
    if (char === undefined)
      return 'eof';

    var code = char.charCodeAt(0);

    switch(code) {
      case 0x5B: // [
      case 0x5D: // ]
      case 0x2E: // .
      case 0x22: // "
      case 0x27: // '
      case 0x30: // 0
        return char;

      case 0x5F: // _
      case 0x24: // $
        return 'ident';

      case 0x20: // Space
      case 0x09: // Tab
      case 0x0A: // Newline
      case 0x0D: // Return
      case 0xA0:  // No-break space
      case 0xFEFF:  // Byte Order Mark
      case 0x2028:  // Line Separator
      case 0x2029:  // Paragraph Separator
        return 'ws';
    }

    // a-z, A-Z
    if ((0x61 <= code && code <= 0x7A) || (0x41 <= code && code <= 0x5A))
      return 'ident';

    // 1-9
    if (0x31 <= code && code <= 0x39)
      return 'number';

    return 'else';
  }

  var pathStateMachine = {
    'beforePath': {
      'ws': ['beforePath'],
      'ident': ['inIdent', 'append'],
      '[': ['beforeElement'],
      'eof': ['afterPath']
    },

    'inPath': {
      'ws': ['inPath'],
      '.': ['beforeIdent'],
      '[': ['beforeElement'],
      'eof': ['afterPath']
    },

    'beforeIdent': {
      'ws': ['beforeIdent'],
      'ident': ['inIdent', 'append']
    },

    'inIdent': {
      'ident': ['inIdent', 'append'],
      '0': ['inIdent', 'append'],
      'number': ['inIdent', 'append'],
      'ws': ['inPath', 'push'],
      '.': ['beforeIdent', 'push'],
      '[': ['beforeElement', 'push'],
      'eof': ['afterPath', 'push']
    },

    'beforeElement': {
      'ws': ['beforeElement'],
      '0': ['afterZero', 'append'],
      'number': ['inIndex', 'append'],
      "'": ['inSingleQuote', 'append', ''],
      '"': ['inDoubleQuote', 'append', '']
    },

    'afterZero': {
      'ws': ['afterElement', 'push'],
      ']': ['inPath', 'push']
    },

    'inIndex': {
      '0': ['inIndex', 'append'],
      'number': ['inIndex', 'append'],
      'ws': ['afterElement'],
      ']': ['inPath', 'push']
    },

    'inSingleQuote': {
      "'": ['afterElement'],
      'eof': ['error'],
      'else': ['inSingleQuote', 'append']
    },

    'inDoubleQuote': {
      '"': ['afterElement'],
      'eof': ['error'],
      'else': ['inDoubleQuote', 'append']
    },

    'afterElement': {
      'ws': ['afterElement'],
      ']': ['inPath', 'push']
    }
  }

  function noop() {}

  function parsePath(path) {
    var keys = [];
    var index = -1;
    var c, newChar, key, type, transition, action, typeMap, mode = 'beforePath';

    var actions = {
      push: function() {
        if (key === undefined)
          return;

        keys.push(key);
        key = undefined;
      },

      append: function() {
        if (key === undefined)
          key = newChar
        else
          key += newChar;
      }
    };

    function maybeUnescapeQuote() {
      if (index >= path.length)
        return;

      var nextChar = path[index + 1];
      if ((mode == 'inSingleQuote' && nextChar == "'") ||
          (mode == 'inDoubleQuote' && nextChar == '"')) {
        index++;
        newChar = nextChar;
        actions.append();
        return true;
      }
    }

    while (mode) {
      index++;
      c = path[index];

      if (c == '\\' && maybeUnescapeQuote(mode))
        continue;

      type = getPathCharType(c);
      typeMap = pathStateMachine[mode];
      transition = typeMap[type] || typeMap['else'] || 'error';

      if (transition == 'error')
        return; // parse error;

      mode = transition[0];
      action = actions[transition[1]] || noop;
      newChar = transition[2] === undefined ? c : transition[2];
      action();

      if (mode === 'afterPath') {
        return keys;
      }
    }

    return; // parse error
  }

  function isIdent(s) {
    return identRegExp.test(s);
  }

  var constructorIsPrivate = {};

  function Path(parts, privateToken) {
    if (privateToken !== constructorIsPrivate)
      throw Error('Use Path.get to retrieve path objects');

    for (var i = 0; i < parts.length; i++) {
      this.push(String(parts[i]));
    }

    if (hasEval && this.length) {
      this.getValueFrom = this.compiledGetValueFromFn();
    }
  }

  // TODO(rafaelw): Make simple LRU cache
  var pathCache = {};

  function getPath(pathString) {
    if (pathString instanceof Path)
      return pathString;

    if (pathString == null || pathString.length == 0)
      pathString = '';

    if (typeof pathString != 'string') {
      if (isIndex(pathString.length)) {
        // Constructed with array-like (pre-parsed) keys
        return new Path(pathString, constructorIsPrivate);
      }

      pathString = String(pathString);
    }

    var path = pathCache[pathString];
    if (path)
      return path;

    var parts = parsePath(pathString);
    if (!parts)
      return invalidPath;

    var path = new Path(parts, constructorIsPrivate);
    pathCache[pathString] = path;
    return path;
  }

  Path.get = getPath;

  function formatAccessor(key) {
    if (isIndex(key)) {
      return '[' + key + ']';
    } else {
      return '["' + key.replace(/"/g, '\\"') + '"]';
    }
  }

  Path.prototype = createObject({
    __proto__: [],
    valid: true,

    toString: function() {
      var pathString = '';
      for (var i = 0; i < this.length; i++) {
        var key = this[i];
        if (isIdent(key)) {
          pathString += i ? '.' + key : key;
        } else {
          pathString += formatAccessor(key);
        }
      }

      return pathString;
    },

    getValueFrom: function(obj, directObserver) {
      for (var i = 0; i < this.length; i++) {
        if (obj == null)
          return;
        obj = obj[this[i]];
      }
      return obj;
    },

    iterateObjects: function(obj, observe) {
      for (var i = 0; i < this.length; i++) {
        if (i)
          obj = obj[this[i - 1]];
        if (!isObject(obj))
          return;
        observe(obj, this[i]);
      }
    },

    compiledGetValueFromFn: function() {
      var str = '';
      var pathString = 'obj';
      str += 'if (obj != null';
      var i = 0;
      var key;
      for (; i < (this.length - 1); i++) {
        key = this[i];
        pathString += isIdent(key) ? '.' + key : formatAccessor(key);
        str += ' &&\n     ' + pathString + ' != null';
      }
      str += ')\n';

      var key = this[i];
      pathString += isIdent(key) ? '.' + key : formatAccessor(key);

      str += '  return ' + pathString + ';\nelse\n  return undefined;';
      return new Function('obj', str);
    },

    setValueFrom: function(obj, value) {
      if (!this.length)
        return false;

      for (var i = 0; i < this.length - 1; i++) {
        if (!isObject(obj))
          return false;
        obj = obj[this[i]];
      }

      if (!isObject(obj))
        return false;

      obj[this[i]] = value;
      return true;
    }
  });

  var invalidPath = new Path('', constructorIsPrivate);
  invalidPath.valid = false;
  invalidPath.getValueFrom = invalidPath.setValueFrom = function() {};

  var MAX_DIRTY_CHECK_CYCLES = 1000;

  function dirtyCheck(observer) {
    var cycles = 0;
    while (cycles < MAX_DIRTY_CHECK_CYCLES && observer.check_()) {
      cycles++;
    }
    if (testingExposeCycleCount)
      global.dirtyCheckCycleCount = cycles;

    return cycles > 0;
  }

  function objectIsEmpty(object) {
    for (var prop in object)
      return false;
    return true;
  }

  function diffIsEmpty(diff) {
    return objectIsEmpty(diff.added) &&
           objectIsEmpty(diff.removed) &&
           objectIsEmpty(diff.changed);
  }

  function diffObjectFromOldObject(object, oldObject) {
    var added = {};
    var removed = {};
    var changed = {};

    for (var prop in oldObject) {
      var newValue = object[prop];

      if (newValue !== undefined && newValue === oldObject[prop])
        continue;

      if (!(prop in object)) {
        removed[prop] = undefined;
        continue;
      }

      if (newValue !== oldObject[prop])
        changed[prop] = newValue;
    }

    for (var prop in object) {
      if (prop in oldObject)
        continue;

      added[prop] = object[prop];
    }

    if (Array.isArray(object) && object.length !== oldObject.length)
      changed.length = object.length;

    return {
      added: added,
      removed: removed,
      changed: changed
    };
  }

  var eomTasks = [];
  function runEOMTasks() {
    if (!eomTasks.length)
      return false;

    for (var i = 0; i < eomTasks.length; i++) {
      eomTasks[i]();
    }
    eomTasks.length = 0;
    return true;
  }

  var runEOM = hasObserve ? (function(){
    return function(fn) {
      return Promise.resolve().then(fn);
    }
  })() :
  (function() {
    return function(fn) {
      eomTasks.push(fn);
    };
  })();

  var observedObjectCache = [];

  function newObservedObject() {
    var observer;
    var object;
    var discardRecords = false;
    var first = true;

    function callback(records) {
      if (observer && observer.state_ === OPENED && !discardRecords)
        observer.check_(records);
    }

    return {
      open: function(obs) {
        if (observer)
          throw Error('ObservedObject in use');

        if (!first)
          Object.deliverChangeRecords(callback);

        observer = obs;
        first = false;
      },
      observe: function(obj, arrayObserve) {
        object = obj;
        if (arrayObserve)
          Array.observe(object, callback);
        else
          Object.observe(object, callback);
      },
      deliver: function(discard) {
        discardRecords = discard;
        Object.deliverChangeRecords(callback);
        discardRecords = false;
      },
      close: function() {
        observer = undefined;
        Object.unobserve(object, callback);
        observedObjectCache.push(this);
      }
    };
  }

  /*
   * The observedSet abstraction is a perf optimization which reduces the total
   * number of Object.observe observations of a set of objects. The idea is that
   * groups of Observers will have some object dependencies in common and this
   * observed set ensures that each object in the transitive closure of
   * dependencies is only observed once. The observedSet acts as a write barrier
   * such that whenever any change comes through, all Observers are checked for
   * changed values.
   *
   * Note that this optimization is explicitly moving work from setup-time to
   * change-time.
   *
   * TODO(rafaelw): Implement "garbage collection". In order to move work off
   * the critical path, when Observers are closed, their observed objects are
   * not Object.unobserve(d). As a result, it's possible that if the observedSet
   * is kept open, but some Observers have been closed, it could cause "leaks"
   * (prevent otherwise collectable objects from being collected). At some
   * point, we should implement incremental "gc" which keeps a list of
   * observedSets which may need clean-up and does small amounts of cleanup on a
   * timeout until all is clean.
   */

  function getObservedObject(observer, object, arrayObserve) {
    var dir = observedObjectCache.pop() || newObservedObject();
    dir.open(observer);
    dir.observe(object, arrayObserve);
    return dir;
  }

  var observedSetCache = [];

  function newObservedSet() {
    var observerCount = 0;
    var observers = [];
    var objects = [];
    var rootObj;
    var rootObjProps;

    function observe(obj, prop) {
      if (!obj)
        return;

      if (obj === rootObj)
        rootObjProps[prop] = true;

      if (objects.indexOf(obj) < 0) {
        objects.push(obj);
        Object.observe(obj, callback);
      }

      observe(Object.getPrototypeOf(obj), prop);
    }

    function allRootObjNonObservedProps(recs) {
      for (var i = 0; i < recs.length; i++) {
        var rec = recs[i];
        if (rec.object !== rootObj ||
            rootObjProps[rec.name] ||
            rec.type === 'setPrototype') {
          return false;
        }
      }
      return true;
    }

    function callback(recs) {
      if (allRootObjNonObservedProps(recs))
        return;

      var observer;
      for (var i = 0; i < observers.length; i++) {
        observer = observers[i];
        if (observer.state_ == OPENED) {
          observer.iterateObjects_(observe);
        }
      }

      for (var i = 0; i < observers.length; i++) {
        observer = observers[i];
        if (observer.state_ == OPENED) {
          observer.check_();
        }
      }
    }

    var record = {
      objects: objects,
      get rootObject() { return rootObj; },
      set rootObject(value) {
        rootObj = value;
        rootObjProps = {};
      },
      open: function(obs, object) {
        observers.push(obs);
        observerCount++;
        obs.iterateObjects_(observe);
      },
      close: function(obs) {
        observerCount--;
        if (observerCount > 0) {
          return;
        }

        for (var i = 0; i < objects.length; i++) {
          Object.unobserve(objects[i], callback);
          Observer.unobservedCount++;
        }

        observers.length = 0;
        objects.length = 0;
        rootObj = undefined;
        rootObjProps = undefined;
        observedSetCache.push(this);
        if (lastObservedSet === this)
          lastObservedSet = null;
      },
    };

    return record;
  }

  var lastObservedSet;

  function getObservedSet(observer, obj) {
    if (!lastObservedSet || lastObservedSet.rootObject !== obj) {
      lastObservedSet = observedSetCache.pop() || newObservedSet();
      lastObservedSet.rootObject = obj;
    }
    lastObservedSet.open(observer, obj);
    return lastObservedSet;
  }

  var UNOPENED = 0;
  var OPENED = 1;
  var CLOSED = 2;
  var RESETTING = 3;

  var nextObserverId = 1;

  function Observer() {
    this.state_ = UNOPENED;
    this.callback_ = undefined;
    this.target_ = undefined; // TODO(rafaelw): Should be WeakRef
    this.directObserver_ = undefined;
    this.value_ = undefined;
    this.id_ = nextObserverId++;
  }

  Observer.prototype = {
    open: function(callback, target) {
      if (this.state_ != UNOPENED)
        throw Error('Observer has already been opened.');

      addToAll(this);
      this.callback_ = callback;
      this.target_ = target;
      this.connect_();
      this.state_ = OPENED;
      return this.value_;
    },

    close: function() {
      if (this.state_ != OPENED)
        return;

      removeFromAll(this);
      this.disconnect_();
      this.value_ = undefined;
      this.callback_ = undefined;
      this.target_ = undefined;
      this.state_ = CLOSED;
    },

    deliver: function() {
      if (this.state_ != OPENED)
        return;

      dirtyCheck(this);
    },

    report_: function(changes) {
      try {
        this.callback_.apply(this.target_, changes);
      } catch (ex) {
        Observer._errorThrownDuringCallback = true;
        console.error('Exception caught during observer callback: ' +
                       (ex.stack || ex));
      }
    },

    discardChanges: function() {
      this.check_(undefined, true);
      return this.value_;
    }
  }

  var collectObservers = !hasObserve;
  var allObservers;
  Observer._allObserversCount = 0;

  if (collectObservers) {
    allObservers = [];
  }

  function addToAll(observer) {
    Observer._allObserversCount++;
    if (!collectObservers)
      return;

    allObservers.push(observer);
  }

  function removeFromAll(observer) {
    Observer._allObserversCount--;
  }

  var runningMicrotaskCheckpoint = false;

  global.Platform = global.Platform || {};

  global.Platform.performMicrotaskCheckpoint = function() {
    if (runningMicrotaskCheckpoint)
      return;

    if (!collectObservers)
      return;

    runningMicrotaskCheckpoint = true;

    var cycles = 0;
    var anyChanged, toCheck;

    do {
      cycles++;
      toCheck = allObservers;
      allObservers = [];
      anyChanged = false;

      for (var i = 0; i < toCheck.length; i++) {
        var observer = toCheck[i];
        if (observer.state_ != OPENED)
          continue;

        if (observer.check_())
          anyChanged = true;

        allObservers.push(observer);
      }
      if (runEOMTasks())
        anyChanged = true;
    } while (cycles < MAX_DIRTY_CHECK_CYCLES && anyChanged);

    if (testingExposeCycleCount)
      global.dirtyCheckCycleCount = cycles;

    runningMicrotaskCheckpoint = false;
  };

  if (collectObservers) {
    global.Platform.clearObservers = function() {
      allObservers = [];
    };
  }

  function ObjectObserver(object) {
    Observer.call(this);
    this.value_ = object;
    this.oldObject_ = undefined;
  }

  ObjectObserver.prototype = createObject({
    __proto__: Observer.prototype,

    arrayObserve: false,

    connect_: function(callback, target) {
      if (hasObserve) {
        this.directObserver_ = getObservedObject(this, this.value_,
                                                 this.arrayObserve);
      } else {
        this.oldObject_ = this.copyObject(this.value_);
      }

    },

    copyObject: function(object) {
      var copy = Array.isArray(object) ? [] : {};
      for (var prop in object) {
        copy[prop] = object[prop];
      };
      if (Array.isArray(object))
        copy.length = object.length;
      return copy;
    },

    check_: function(changeRecords, skipChanges) {
      var diff;
      var oldValues;
      if (hasObserve) {
        if (!changeRecords)
          return false;

        oldValues = {};
        diff = diffObjectFromChangeRecords(this.value_, changeRecords,
                                           oldValues);
      } else {
        oldValues = this.oldObject_;
        diff = diffObjectFromOldObject(this.value_, this.oldObject_);
      }

      if (diffIsEmpty(diff))
        return false;

      if (!hasObserve)
        this.oldObject_ = this.copyObject(this.value_);

      this.report_([
        diff.added || {},
        diff.removed || {},
        diff.changed || {},
        function(property) {
          return oldValues[property];
        }
      ]);

      return true;
    },

    disconnect_: function() {
      if (hasObserve) {
        this.directObserver_.close();
        this.directObserver_ = undefined;
      } else {
        this.oldObject_ = undefined;
      }
    },

    deliver: function() {
      if (this.state_ != OPENED)
        return;

      if (hasObserve)
        this.directObserver_.deliver(false);
      else
        dirtyCheck(this);
    },

    discardChanges: function() {
      if (this.directObserver_)
        this.directObserver_.deliver(true);
      else
        this.oldObject_ = this.copyObject(this.value_);

      return this.value_;
    }
  });

  function ArrayObserver(array) {
    if (!Array.isArray(array))
      throw Error('Provided object is not an Array');
    ObjectObserver.call(this, array);
  }

  ArrayObserver.prototype = createObject({

    __proto__: ObjectObserver.prototype,

    arrayObserve: true,

    copyObject: function(arr) {
      return arr.slice();
    },

    check_: function(changeRecords) {
      var splices;
      if (hasObserve) {
        if (!changeRecords)
          return false;
        splices = projectArraySplices(this.value_, changeRecords);
      } else {
        splices = calcSplices(this.value_, 0, this.value_.length,
                              this.oldObject_, 0, this.oldObject_.length);
      }

      if (!splices || !splices.length)
        return false;

      if (!hasObserve)
        this.oldObject_ = this.copyObject(this.value_);

      this.report_([splices]);
      return true;
    }
  });

  ArrayObserver.applySplices = function(previous, current, splices) {
    splices.forEach(function(splice) {
      var spliceArgs = [splice.index, splice.removed.length];
      var addIndex = splice.index;
      while (addIndex < splice.index + splice.addedCount) {
        spliceArgs.push(current[addIndex]);
        addIndex++;
      }

      Array.prototype.splice.apply(previous, spliceArgs);
    });
  };

  function PathObserver(object, path) {
    Observer.call(this);

    this.object_ = object;
    this.path_ = getPath(path);
    this.directObserver_ = undefined;
  }

  PathObserver.prototype = createObject({
    __proto__: Observer.prototype,

    get path() {
      return this.path_;
    },

    connect_: function() {
      if (hasObserve)
        this.directObserver_ = getObservedSet(this, this.object_);

      this.check_(undefined, true);
    },

    disconnect_: function() {
      this.value_ = undefined;

      if (this.directObserver_) {
        this.directObserver_.close(this);
        this.directObserver_ = undefined;
      }
    },

    iterateObjects_: function(observe) {
      this.path_.iterateObjects(this.object_, observe);
    },

    check_: function(changeRecords, skipChanges) {
      var oldValue = this.value_;
      this.value_ = this.path_.getValueFrom(this.object_);
      if (skipChanges || areSameValue(this.value_, oldValue))
        return false;

      this.report_([this.value_, oldValue, this]);
      return true;
    },

    setValue: function(newValue) {
      if (this.path_)
        this.path_.setValueFrom(this.object_, newValue);
    }
  });

  function CompoundObserver(reportChangesOnOpen) {
    Observer.call(this);

    this.reportChangesOnOpen_ = reportChangesOnOpen;
    this.value_ = [];
    this.directObserver_ = undefined;
    this.observed_ = [];
  }

  var observerSentinel = {};

  CompoundObserver.prototype = createObject({
    __proto__: Observer.prototype,

    connect_: function() {
      if (hasObserve) {
        var object;
        var needsDirectObserver = false;
        for (var i = 0; i < this.observed_.length; i += 2) {
          object = this.observed_[i]
          if (object !== observerSentinel) {
            needsDirectObserver = true;
            break;
          }
        }

        if (needsDirectObserver)
          this.directObserver_ = getObservedSet(this, object);
      }

      this.check_(undefined, !this.reportChangesOnOpen_);
    },

    disconnect_: function() {
      for (var i = 0; i < this.observed_.length; i += 2) {
        if (this.observed_[i] === observerSentinel)
          this.observed_[i + 1].close();
      }
      this.observed_.length = 0;
      this.value_.length = 0;

      if (this.directObserver_) {
        this.directObserver_.close(this);
        this.directObserver_ = undefined;
      }
    },

    addPath: function(object, path) {
      if (this.state_ != UNOPENED && this.state_ != RESETTING)
        throw Error('Cannot add paths once started.');

      var path = getPath(path);
      this.observed_.push(object, path);
      if (!this.reportChangesOnOpen_)
        return;
      var index = this.observed_.length / 2 - 1;
      this.value_[index] = path.getValueFrom(object);
    },

    addObserver: function(observer) {
      if (this.state_ != UNOPENED && this.state_ != RESETTING)
        throw Error('Cannot add observers once started.');

      this.observed_.push(observerSentinel, observer);
      if (!this.reportChangesOnOpen_)
        return;
      var index = this.observed_.length / 2 - 1;
      this.value_[index] = observer.open(this.deliver, this);
    },

    startReset: function() {
      if (this.state_ != OPENED)
        throw Error('Can only reset while open');

      this.state_ = RESETTING;
      this.disconnect_();
    },

    finishReset: function() {
      if (this.state_ != RESETTING)
        throw Error('Can only finishReset after startReset');
      this.state_ = OPENED;
      this.connect_();

      return this.value_;
    },

    iterateObjects_: function(observe) {
      var object;
      for (var i = 0; i < this.observed_.length; i += 2) {
        object = this.observed_[i]
        if (object !== observerSentinel)
          this.observed_[i + 1].iterateObjects(object, observe)
      }
    },

    check_: function(changeRecords, skipChanges) {
      var oldValues;
      for (var i = 0; i < this.observed_.length; i += 2) {
        var object = this.observed_[i];
        var path = this.observed_[i+1];
        var value;
        if (object === observerSentinel) {
          var observable = path;
          value = this.state_ === UNOPENED ?
              observable.open(this.deliver, this) :
              observable.discardChanges();
        } else {
          value = path.getValueFrom(object);
        }

        if (skipChanges) {
          this.value_[i / 2] = value;
          continue;
        }

        if (areSameValue(value, this.value_[i / 2]))
          continue;

        oldValues = oldValues || [];
        oldValues[i / 2] = this.value_[i / 2];
        this.value_[i / 2] = value;
      }

      if (!oldValues)
        return false;

      // TODO(rafaelw): Having observed_ as the third callback arg here is
      // pretty lame API. Fix.
      this.report_([this.value_, oldValues, this.observed_]);
      return true;
    }
  });

  function identFn(value) { return value; }

  function ObserverTransform(observable, getValueFn, setValueFn,
                             dontPassThroughSet) {
    this.callback_ = undefined;
    this.target_ = undefined;
    this.value_ = undefined;
    this.observable_ = observable;
    this.getValueFn_ = getValueFn || identFn;
    this.setValueFn_ = setValueFn || identFn;
    // TODO(rafaelw): This is a temporary hack. PolymerExpressions needs this
    // at the moment because of a bug in it's dependency tracking.
    this.dontPassThroughSet_ = dontPassThroughSet;
  }

  ObserverTransform.prototype = {
    open: function(callback, target) {
      this.callback_ = callback;
      this.target_ = target;
      this.value_ =
          this.getValueFn_(this.observable_.open(this.observedCallback_, this));
      return this.value_;
    },

    observedCallback_: function(value) {
      value = this.getValueFn_(value);
      if (areSameValue(value, this.value_))
        return;
      var oldValue = this.value_;
      this.value_ = value;
      this.callback_.call(this.target_, this.value_, oldValue);
    },

    discardChanges: function() {
      this.value_ = this.getValueFn_(this.observable_.discardChanges());
      return this.value_;
    },

    deliver: function() {
      return this.observable_.deliver();
    },

    setValue: function(value) {
      value = this.setValueFn_(value);
      if (!this.dontPassThroughSet_ && this.observable_.setValue)
        return this.observable_.setValue(value);
    },

    close: function() {
      if (this.observable_)
        this.observable_.close();
      this.callback_ = undefined;
      this.target_ = undefined;
      this.observable_ = undefined;
      this.value_ = undefined;
      this.getValueFn_ = undefined;
      this.setValueFn_ = undefined;
    }
  }

  var expectedRecordTypes = {
    add: true,
    update: true,
    delete: true
  };

  function diffObjectFromChangeRecords(object, changeRecords, oldValues) {
    var added = {};
    var removed = {};

    for (var i = 0; i < changeRecords.length; i++) {
      var record = changeRecords[i];
      if (!expectedRecordTypes[record.type]) {
        console.error('Unknown changeRecord type: ' + record.type);
        console.error(record);
        continue;
      }

      if (!(record.name in oldValues))
        oldValues[record.name] = record.oldValue;

      if (record.type == 'update')
        continue;

      if (record.type == 'add') {
        if (record.name in removed)
          delete removed[record.name];
        else
          added[record.name] = true;

        continue;
      }

      // type = 'delete'
      if (record.name in added) {
        delete added[record.name];
        delete oldValues[record.name];
      } else {
        removed[record.name] = true;
      }
    }

    for (var prop in added)
      added[prop] = object[prop];

    for (var prop in removed)
      removed[prop] = undefined;

    var changed = {};
    for (var prop in oldValues) {
      if (prop in added || prop in removed)
        continue;

      var newValue = object[prop];
      if (oldValues[prop] !== newValue)
        changed[prop] = newValue;
    }

    return {
      added: added,
      removed: removed,
      changed: changed
    };
  }

  function newSplice(index, removed, addedCount) {
    return {
      index: index,
      removed: removed,
      addedCount: addedCount
    };
  }

  var EDIT_LEAVE = 0;
  var EDIT_UPDATE = 1;
  var EDIT_ADD = 2;
  var EDIT_DELETE = 3;

  function ArraySplice() {}

  ArraySplice.prototype = {

    // Note: This function is *based* on the computation of the Levenshtein
    // "edit" distance. The one change is that "updates" are treated as two
    // edits - not one. With Array splices, an update is really a delete
    // followed by an add. By retaining this, we optimize for "keeping" the
    // maximum array items in the original array. For example:
    //
    //   'xxxx123' -> '123yyyy'
    //
    // With 1-edit updates, the shortest path would be just to update all seven
    // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This
    // leaves the substring '123' intact.
    calcEditDistances: function(current, currentStart, currentEnd,
                                old, oldStart, oldEnd) {
      // "Deletion" columns
      var rowCount = oldEnd - oldStart + 1;
      var columnCount = currentEnd - currentStart + 1;
      var distances = new Array(rowCount);

      // "Addition" rows. Initialize null column.
      for (var i = 0; i < rowCount; i++) {
        distances[i] = new Array(columnCount);
        distances[i][0] = i;
      }

      // Initialize null row
      for (var j = 0; j < columnCount; j++)
        distances[0][j] = j;

      for (var i = 1; i < rowCount; i++) {
        for (var j = 1; j < columnCount; j++) {
          if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))
            distances[i][j] = distances[i - 1][j - 1];
          else {
            var north = distances[i - 1][j] + 1;
            var west = distances[i][j - 1] + 1;
            distances[i][j] = north < west ? north : west;
          }
        }
      }

      return distances;
    },

    // This starts at the final weight, and walks "backward" by finding
    // the minimum previous weight recursively until the origin of the weight
    // matrix.
    spliceOperationsFromEditDistances: function(distances) {
      var i = distances.length - 1;
      var j = distances[0].length - 1;
      var current = distances[i][j];
      var edits = [];
      while (i > 0 || j > 0) {
        if (i == 0) {
          edits.push(EDIT_ADD);
          j--;
          continue;
        }
        if (j == 0) {
          edits.push(EDIT_DELETE);
          i--;
          continue;
        }
        var northWest = distances[i - 1][j - 1];
        var west = distances[i - 1][j];
        var north = distances[i][j - 1];

        var min;
        if (west < north)
          min = west < northWest ? west : northWest;
        else
          min = north < northWest ? north : northWest;

        if (min == northWest) {
          if (northWest == current) {
            edits.push(EDIT_LEAVE);
          } else {
            edits.push(EDIT_UPDATE);
            current = northWest;
          }
          i--;
          j--;
        } else if (min == west) {
          edits.push(EDIT_DELETE);
          i--;
          current = west;
        } else {
          edits.push(EDIT_ADD);
          j--;
          current = north;
        }
      }

      edits.reverse();
      return edits;
    },

    /**
     * Splice Projection functions:
     *
     * A splice map is a representation of how a previous array of items
     * was transformed into a new array of items. Conceptually it is a list of
     * tuples of
     *
     *   <index, removed, addedCount>
     *
     * which are kept in ascending index order of. The tuple represents that at
     * the |index|, |removed| sequence of items were removed, and counting forward
     * from |index|, |addedCount| items were added.
     */

    /**
     * Lacking individual splice mutation information, the minimal set of
     * splices can be synthesized given the previous state and final state of an
     * array. The basic approach is to calculate the edit distance matrix and
     * choose the shortest path through it.
     *
     * Complexity: O(l * p)
     *   l: The length of the current array
     *   p: The length of the old array
     */
    calcSplices: function(current, currentStart, currentEnd,
                          old, oldStart, oldEnd) {
      var prefixCount = 0;
      var suffixCount = 0;

      var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
      if (currentStart == 0 && oldStart == 0)
        prefixCount = this.sharedPrefix(current, old, minLength);

      if (currentEnd == current.length && oldEnd == old.length)
        suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);

      currentStart += prefixCount;
      oldStart += prefixCount;
      currentEnd -= suffixCount;
      oldEnd -= suffixCount;

      if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
        return [];

      if (currentStart == currentEnd) {
        var splice = newSplice(currentStart, [], 0);
        while (oldStart < oldEnd)
          splice.removed.push(old[oldStart++]);

        return [ splice ];
      } else if (oldStart == oldEnd)
        return [ newSplice(currentStart, [], currentEnd - currentStart) ];

      var ops = this.spliceOperationsFromEditDistances(
          this.calcEditDistances(current, currentStart, currentEnd,
                                 old, oldStart, oldEnd));

      var splice = undefined;
      var splices = [];
      var index = currentStart;
      var oldIndex = oldStart;
      for (var i = 0; i < ops.length; i++) {
        switch(ops[i]) {
          case EDIT_LEAVE:
            if (splice) {
              splices.push(splice);
              splice = undefined;
            }

            index++;
            oldIndex++;
            break;
          case EDIT_UPDATE:
            if (!splice)
              splice = newSplice(index, [], 0);

            splice.addedCount++;
            index++;

            splice.removed.push(old[oldIndex]);
            oldIndex++;
            break;
          case EDIT_ADD:
            if (!splice)
              splice = newSplice(index, [], 0);

            splice.addedCount++;
            index++;
            break;
          case EDIT_DELETE:
            if (!splice)
              splice = newSplice(index, [], 0);

            splice.removed.push(old[oldIndex]);
            oldIndex++;
            break;
        }
      }

      if (splice) {
        splices.push(splice);
      }
      return splices;
    },

    sharedPrefix: function(current, old, searchLength) {
      for (var i = 0; i < searchLength; i++)
        if (!this.equals(current[i], old[i]))
          return i;
      return searchLength;
    },

    sharedSuffix: function(current, old, searchLength) {
      var index1 = current.length;
      var index2 = old.length;
      var count = 0;
      while (count < searchLength && this.equals(current[--index1], old[--index2]))
        count++;

      return count;
    },

    calculateSplices: function(current, previous) {
      return this.calcSplices(current, 0, current.length, previous, 0,
                              previous.length);
    },

    equals: function(currentValue, previousValue) {
      return currentValue === previousValue;
    }
  };

  var arraySplice = new ArraySplice();

  function calcSplices(current, currentStart, currentEnd,
                       old, oldStart, oldEnd) {
    return arraySplice.calcSplices(current, currentStart, currentEnd,
                                   old, oldStart, oldEnd);
  }

  function intersect(start1, end1, start2, end2) {
    // Disjoint
    if (end1 < start2 || end2 < start1)
      return -1;

    // Adjacent
    if (end1 == start2 || end2 == start1)
      return 0;

    // Non-zero intersect, span1 first
    if (start1 < start2) {
      if (end1 < end2)
        return end1 - start2; // Overlap
      else
        return end2 - start2; // Contained
    } else {
      // Non-zero intersect, span2 first
      if (end2 < end1)
        return end2 - start1; // Overlap
      else
        return end1 - start1; // Contained
    }
  }

  function mergeSplice(splices, index, removed, addedCount) {

    var splice = newSplice(index, removed, addedCount);

    var inserted = false;
    var insertionOffset = 0;

    for (var i = 0; i < splices.length; i++) {
      var current = splices[i];
      current.index += insertionOffset;

      if (inserted)
        continue;

      var intersectCount = intersect(splice.index,
                                     splice.index + splice.removed.length,
                                     current.index,
                                     current.index + current.addedCount);

      if (intersectCount >= 0) {
        // Merge the two splices

        splices.splice(i, 1);
        i--;

        insertionOffset -= current.addedCount - current.removed.length;

        splice.addedCount += current.addedCount - intersectCount;
        var deleteCount = splice.removed.length +
                          current.removed.length - intersectCount;

        if (!splice.addedCount && !deleteCount) {
          // merged splice is a noop. discard.
          inserted = true;
        } else {
          var removed = current.removed;

          if (splice.index < current.index) {
            // some prefix of splice.removed is prepended to current.removed.
            var prepend = splice.removed.slice(0, current.index - splice.index);
            Array.prototype.push.apply(prepend, removed);
            removed = prepend;
          }

          if (splice.index + splice.removed.length > current.index + current.addedCount) {
            // some suffix of splice.removed is appended to current.removed.
            var append = splice.removed.slice(current.index + current.addedCount - splice.index);
            Array.prototype.push.apply(removed, append);
          }

          splice.removed = removed;
          if (current.index < splice.index) {
            splice.index = current.index;
          }
        }
      } else if (splice.index < current.index) {
        // Insert splice here.

        inserted = true;

        splices.splice(i, 0, splice);
        i++;

        var offset = splice.addedCount - splice.removed.length
        current.index += offset;
        insertionOffset += offset;
      }
    }

    if (!inserted)
      splices.push(splice);
  }

  function createInitialSplices(array, changeRecords) {
    var splices = [];

    for (var i = 0; i < changeRecords.length; i++) {
      var record = changeRecords[i];
      switch(record.type) {
        case 'splice':
          mergeSplice(splices, record.index, record.removed.slice(), record.addedCount);
          break;
        case 'add':
        case 'update':
        case 'delete':
          if (!isIndex(record.name))
            continue;
          var index = toNumber(record.name);
          if (index < 0)
            continue;
          mergeSplice(splices, index, [record.oldValue], 1);
          break;
        default:
          console.error('Unexpected record type: ' + JSON.stringify(record));
          break;
      }
    }

    return splices;
  }

  function projectArraySplices(array, changeRecords) {
    var splices = [];

    createInitialSplices(array, changeRecords).forEach(function(splice) {
      if (splice.addedCount == 1 && splice.removed.length == 1) {
        if (splice.removed[0] !== array[splice.index])
          splices.push(splice);

        return
      };

      splices = splices.concat(calcSplices(array, splice.index, splice.index + splice.addedCount,
                                           splice.removed, 0, splice.removed.length));
    });

    return splices;
  }

  // Export the observe-js object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, export as a global object.

  var expose = global;

  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      expose = exports = module.exports;
    }
    expose = exports;
  } 

  expose.Observer = Observer;
  expose.Observer.runEOM_ = runEOM;
  expose.Observer.observerSentinel_ = observerSentinel; // for testing.
  expose.Observer.hasObjectObserve = hasObserve;
  expose.ArrayObserver = ArrayObserver;
  expose.ArrayObserver.calculateSplices = function(current, previous) {
    return arraySplice.calculateSplices(current, previous);
  };

  expose.ArraySplice = ArraySplice;
  expose.ObjectObserver = ObjectObserver;
  expose.PathObserver = PathObserver;
  expose.CompoundObserver = CompoundObserver;
  expose.Path = Path;
  expose.ObserverTransform = ObserverTransform;
  
})(typeof global !== 'undefined' && global && typeof module !== 'undefined' && module ? global : this || window);

// Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
// This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
// The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
// The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
// Code distributed by Google as part of the polymer project is also
// subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt

(function(global) {
  'use strict';

  var filter = Array.prototype.filter.call.bind(Array.prototype.filter);

  function getTreeScope(node) {
    while (node.parentNode) {
      node = node.parentNode;
    }

    return typeof node.getElementById === 'function' ? node : null;
  }

  Node.prototype.bind = function(name, observable) {
    console.error('Unhandled binding to Node: ', this, name, observable);
  };

  Node.prototype.bindFinished = function() {};

  function updateBindings(node, name, binding) {
    var bindings = node.bindings_;
    if (!bindings)
      bindings = node.bindings_ = {};

    if (bindings[name])
      binding[name].close();

    return bindings[name] = binding;
  }

  function returnBinding(node, name, binding) {
    return binding;
  }

  function sanitizeValue(value) {
    return value == null ? '' : value;
  }

  function updateText(node, value) {
    node.data = sanitizeValue(value);
  }

  function textBinding(node) {
    return function(value) {
      return updateText(node, value);
    };
  }

  var maybeUpdateBindings = returnBinding;

  Object.defineProperty(Platform, 'enableBindingsReflection', {
    get: function() {
      return maybeUpdateBindings === updateBindings;
    },
    set: function(enable) {
      maybeUpdateBindings = enable ? updateBindings : returnBinding;
      return enable;
    },
    configurable: true
  });

  Text.prototype.bind = function(name, value, oneTime) {
    if (name !== 'textContent')
      return Node.prototype.bind.call(this, name, value, oneTime);

    if (oneTime)
      return updateText(this, value);

    var observable = value;
    updateText(this, observable.open(textBinding(this)));
    return maybeUpdateBindings(this, name, observable);
  }

  function updateAttribute(el, name, conditional, value) {
    if (conditional) {
      if (value)
        el.setAttribute(name, '');
      else
        el.removeAttribute(name);
      return;
    }

    el.setAttribute(name, sanitizeValue(value));
  }

  function attributeBinding(el, name, conditional) {
    return function(value) {
      updateAttribute(el, name, conditional, value);
    };
  }

  Element.prototype.bind = function(name, value, oneTime) {
    var conditional = name[name.length - 1] == '?';
    if (conditional) {
      this.removeAttribute(name);
      name = name.slice(0, -1);
    }

    if (oneTime)
      return updateAttribute(this, name, conditional, value);


    var observable = value;
    updateAttribute(this, name, conditional,
        observable.open(attributeBinding(this, name, conditional)));

    return maybeUpdateBindings(this, name, observable);
  };

  var checkboxEventType;
  (function() {
    // Attempt to feature-detect which event (change or click) is fired first
    // for checkboxes.
    var div = document.createElement('div');
    var checkbox = div.appendChild(document.createElement('input'));
    checkbox.setAttribute('type', 'checkbox');
    var first;
    var count = 0;
    checkbox.addEventListener('click', function(e) {
      count++;
      first = first || 'click';
    });
    checkbox.addEventListener('change', function() {
      count++;
      first = first || 'change';
    });

    var event = document.createEvent('MouseEvent');
    event.initMouseEvent("click", true, true, window, 0, 0, 0, 0, 0, false,
        false, false, false, 0, null);
    checkbox.dispatchEvent(event);
    // WebKit/Blink don't fire the change event if the element is outside the
    // document, so assume 'change' for that case.
    checkboxEventType = count == 1 ? 'change' : first;
  })();

  function getEventForInputType(element) {
    switch (element.type) {
      case 'checkbox':
        return checkboxEventType;
      case 'radio':
      case 'select-multiple':
      case 'select-one':
        return 'change';
      case 'range':
        if (/Trident|MSIE/.test(navigator.userAgent))
          return 'change';
      default:
        return 'input';
    }
  }

  function updateInput(input, property, value, santizeFn) {
    input[property] = (santizeFn || sanitizeValue)(value);
  }

  function inputBinding(input, property, santizeFn) {
    return function(value) {
      return updateInput(input, property, value, santizeFn);
    }
  }

  function noop() {}

  function bindInputEvent(input, property, observable, postEventFn) {
    var eventType = getEventForInputType(input);

    function eventHandler() {
      observable.setValue(input[property]);
      observable.discardChanges();
      (postEventFn || noop)(input);
      Platform.performMicrotaskCheckpoint();
    }
    input.addEventListener(eventType, eventHandler);

    return {
      close: function() {
        input.removeEventListener(eventType, eventHandler);
        observable.close();
      },

      observable_: observable
    }
  }

  function booleanSanitize(value) {
    return Boolean(value);
  }

  // |element| is assumed to be an HTMLInputElement with |type| == 'radio'.
  // Returns an array containing all radio buttons other than |element| that
  // have the same |name|, either in the form that |element| belongs to or,
  // if no form, in the document tree to which |element| belongs.
  //
  // This implementation is based upon the HTML spec definition of a
  // "radio button group":
  //   http://www.whatwg.org/specs/web-apps/current-work/multipage/number-state.html#radio-button-group
  //
  function getAssociatedRadioButtons(element) {
    if (element.form) {
      return filter(element.form.elements, function(el) {
        return el != element &&
            el.tagName == 'INPUT' &&
            el.type == 'radio' &&
            el.name == element.name;
      });
    } else {
      var treeScope = getTreeScope(element);
      if (!treeScope)
        return [];
      var radios = treeScope.querySelectorAll(
          'input[type="radio"][name="' + element.name + '"]');
      return filter(radios, function(el) {
        return el != element && !el.form;
      });
    }
  }

  function checkedPostEvent(input) {
    // Only the radio button that is getting checked gets an event. We
    // therefore find all the associated radio buttons and update their
    // check binding manually.
    if (input.tagName === 'INPUT' &&
        input.type === 'radio') {
      getAssociatedRadioButtons(input).forEach(function(radio) {
        var checkedBinding = radio.bindings_.checked;
        if (checkedBinding) {
          // Set the value directly to avoid an infinite call stack.
          checkedBinding.observable_.setValue(false);
        }
      });
    }
  }

  HTMLInputElement.prototype.bind = function(name, value, oneTime) {
    if (name !== 'value' && name !== 'checked')
      return HTMLElement.prototype.bind.call(this, name, value, oneTime);

    this.removeAttribute(name);
    var sanitizeFn = name == 'checked' ? booleanSanitize : sanitizeValue;
    var postEventFn = name == 'checked' ? checkedPostEvent : noop;

    if (oneTime)
      return updateInput(this, name, value, sanitizeFn);


    var observable = value;
    var binding = bindInputEvent(this, name, observable, postEventFn);
    updateInput(this, name,
                observable.open(inputBinding(this, name, sanitizeFn)),
                sanitizeFn);

    // Checkboxes may need to update bindings of other checkboxes.
    return updateBindings(this, name, binding);
  }

  HTMLTextAreaElement.prototype.bind = function(name, value, oneTime) {
    if (name !== 'value')
      return HTMLElement.prototype.bind.call(this, name, value, oneTime);

    this.removeAttribute('value');

    if (oneTime)
      return updateInput(this, 'value', value);

    var observable = value;
    var binding = bindInputEvent(this, 'value', observable);
    updateInput(this, 'value',
                observable.open(inputBinding(this, 'value', sanitizeValue)));
    return maybeUpdateBindings(this, name, binding);
  }

  function updateOption(option, value) {
    var parentNode = option.parentNode;;
    var select;
    var selectBinding;
    var oldValue;
    if (parentNode instanceof HTMLSelectElement &&
        parentNode.bindings_ &&
        parentNode.bindings_.value) {
      select = parentNode;
      selectBinding = select.bindings_.value;
      oldValue = select.value;
    }

    option.value = sanitizeValue(value);

    if (select && select.value != oldValue) {
      selectBinding.observable_.setValue(select.value);
      selectBinding.observable_.discardChanges();
      Platform.performMicrotaskCheckpoint();
    }
  }

  function optionBinding(option) {
    return function(value) {
      updateOption(option, value);
    }
  }

  HTMLOptionElement.prototype.bind = function(name, value, oneTime) {
    if (name !== 'value')
      return HTMLElement.prototype.bind.call(this, name, value, oneTime);

    this.removeAttribute('value');

    if (oneTime)
      return updateOption(this, value);

    var observable = value;
    var binding = bindInputEvent(this, 'value', observable);
    updateOption(this, observable.open(optionBinding(this)));
    return maybeUpdateBindings(this, name, binding);
  }

  HTMLSelectElement.prototype.bind = function(name, value, oneTime) {
    if (name === 'selectedindex')
      name = 'selectedIndex';

    if (name !== 'selectedIndex' && name !== 'value')
      return HTMLElement.prototype.bind.call(this, name, value, oneTime);

    this.removeAttribute(name);

    if (oneTime)
      return updateInput(this, name, value);

    var observable = value;
    var binding = bindInputEvent(this, name, observable);
    updateInput(this, name,
                observable.open(inputBinding(this, name)));

    // Option update events may need to access select bindings.
    return updateBindings(this, name, binding);
  }
})(this);

// Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
// This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
// The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
// The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
// Code distributed by Google as part of the polymer project is also
// subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt

(function(global) {
  'use strict';

  function assert(v) {
    if (!v)
      throw new Error('Assertion failed');
  }

  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);

  function getFragmentRoot(node) {
    var p;
    while (p = node.parentNode) {
      node = p;
    }

    return node;
  }

  function searchRefId(node, id) {
    if (!id)
      return;

    var ref;
    var selector = '#' + id;
    while (!ref) {
      node = getFragmentRoot(node);

      if (node.protoContent_)
        ref = node.protoContent_.querySelector(selector);
      else if (node.getElementById)
        ref = node.getElementById(id);

      if (ref || !node.templateCreator_)
        break

      node = node.templateCreator_;
    }

    return ref;
  }

  function getInstanceRoot(node) {
    while (node.parentNode) {
      node = node.parentNode;
    }
    return node.templateCreator_ ? node : null;
  }

  var Map;
  if (global.Map && typeof global.Map.prototype.forEach === 'function') {
    Map = global.Map;
  } else {
    Map = function() {
      this.keys = [];
      this.values = [];
    };

    Map.prototype = {
      set: function(key, value) {
        var index = this.keys.indexOf(key);
        if (index < 0) {
          this.keys.push(key);
          this.values.push(value);
        } else {
          this.values[index] = value;
        }
      },

      get: function(key) {
        var index = this.keys.indexOf(key);
        if (index < 0)
          return;

        return this.values[index];
      },

      delete: function(key, value) {
        var index = this.keys.indexOf(key);
        if (index < 0)
          return false;

        this.keys.splice(index, 1);
        this.values.splice(index, 1);
        return true;
      },

      forEach: function(f, opt_this) {
        for (var i = 0; i < this.keys.length; i++)
          f.call(opt_this || this, this.values[i], this.keys[i], this);
      }
    };
  }

  // JScript does not have __proto__. We wrap all object literals with
  // createObject which uses Object.create, Object.defineProperty and
  // Object.getOwnPropertyDescriptor to create a new object that does the exact
  // same thing. The main downside to this solution is that we have to extract
  // all those property descriptors for IE.
  var createObject = ('__proto__' in {}) ?
      function(obj) { return obj; } :
      function(obj) {
        var proto = obj.__proto__;
        if (!proto)
          return obj;
        var newObject = Object.create(proto);
        Object.getOwnPropertyNames(obj).forEach(function(name) {
          Object.defineProperty(newObject, name,
                               Object.getOwnPropertyDescriptor(obj, name));
        });
        return newObject;
      };

  // IE does not support have Document.prototype.contains.
  if (typeof document.contains != 'function') {
    Document.prototype.contains = function(node) {
      if (node === this || node.parentNode === this)
        return true;
      return this.documentElement.contains(node);
    }
  }

  var BIND = 'bind';
  var REPEAT = 'repeat';
  var IF = 'if';

  var templateAttributeDirectives = {
    'template': true,
    'repeat': true,
    'bind': true,
    'ref': true
  };

  var semanticTemplateElements = {
    'THEAD': true,
    'TBODY': true,
    'TFOOT': true,
    'TH': true,
    'TR': true,
    'TD': true,
    'COLGROUP': true,
    'COL': true,
    'CAPTION': true,
    'OPTION': true,
    'OPTGROUP': true
  };

  var hasTemplateElement = typeof HTMLTemplateElement !== 'undefined';
  if (hasTemplateElement) {
    // TODO(rafaelw): Remove when fix for
    // https://codereview.chromium.org/164803002/
    // makes it to Chrome release.
    (function() {
      var t = document.createElement('template');
      var d = t.content.ownerDocument;
      var html = d.appendChild(d.createElement('html'));
      var head = html.appendChild(d.createElement('head'));
      var base = d.createElement('base');
      base.href = document.baseURI;
      head.appendChild(base);
    })();
  }

  var allTemplatesSelectors = 'template, ' +
      Object.keys(semanticTemplateElements).map(function(tagName) {
        return tagName.toLowerCase() + '[template]';
      }).join(', ');

  function isSVGTemplate(el) {
    return el.tagName == 'template' &&
           el.namespaceURI == 'http://www.w3.org/2000/svg';
  }

  function isHTMLTemplate(el) {
    return el.tagName == 'TEMPLATE' &&
           el.namespaceURI == 'http://www.w3.org/1999/xhtml';
  }

  function isAttributeTemplate(el) {
    return Boolean(semanticTemplateElements[el.tagName] &&
                   el.hasAttribute('template'));
  }

  function isTemplate(el) {
    if (el.isTemplate_ === undefined)
      el.isTemplate_ = el.tagName == 'TEMPLATE' || isAttributeTemplate(el);

    return el.isTemplate_;
  }

  // FIXME: Observe templates being added/removed from documents
  // FIXME: Expose imperative API to decorate and observe templates in
  // "disconnected tress" (e.g. ShadowRoot)
  document.addEventListener('DOMContentLoaded', function(e) {
    bootstrapTemplatesRecursivelyFrom(document);
    // FIXME: Is this needed? Seems like it shouldn't be.
    Platform.performMicrotaskCheckpoint();
  }, false);

  function forAllTemplatesFrom(node, fn) {
    var subTemplates = node.querySelectorAll(allTemplatesSelectors);

    if (isTemplate(node))
      fn(node)
    forEach(subTemplates, fn);
  }

  function bootstrapTemplatesRecursivelyFrom(node) {
    function bootstrap(template) {
      if (!HTMLTemplateElement.decorate(template))
        bootstrapTemplatesRecursivelyFrom(template.content);
    }

    forAllTemplatesFrom(node, bootstrap);
  }

  if (!hasTemplateElement) {
    /**
     * This represents a <template> element.
     * @constructor
     * @extends {HTMLElement}
     */
    global.HTMLTemplateElement = function() {
      throw TypeError('Illegal constructor');
    };
  }

  var hasProto = '__proto__' in {};

  function mixin(to, from) {
    Object.getOwnPropertyNames(from).forEach(function(name) {
      Object.defineProperty(to, name,
                            Object.getOwnPropertyDescriptor(from, name));
    });
  }

  // http://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/templates/index.html#dfn-template-contents-owner
  function getOrCreateTemplateContentsOwner(template) {
    var doc = template.ownerDocument
    if (!doc.defaultView)
      return doc;
    var d = doc.templateContentsOwner_;
    if (!d) {
      // TODO(arv): This should either be a Document or HTMLDocument depending
      // on doc.
      d = doc.implementation.createHTMLDocument('');
      while (d.lastChild) {
        d.removeChild(d.lastChild);
      }
      doc.templateContentsOwner_ = d;
    }
    return d;
  }

  function getTemplateStagingDocument(template) {
    if (!template.stagingDocument_) {
      var owner = template.ownerDocument;
      if (!owner.stagingDocument_) {
        owner.stagingDocument_ = owner.implementation.createHTMLDocument('');
        owner.stagingDocument_.isStagingDocument = true;
        // TODO(rafaelw): Remove when fix for
        // https://codereview.chromium.org/164803002/
        // makes it to Chrome release.
        var base = owner.stagingDocument_.createElement('base');
        base.href = document.baseURI;
        owner.stagingDocument_.head.appendChild(base);

        owner.stagingDocument_.stagingDocument_ = owner.stagingDocument_;
      }

      template.stagingDocument_ = owner.stagingDocument_;
    }

    return template.stagingDocument_;
  }

  // For non-template browsers, the parser will disallow <template> in certain
  // locations, so we allow "attribute templates" which combine the template
  // element with the top-level container node of the content, e.g.
  //
  //   <tr template repeat="{{ foo }}"" class="bar"><td>Bar</td></tr>
  //
  // becomes
  //
  //   <template repeat="{{ foo }}">
  //   + #document-fragment
  //     + <tr class="bar">
  //       + <td>Bar</td>
  //
  function extractTemplateFromAttributeTemplate(el) {
    var template = el.ownerDocument.createElement('template');
    el.parentNode.insertBefore(template, el);

    var attribs = el.attributes;
    var count = attribs.length;
    while (count-- > 0) {
      var attrib = attribs[count];
      if (templateAttributeDirectives[attrib.name]) {
        if (attrib.name !== 'template')
          template.setAttribute(attrib.name, attrib.value);
        el.removeAttribute(attrib.name);
      }
    }

    return template;
  }

  function extractTemplateFromSVGTemplate(el) {
    var template = el.ownerDocument.createElement('template');
    el.parentNode.insertBefore(template, el);

    var attribs = el.attributes;
    var count = attribs.length;
    while (count-- > 0) {
      var attrib = attribs[count];
      template.setAttribute(attrib.name, attrib.value);
      el.removeAttribute(attrib.name);
    }

    el.parentNode.removeChild(el);
    return template;
  }

  function liftNonNativeTemplateChildrenIntoContent(template, el, useRoot) {
    var content = template.content;
    if (useRoot) {
      content.appendChild(el);
      return;
    }

    var child;
    while (child = el.firstChild) {
      content.appendChild(child);
    }
  }

  var templateObserver;
  if (typeof MutationObserver == 'function') {
    templateObserver = new MutationObserver(function(records) {
      for (var i = 0; i < records.length; i++) {
        records[i].target.refChanged_();
      }
    });
  }

  /**
   * Ensures proper API and content model for template elements.
   * @param {HTMLTemplateElement} opt_instanceRef The template element which
   *     |el| template element will return as the value of its ref(), and whose
   *     content will be used as source when createInstance() is invoked.
   */
  HTMLTemplateElement.decorate = function(el, opt_instanceRef) {
    if (el.templateIsDecorated_)
      return false;

    var templateElement = el;
    templateElement.templateIsDecorated_ = true;

    var isNativeHTMLTemplate = isHTMLTemplate(templateElement) &&
                               hasTemplateElement;
    var bootstrapContents = isNativeHTMLTemplate;
    var liftContents = !isNativeHTMLTemplate;
    var liftRoot = false;

    if (!isNativeHTMLTemplate) {
      if (isAttributeTemplate(templateElement)) {
        assert(!opt_instanceRef);
        templateElement = extractTemplateFromAttributeTemplate(el);
        templateElement.templateIsDecorated_ = true;
        isNativeHTMLTemplate = hasTemplateElement;
        liftRoot = true;
      } else if (isSVGTemplate(templateElement)) {
        templateElement = extractTemplateFromSVGTemplate(el);
        templateElement.templateIsDecorated_ = true;
        isNativeHTMLTemplate = hasTemplateElement;
      }
    }

    if (!isNativeHTMLTemplate) {
      fixTemplateElementPrototype(templateElement);
      var doc = getOrCreateTemplateContentsOwner(templateElement);
      templateElement.content_ = doc.createDocumentFragment();
    }

    if (opt_instanceRef) {
      // template is contained within an instance, its direct content must be
      // empty
      templateElement.instanceRef_ = opt_instanceRef;
    } else if (liftContents) {
      liftNonNativeTemplateChildrenIntoContent(templateElement,
                                               el,
                                               liftRoot);
    } else if (bootstrapContents) {
      bootstrapTemplatesRecursivelyFrom(templateElement.content);
    }

    return true;
  };

  // TODO(rafaelw): This used to decorate recursively all templates from a given
  // node. This happens by default on 'DOMContentLoaded', but may be needed
  // in subtrees not descendent from document (e.g. ShadowRoot).
  // Review whether this is the right public API.
  HTMLTemplateElement.bootstrap = bootstrapTemplatesRecursivelyFrom;

  var htmlElement = global.HTMLUnknownElement || HTMLElement;

  var contentDescriptor = {
    get: function() {
      return this.content_;
    },
    enumerable: true,
    configurable: true
  };

  if (!hasTemplateElement) {
    // Gecko is more picky with the prototype than WebKit. Make sure to use the
    // same prototype as created in the constructor.
    HTMLTemplateElement.prototype = Object.create(htmlElement.prototype);

    Object.defineProperty(HTMLTemplateElement.prototype, 'content',
                          contentDescriptor);
  }

  function fixTemplateElementPrototype(el) {
    if (hasProto)
      el.__proto__ = HTMLTemplateElement.prototype;
    else
      mixin(el, HTMLTemplateElement.prototype);
  }

  function ensureSetModelScheduled(template) {
    if (!template.setModelFn_) {
      template.setModelFn_ = function() {
        template.setModelFnScheduled_ = false;
        var map = getBindings(template,
            template.delegate_ && template.delegate_.prepareBinding);
        processBindings(template, map, template.model_);
      };
    }

    if (!template.setModelFnScheduled_) {
      template.setModelFnScheduled_ = true;
      Observer.runEOM_(template.setModelFn_);
    }
  }

  mixin(HTMLTemplateElement.prototype, {
    bind: function(name, value, oneTime) {
      if (name != 'ref')
        return Element.prototype.bind.call(this, name, value, oneTime);

      var self = this;
      var ref = oneTime ? value : value.open(function(ref) {
        self.setAttribute('ref', ref);
        self.refChanged_();
      });

      this.setAttribute('ref', ref);
      this.refChanged_();
      if (oneTime)
        return;

      if (!this.bindings_) {
        this.bindings_ = { ref: value };
      } else {
        this.bindings_.ref = value;
      }

      return value;
    },

    processBindingDirectives_: function(directives) {
      if (this.iterator_)
        this.iterator_.closeDeps();

      if (!directives.if && !directives.bind && !directives.repeat) {
        if (this.iterator_) {
          this.iterator_.close();
          this.iterator_ = undefined;
        }

        return;
      }

      if (!this.iterator_) {
        this.iterator_ = new TemplateIterator(this);
      }

      this.iterator_.updateDependencies(directives, this.model_);

      if (templateObserver) {
        templateObserver.observe(this, { attributes: true,
                                         attributeFilter: ['ref'] });
      }

      return this.iterator_;
    },

    createInstance: function(model, bindingDelegate, delegate_) {
      if (bindingDelegate)
        delegate_ = this.newDelegate_(bindingDelegate);
      else if (!delegate_)
        delegate_ = this.delegate_;

      if (!this.refContent_)
        this.refContent_ = this.ref_.content;
      var content = this.refContent_;
      if (content.firstChild === null)
        return emptyInstance;

      var map = getInstanceBindingMap(content, delegate_);
      var stagingDocument = getTemplateStagingDocument(this);
      var instance = stagingDocument.createDocumentFragment();
      instance.templateCreator_ = this;
      instance.protoContent_ = content;
      instance.bindings_ = [];
      instance.terminator_ = null;
      var instanceRecord = instance.templateInstance_ = {
        firstNode: null,
        lastNode: null,
        model: model
      };

      var i = 0;
      var collectTerminator = false;
      for (var child = content.firstChild; child; child = child.nextSibling) {
        // The terminator of the instance is the clone of the last child of the
        // content. If the last child is an active template, it may produce
        // instances as a result of production, so simply collecting the last
        // child of the instance after it has finished producing may be wrong.
        if (child.nextSibling === null)
          collectTerminator = true;

        var clone = cloneAndBindInstance(child, instance, stagingDocument,
                                         map.children[i++],
                                         model,
                                         delegate_,
                                         instance.bindings_);
        clone.templateInstance_ = instanceRecord;
        if (collectTerminator)
          instance.terminator_ = clone;
      }

      instanceRecord.firstNode = instance.firstChild;
      instanceRecord.lastNode = instance.lastChild;
      instance.templateCreator_ = undefined;
      instance.protoContent_ = undefined;
      return instance;
    },

    get model() {
      return this.model_;
    },

    set model(model) {
      this.model_ = model;
      ensureSetModelScheduled(this);
    },

    get bindingDelegate() {
      return this.delegate_ && this.delegate_.raw;
    },

    refChanged_: function() {
      if (!this.iterator_ || this.refContent_ === this.ref_.content)
        return;

      this.refContent_ = undefined;
      this.iterator_.valueChanged();
      this.iterator_.updateIteratedValue(this.iterator_.getUpdatedValue());
    },

    clear: function() {
      this.model_ = undefined;
      this.delegate_ = undefined;
      if (this.bindings_ && this.bindings_.ref)
        this.bindings_.ref.close()
      this.refContent_ = undefined;
      if (!this.iterator_)
        return;
      this.iterator_.valueChanged();
      this.iterator_.close()
      this.iterator_ = undefined;
    },

    setDelegate_: function(delegate) {
      this.delegate_ = delegate;
      this.bindingMap_ = undefined;
      if (this.iterator_) {
        this.iterator_.instancePositionChangedFn_ = undefined;
        this.iterator_.instanceModelFn_ = undefined;
      }
    },

    newDelegate_: function(bindingDelegate) {
      if (!bindingDelegate)
        return;

      function delegateFn(name) {
        var fn = bindingDelegate && bindingDelegate[name];
        if (typeof fn != 'function')
          return;

        return function() {
          return fn.apply(bindingDelegate, arguments);
        };
      }

      return {
        bindingMaps: {},
        raw: bindingDelegate,
        prepareBinding: delegateFn('prepareBinding'),
        prepareInstanceModel: delegateFn('prepareInstanceModel'),
        prepareInstancePositionChanged:
            delegateFn('prepareInstancePositionChanged')
      };
    },

    set bindingDelegate(bindingDelegate) {
      if (this.delegate_) {
        throw Error('Template must be cleared before a new bindingDelegate ' +
                    'can be assigned');
      }

      this.setDelegate_(this.newDelegate_(bindingDelegate));
    },

    get ref_() {
      var ref = searchRefId(this, this.getAttribute('ref'));
      if (!ref)
        ref = this.instanceRef_;

      if (!ref)
        return this;

      var nextRef = ref.ref_;
      return nextRef ? nextRef : ref;
    }
  });

  // Returns
  //   a) undefined if there are no mustaches.
  //   b) [TEXT, (ONE_TIME?, PATH, DELEGATE_FN, TEXT)+] if there is at least one mustache.
  function parseMustaches(s, name, node, prepareBindingFn) {
    if (!s || !s.length)
      return;

    var tokens;
    var length = s.length;
    var startIndex = 0, lastIndex = 0, endIndex = 0;
    var onlyOneTime = true;
    while (lastIndex < length) {
      var startIndex = s.indexOf('{{', lastIndex);
      var oneTimeStart = s.indexOf('[[', lastIndex);
      var oneTime = false;
      var terminator = '}}';

      if (oneTimeStart >= 0 &&
          (startIndex < 0 || oneTimeStart < startIndex)) {
        startIndex = oneTimeStart;
        oneTime = true;
        terminator = ']]';
      }

      endIndex = startIndex < 0 ? -1 : s.indexOf(terminator, startIndex + 2);

      if (endIndex < 0) {
        if (!tokens)
          return;

        tokens.push(s.slice(lastIndex)); // TEXT
        break;
      }

      tokens = tokens || [];
      tokens.push(s.slice(lastIndex, startIndex)); // TEXT
      var pathString = s.slice(startIndex + 2, endIndex).trim();
      tokens.push(oneTime); // ONE_TIME?
      onlyOneTime = onlyOneTime && oneTime;
      var delegateFn = prepareBindingFn &&
                       prepareBindingFn(pathString, name, node);
      // Don't try to parse the expression if there's a prepareBinding function
      if (delegateFn == null) {
        tokens.push(Path.get(pathString)); // PATH
      } else {
        tokens.push(null);
      }
      tokens.push(delegateFn); // DELEGATE_FN
      lastIndex = endIndex + 2;
    }

    if (lastIndex === length)
      tokens.push(''); // TEXT

    tokens.hasOnePath = tokens.length === 5;
    tokens.isSimplePath = tokens.hasOnePath &&
                          tokens[0] == '' &&
                          tokens[4] == '';
    tokens.onlyOneTime = onlyOneTime;

    tokens.combinator = function(values) {
      var newValue = tokens[0];

      for (var i = 1; i < tokens.length; i += 4) {
        var value = tokens.hasOnePath ? values : values[(i - 1) / 4];
        if (value !== undefined)
          newValue += value;
        newValue += tokens[i + 3];
      }

      return newValue;
    }

    return tokens;
  };

  function processOneTimeBinding(name, tokens, node, model) {
    if (tokens.hasOnePath) {
      var delegateFn = tokens[3];
      var value = delegateFn ? delegateFn(model, node, true) :
                               tokens[2].getValueFrom(model);
      return tokens.isSimplePath ? value : tokens.combinator(value);
    }

    var values = [];
    for (var i = 1; i < tokens.length; i += 4) {
      var delegateFn = tokens[i + 2];
      values[(i - 1) / 4] = delegateFn ? delegateFn(model, node) :
          tokens[i + 1].getValueFrom(model);
    }

    return tokens.combinator(values);
  }

  function processSinglePathBinding(name, tokens, node, model) {
    var delegateFn = tokens[3];
    var observer = delegateFn ? delegateFn(model, node, false) :
        new PathObserver(model, tokens[2]);

    return tokens.isSimplePath ? observer :
        new ObserverTransform(observer, tokens.combinator);
  }

  function processBinding(name, tokens, node, model) {
    if (tokens.onlyOneTime)
      return processOneTimeBinding(name, tokens, node, model);

    if (tokens.hasOnePath)
      return processSinglePathBinding(name, tokens, node, model);

    var observer = new CompoundObserver();

    for (var i = 1; i < tokens.length; i += 4) {
      var oneTime = tokens[i];
      var delegateFn = tokens[i + 2];

      if (delegateFn) {
        var value = delegateFn(model, node, oneTime);
        if (oneTime)
          observer.addPath(value)
        else
          observer.addObserver(value);
        continue;
      }

      var path = tokens[i + 1];
      if (oneTime)
        observer.addPath(path.getValueFrom(model))
      else
        observer.addPath(model, path);
    }

    return new ObserverTransform(observer, tokens.combinator);
  }

  function processBindings(node, bindings, model, instanceBindings) {
    for (var i = 0; i < bindings.length; i += 2) {
      var name = bindings[i]
      var tokens = bindings[i + 1];
      var value = processBinding(name, tokens, node, model);
      var binding = node.bind(name, value, tokens.onlyOneTime);
      if (binding && instanceBindings)
        instanceBindings.push(binding);
    }

    node.bindFinished();
    if (!bindings.isTemplate)
      return;

    node.model_ = model;
    var iter = node.processBindingDirectives_(bindings);
    if (instanceBindings && iter)
      instanceBindings.push(iter);
  }

  function parseWithDefault(el, name, prepareBindingFn) {
    var v = el.getAttribute(name);
    return parseMustaches(v == '' ? '{{}}' : v, name, el, prepareBindingFn);
  }

  function parseAttributeBindings(element, prepareBindingFn) {
    assert(element);

    var bindings = [];
    var ifFound = false;
    var bindFound = false;

    for (var i = 0; i < element.attributes.length; i++) {
      var attr = element.attributes[i];
      var name = attr.name;
      var value = attr.value;

      // Allow bindings expressed in attributes to be prefixed with underbars.
      // We do this to allow correct semantics for browsers that don't implement
      // <template> where certain attributes might trigger side-effects -- and
      // for IE which sanitizes certain attributes, disallowing mustache
      // replacements in their text.
      while (name[0] === '_') {
        name = name.substring(1);
      }

      if (isTemplate(element) &&
          (name === IF || name === BIND || name === REPEAT)) {
        continue;
      }

      var tokens = parseMustaches(value, name, element,
                                  prepareBindingFn);
      if (!tokens)
        continue;

      bindings.push(name, tokens);
    }

    if (isTemplate(element)) {
      bindings.isTemplate = true;
      bindings.if = parseWithDefault(element, IF, prepareBindingFn);
      bindings.bind = parseWithDefault(element, BIND, prepareBindingFn);
      bindings.repeat = parseWithDefault(element, REPEAT, prepareBindingFn);

      if (bindings.if && !bindings.bind && !bindings.repeat)
        bindings.bind = parseMustaches('{{}}', BIND, element, prepareBindingFn);
    }

    return bindings;
  }

  function getBindings(node, prepareBindingFn) {
    if (node.nodeType === Node.ELEMENT_NODE)
      return parseAttributeBindings(node, prepareBindingFn);

    if (node.nodeType === Node.TEXT_NODE) {
      var tokens = parseMustaches(node.data, 'textContent', node,
                                  prepareBindingFn);
      if (tokens)
        return ['textContent', tokens];
    }

    return [];
  }

  function cloneAndBindInstance(node, parent, stagingDocument, bindings, model,
                                delegate,
                                instanceBindings,
                                instanceRecord) {
    var clone = parent.appendChild(stagingDocument.importNode(node, false));

    var i = 0;
    for (var child = node.firstChild; child; child = child.nextSibling) {
      cloneAndBindInstance(child, clone, stagingDocument,
                            bindings.children[i++],
                            model,
                            delegate,
                            instanceBindings);
    }

    if (bindings.isTemplate) {
      HTMLTemplateElement.decorate(clone, node);
      if (delegate)
        clone.setDelegate_(delegate);
    }

    processBindings(clone, bindings, model, instanceBindings);
    return clone;
  }

  function createInstanceBindingMap(node, prepareBindingFn) {
    var map = getBindings(node, prepareBindingFn);
    map.children = {};
    var index = 0;
    for (var child = node.firstChild; child; child = child.nextSibling) {
      map.children[index++] = createInstanceBindingMap(child, prepareBindingFn);
    }

    return map;
  }

  var contentUidCounter = 1;

  // TODO(rafaelw): Setup a MutationObserver on content which clears the id
  // so that bindingMaps regenerate when the template.content changes.
  function getContentUid(content) {
    var id = content.id_;
    if (!id)
      id = content.id_ = contentUidCounter++;
    return id;
  }

  // Each delegate is associated with a set of bindingMaps, one for each
  // content which may be used by a template. The intent is that each binding
  // delegate gets the opportunity to prepare the instance (via the prepare*
  // delegate calls) once across all uses.
  // TODO(rafaelw): Separate out the parse map from the binding map. In the
  // current implementation, if two delegates need a binding map for the same
  // content, the second will have to reparse.
  function getInstanceBindingMap(content, delegate_) {
    var contentId = getContentUid(content);
    if (delegate_) {
      var map = delegate_.bindingMaps[contentId];
      if (!map) {
        map = delegate_.bindingMaps[contentId] =
            createInstanceBindingMap(content, delegate_.prepareBinding) || [];
      }
      return map;
    }

    var map = content.bindingMap_;
    if (!map) {
      map = content.bindingMap_ =
          createInstanceBindingMap(content, undefined) || [];
    }
    return map;
  }

  Object.defineProperty(Node.prototype, 'templateInstance', {
    get: function() {
      var instance = this.templateInstance_;
      return instance ? instance :
          (this.parentNode ? this.parentNode.templateInstance : undefined);
    }
  });

  var emptyInstance = document.createDocumentFragment();
  emptyInstance.bindings_ = [];
  emptyInstance.terminator_ = null;

  function TemplateIterator(templateElement) {
    this.closed = false;
    this.templateElement_ = templateElement;
    this.instances = [];
    this.deps = undefined;
    this.iteratedValue = [];
    this.presentValue = undefined;
    this.arrayObserver = undefined;
  }

  TemplateIterator.prototype = {
    closeDeps: function() {
      var deps = this.deps;
      if (deps) {
        if (deps.ifOneTime === false)
          deps.ifValue.close();
        if (deps.oneTime === false)
          deps.value.close();
      }
    },

    updateDependencies: function(directives, model) {
      this.closeDeps();

      var deps = this.deps = {};
      var template = this.templateElement_;

      var ifValue = true;
      if (directives.if) {
        deps.hasIf = true;
        deps.ifOneTime = directives.if.onlyOneTime;
        deps.ifValue = processBinding(IF, directives.if, template, model);

        ifValue = deps.ifValue;

        // oneTime if & predicate is false. nothing else to do.
        if (deps.ifOneTime && !ifValue) {
          this.valueChanged();
          return;
        }

        if (!deps.ifOneTime)
          ifValue = ifValue.open(this.updateIfValue, this);
      }

      if (directives.repeat) {
        deps.repeat = true;
        deps.oneTime = directives.repeat.onlyOneTime;
        deps.value = processBinding(REPEAT, directives.repeat, template, model);
      } else {
        deps.repeat = false;
        deps.oneTime = directives.bind.onlyOneTime;
        deps.value = processBinding(BIND, directives.bind, template, model);
      }

      var value = deps.value;
      if (!deps.oneTime)
        value = value.open(this.updateIteratedValue, this);

      if (!ifValue) {
        this.valueChanged();
        return;
      }

      this.updateValue(value);
    },

    /**
     * Gets the updated value of the bind/repeat. This can potentially call
     * user code (if a bindingDelegate is set up) so we try to avoid it if we
     * already have the value in hand (from Observer.open).
     */
    getUpdatedValue: function() {
      var value = this.deps.value;
      if (!this.deps.oneTime)
        value = value.discardChanges();
      return value;
    },

    updateIfValue: function(ifValue) {
      if (!ifValue) {
        this.valueChanged();
        return;
      }

      this.updateValue(this.getUpdatedValue());
    },

    updateIteratedValue: function(value) {
      if (this.deps.hasIf) {
        var ifValue = this.deps.ifValue;
        if (!this.deps.ifOneTime)
          ifValue = ifValue.discardChanges();
        if (!ifValue) {
          this.valueChanged();
          return;
        }
      }

      this.updateValue(value);
    },

    updateValue: function(value) {
      if (!this.deps.repeat)
        value = [value];
      var observe = this.deps.repeat &&
                    !this.deps.oneTime &&
                    Array.isArray(value);
      this.valueChanged(value, observe);
    },

    valueChanged: function(value, observeValue) {
      if (!Array.isArray(value))
        value = [];

      if (value === this.iteratedValue)
        return;

      this.unobserve();
      this.presentValue = value;
      if (observeValue) {
        this.arrayObserver = new ArrayObserver(this.presentValue);
        this.arrayObserver.open(this.handleSplices, this);
      }

      this.handleSplices(ArrayObserver.calculateSplices(this.presentValue,
                                                        this.iteratedValue));
    },

    getLastInstanceNode: function(index) {
      if (index == -1)
        return this.templateElement_;
      var instance = this.instances[index];
      var terminator = instance.terminator_;
      if (!terminator)
        return this.getLastInstanceNode(index - 1);

      if (terminator.nodeType !== Node.ELEMENT_NODE ||
          this.templateElement_ === terminator) {
        return terminator;
      }

      var subtemplateIterator = terminator.iterator_;
      if (!subtemplateIterator)
        return terminator;

      return subtemplateIterator.getLastTemplateNode();
    },

    getLastTemplateNode: function() {
      return this.getLastInstanceNode(this.instances.length - 1);
    },

    insertInstanceAt: function(index, fragment) {
      var previousInstanceLast = this.getLastInstanceNode(index - 1);
      var parent = this.templateElement_.parentNode;
      this.instances.splice(index, 0, fragment);

      parent.insertBefore(fragment, previousInstanceLast.nextSibling);
    },

    extractInstanceAt: function(index) {
      var previousInstanceLast = this.getLastInstanceNode(index - 1);
      var lastNode = this.getLastInstanceNode(index);
      var parent = this.templateElement_.parentNode;
      var instance = this.instances.splice(index, 1)[0];

      while (lastNode !== previousInstanceLast) {
        var node = previousInstanceLast.nextSibling;
        if (node == lastNode)
          lastNode = previousInstanceLast;

        instance.appendChild(parent.removeChild(node));
      }

      return instance;
    },

    getDelegateFn: function(fn) {
      fn = fn && fn(this.templateElement_);
      return typeof fn === 'function' ? fn : null;
    },

    handleSplices: function(splices) {
      if (this.closed || !splices.length)
        return;

      var template = this.templateElement_;

      if (!template.parentNode) {
        this.close();
        return;
      }

      ArrayObserver.applySplices(this.iteratedValue, this.presentValue,
                                 splices);

      var delegate = template.delegate_;
      if (this.instanceModelFn_ === undefined) {
        this.instanceModelFn_ =
            this.getDelegateFn(delegate && delegate.prepareInstanceModel);
      }

      if (this.instancePositionChangedFn_ === undefined) {
        this.instancePositionChangedFn_ =
            this.getDelegateFn(delegate &&
                               delegate.prepareInstancePositionChanged);
      }

      // Instance Removals
      var instanceCache = new Map;
      var removeDelta = 0;
      for (var i = 0; i < splices.length; i++) {
        var splice = splices[i];
        var removed = splice.removed;
        for (var j = 0; j < removed.length; j++) {
          var model = removed[j];
          var instance = this.extractInstanceAt(splice.index + removeDelta);
          if (instance !== emptyInstance) {
            instanceCache.set(model, instance);
          }
        }

        removeDelta -= splice.addedCount;
      }

      // Instance Insertions
      for (var i = 0; i < splices.length; i++) {
        var splice = splices[i];
        var addIndex = splice.index;
        for (; addIndex < splice.index + splice.addedCount; addIndex++) {
          var model = this.iteratedValue[addIndex];
          var instance = instanceCache.get(model);
          if (instance) {
            instanceCache.delete(model);
          } else {
            if (this.instanceModelFn_) {
              model = this.instanceModelFn_(model);
            }

            if (model === undefined) {
              instance = emptyInstance;
            } else {
              instance = template.createInstance(model, undefined, delegate);
            }
          }

          this.insertInstanceAt(addIndex, instance);
        }
      }

      instanceCache.forEach(function(instance) {
        this.closeInstanceBindings(instance);
      }, this);

      if (this.instancePositionChangedFn_)
        this.reportInstancesMoved(splices);
    },

    reportInstanceMoved: function(index) {
      var instance = this.instances[index];
      if (instance === emptyInstance)
        return;

      this.instancePositionChangedFn_(instance.templateInstance_, index);
    },

    reportInstancesMoved: function(splices) {
      var index = 0;
      var offset = 0;
      for (var i = 0; i < splices.length; i++) {
        var splice = splices[i];
        if (offset != 0) {
          while (index < splice.index) {
            this.reportInstanceMoved(index);
            index++;
          }
        } else {
          index = splice.index;
        }

        while (index < splice.index + splice.addedCount) {
          this.reportInstanceMoved(index);
          index++;
        }

        offset += splice.addedCount - splice.removed.length;
      }

      if (offset == 0)
        return;

      var length = this.instances.length;
      while (index < length) {
        this.reportInstanceMoved(index);
        index++;
      }
    },

    closeInstanceBindings: function(instance) {
      var bindings = instance.bindings_;
      for (var i = 0; i < bindings.length; i++) {
        bindings[i].close();
      }
    },

    unobserve: function() {
      if (!this.arrayObserver)
        return;

      this.arrayObserver.close();
      this.arrayObserver = undefined;
    },

    close: function() {
      if (this.closed)
        return;
      this.unobserve();
      for (var i = 0; i < this.instances.length; i++) {
        this.closeInstanceBindings(this.instances[i]);
      }

      this.instances.length = 0;
      this.closeDeps();
      this.templateElement_.iterator_ = undefined;
      this.closed = true;
    }
  };

  // Polyfill-specific API.
  HTMLTemplateElement.forAllTemplatesFrom_ = forAllTemplatesFrom;
})(this);

(function(scope) {
  'use strict';

  // feature detect for URL constructor
  var hasWorkingUrl = false;
  if (!scope.forceJURL) {
    try {
      var u = new URL('b', 'http://a');
      hasWorkingUrl = u.href === 'http://a/b';
    } catch(e) {}
  }

  if (hasWorkingUrl)
    return;

  var relative = Object.create(null);
  relative['ftp'] = 21;
  relative['file'] = 0;
  relative['gopher'] = 70;
  relative['http'] = 80;
  relative['https'] = 443;
  relative['ws'] = 80;
  relative['wss'] = 443;

  var relativePathDotMapping = Object.create(null);
  relativePathDotMapping['%2e'] = '.';
  relativePathDotMapping['.%2e'] = '..';
  relativePathDotMapping['%2e.'] = '..';
  relativePathDotMapping['%2e%2e'] = '..';

  function isRelativeScheme(scheme) {
    return relative[scheme] !== undefined;
  }

  function invalid() {
    clear.call(this);
    this._isInvalid = true;
  }

  function IDNAToASCII(h) {
    if ('' == h) {
      invalid.call(this)
    }
    // XXX
    return h.toLowerCase()
  }

  function percentEscape(c) {
    var unicode = c.charCodeAt(0);
    if (unicode > 0x20 &&
       unicode < 0x7F &&
       // " # < > ? `
       [0x22, 0x23, 0x3C, 0x3E, 0x3F, 0x60].indexOf(unicode) == -1
      ) {
      return c;
    }
    return encodeURIComponent(c);
  }

  function percentEscapeQuery(c) {
    // XXX This actually needs to encode c using encoding and then
    // convert the bytes one-by-one.

    var unicode = c.charCodeAt(0);
    if (unicode > 0x20 &&
       unicode < 0x7F &&
       // " # < > ` (do not escape '?')
       [0x22, 0x23, 0x3C, 0x3E, 0x60].indexOf(unicode) == -1
      ) {
      return c;
    }
    return encodeURIComponent(c);
  }

  var EOF = undefined,
      ALPHA = /[a-zA-Z]/,
      ALPHANUMERIC = /[a-zA-Z0-9\+\-\.]/;

  function parse(input, stateOverride, base) {
    function err(message) {
      errors.push(message)
    }

    var state = stateOverride || 'scheme start',
        cursor = 0,
        buffer = '',
        seenAt = false,
        seenBracket = false,
        errors = [];

    loop: while ((input[cursor - 1] != EOF || cursor == 0) && !this._isInvalid) {
      var c = input[cursor];
      switch (state) {
        case 'scheme start':
          if (c && ALPHA.test(c)) {
            buffer += c.toLowerCase(); // ASCII-safe
            state = 'scheme';
          } else if (!stateOverride) {
            buffer = '';
            state = 'no scheme';
            continue;
          } else {
            err('Invalid scheme.');
            break loop;
          }
          break;

        case 'scheme':
          if (c && ALPHANUMERIC.test(c)) {
            buffer += c.toLowerCase(); // ASCII-safe
          } else if (':' == c) {
            this._scheme = buffer;
            buffer = '';
            if (stateOverride) {
              break loop;
            }
            if (isRelativeScheme(this._scheme)) {
              this._isRelative = true;
            }
            if ('file' == this._scheme) {
              state = 'relative';
            } else if (this._isRelative && base && base._scheme == this._scheme) {
              state = 'relative or authority';
            } else if (this._isRelative) {
              state = 'authority first slash';
            } else {
              state = 'scheme data';
            }
          } else if (!stateOverride) {
            buffer = '';
            cursor = 0;
            state = 'no scheme';
            continue;
          } else if (EOF == c) {
            break loop;
          } else {
            err('Code point not allowed in scheme: ' + c)
            break loop;
          }
          break;

        case 'scheme data':
          if ('?' == c) {
            query = '?';
            state = 'query';
          } else if ('#' == c) {
            this._fragment = '#';
            state = 'fragment';
          } else {
            // XXX error handling
            if (EOF != c && '\t' != c && '\n' != c && '\r' != c) {
              this._schemeData += percentEscape(c);
            }
          }
          break;

        case 'no scheme':
          if (!base || !(isRelativeScheme(base._scheme))) {
            err('Missing scheme.');
            invalid.call(this);
          } else {
            state = 'relative';
            continue;
          }
          break;

        case 'relative or authority':
          if ('/' == c && '/' == input[cursor+1]) {
            state = 'authority ignore slashes';
          } else {
            err('Expected /, got: ' + c);
            state = 'relative';
            continue
          }
          break;

        case 'relative':
          this._isRelative = true;
          if ('file' != this._scheme)
            this._scheme = base._scheme;
          if (EOF == c) {
            this._host = base._host;
            this._port = base._port;
            this._path = base._path.slice();
            this._query = base._query;
            break loop;
          } else if ('/' == c || '\\' == c) {
            if ('\\' == c)
              err('\\ is an invalid code point.');
            state = 'relative slash';
          } else if ('?' == c) {
            this._host = base._host;
            this._port = base._port;
            this._path = base._path.slice();
            this._query = '?';
            state = 'query';
          } else if ('#' == c) {
            this._host = base._host;
            this._port = base._port;
            this._path = base._path.slice();
            this._query = base._query;
            this._fragment = '#';
            state = 'fragment';
          } else {
            var nextC = input[cursor+1]
            var nextNextC = input[cursor+2]
            if (
              'file' != this._scheme || !ALPHA.test(c) ||
              (nextC != ':' && nextC != '|') ||
              (EOF != nextNextC && '/' != nextNextC && '\\' != nextNextC && '?' != nextNextC && '#' != nextNextC)) {
              this._host = base._host;
              this._port = base._port;
              this._path = base._path.slice();
              this._path.pop();
            }
            state = 'relative path';
            continue;
          }
          break;

        case 'relative slash':
          if ('/' == c || '\\' == c) {
            if ('\\' == c) {
              err('\\ is an invalid code point.');
            }
            if ('file' == this._scheme) {
              state = 'file host';
            } else {
              state = 'authority ignore slashes';
            }
          } else {
            if ('file' != this._scheme) {
              this._host = base._host;
              this._port = base._port;
            }
            state = 'relative path';
            continue;
          }
          break;

        case 'authority first slash':
          if ('/' == c) {
            state = 'authority second slash';
          } else {
            err("Expected '/', got: " + c);
            state = 'authority ignore slashes';
            continue;
          }
          break;

        case 'authority second slash':
          state = 'authority ignore slashes';
          if ('/' != c) {
            err("Expected '/', got: " + c);
            continue;
          }
          break;

        case 'authority ignore slashes':
          if ('/' != c && '\\' != c) {
            state = 'authority';
            continue;
          } else {
            err('Expected authority, got: ' + c);
          }
          break;

        case 'authority':
          if ('@' == c) {
            if (seenAt) {
              err('@ already seen.');
              buffer += '%40';
            }
            seenAt = true;
            for (var i = 0; i < buffer.length; i++) {
              var cp = buffer[i];
              if ('\t' == cp || '\n' == cp || '\r' == cp) {
                err('Invalid whitespace in authority.');
                continue;
              }
              // XXX check URL code points
              if (':' == cp && null === this._password) {
                this._password = '';
                continue;
              }
              var tempC = percentEscape(cp);
              (null !== this._password) ? this._password += tempC : this._username += tempC;
            }
            buffer = '';
          } else if (EOF == c || '/' == c || '\\' == c || '?' == c || '#' == c) {
            cursor -= buffer.length;
            buffer = '';
            state = 'host';
            continue;
          } else {
            buffer += c;
          }
          break;

        case 'file host':
          if (EOF == c || '/' == c || '\\' == c || '?' == c || '#' == c) {
            if (buffer.length == 2 && ALPHA.test(buffer[0]) && (buffer[1] == ':' || buffer[1] == '|')) {
              state = 'relative path';
            } else if (buffer.length == 0) {
              state = 'relative path start';
            } else {
              this._host = IDNAToASCII.call(this, buffer);
              buffer = '';
              state = 'relative path start';
            }
            continue;
          } else if ('\t' == c || '\n' == c || '\r' == c) {
            err('Invalid whitespace in file host.');
          } else {
            buffer += c;
          }
          break;

        case 'host':
        case 'hostname':
          if (':' == c && !seenBracket) {
            // XXX host parsing
            this._host = IDNAToASCII.call(this, buffer);
            buffer = '';
            state = 'port';
            if ('hostname' == stateOverride) {
              break loop;
            }
          } else if (EOF == c || '/' == c || '\\' == c || '?' == c || '#' == c) {
            this._host = IDNAToASCII.call(this, buffer);
            buffer = '';
            state = 'relative path start';
            if (stateOverride) {
              break loop;
            }
            continue;
          } else if ('\t' != c && '\n' != c && '\r' != c) {
            if ('[' == c) {
              seenBracket = true;
            } else if (']' == c) {
              seenBracket = false;
            }
            buffer += c;
          } else {
            err('Invalid code point in host/hostname: ' + c);
          }
          break;

        case 'port':
          if (/[0-9]/.test(c)) {
            buffer += c;
          } else if (EOF == c || '/' == c || '\\' == c || '?' == c || '#' == c || stateOverride) {
            if ('' != buffer) {
              var temp = parseInt(buffer, 10);
              if (temp != relative[this._scheme]) {
                this._port = temp + '';
              }
              buffer = '';
            }
            if (stateOverride) {
              break loop;
            }
            state = 'relative path start';
            continue;
          } else if ('\t' == c || '\n' == c || '\r' == c) {
            err('Invalid code point in port: ' + c);
          } else {
            invalid.call(this);
          }
          break;

        case 'relative path start':
          if ('\\' == c)
            err("'\\' not allowed in path.");
          state = 'relative path';
          if ('/' != c && '\\' != c) {
            continue;
          }
          break;

        case 'relative path':
          if (EOF == c || '/' == c || '\\' == c || (!stateOverride && ('?' == c || '#' == c))) {
            if ('\\' == c) {
              err('\\ not allowed in relative path.');
            }
            var tmp;
            if (tmp = relativePathDotMapping[buffer.toLowerCase()]) {
              buffer = tmp;
            }
            if ('..' == buffer) {
              this._path.pop();
              if ('/' != c && '\\' != c) {
                this._path.push('');
              }
            } else if ('.' == buffer && '/' != c && '\\' != c) {
              this._path.push('');
            } else if ('.' != buffer) {
              if ('file' == this._scheme && this._path.length == 0 && buffer.length == 2 && ALPHA.test(buffer[0]) && buffer[1] == '|') {
                buffer = buffer[0] + ':';
              }
              this._path.push(buffer);
            }
            buffer = '';
            if ('?' == c) {
              this._query = '?';
              state = 'query';
            } else if ('#' == c) {
              this._fragment = '#';
              state = 'fragment';
            }
          } else if ('\t' != c && '\n' != c && '\r' != c) {
            buffer += percentEscape(c);
          }
          break;

        case 'query':
          if (!stateOverride && '#' == c) {
            this._fragment = '#';
            state = 'fragment';
          } else if (EOF != c && '\t' != c && '\n' != c && '\r' != c) {
            this._query += percentEscapeQuery(c);
          }
          break;

        case 'fragment':
          if (EOF != c && '\t' != c && '\n' != c && '\r' != c) {
            this._fragment += c;
          }
          break;
      }

      cursor++;
    }
  }

  function clear() {
    this._scheme = '';
    this._schemeData = '';
    this._username = '';
    this._password = null;
    this._host = '';
    this._port = '';
    this._path = [];
    this._query = '';
    this._fragment = '';
    this._isInvalid = false;
    this._isRelative = false;
  }

  // Does not process domain names or IP addresses.
  // Does not handle encoding for the query parameter.
  function jURL(url, base /* , encoding */) {
    if (base !== undefined && !(base instanceof jURL))
      base = new jURL(String(base));

    this._url = url;
    clear.call(this);

    var input = url.replace(/^[ \t\r\n\f]+|[ \t\r\n\f]+$/g, '');
    // encoding = encoding || 'utf-8'

    parse.call(this, input, null, base);
  }

  jURL.prototype = {
    get href() {
      if (this._isInvalid)
        return this._url;

      var authority = '';
      if ('' != this._username || null != this._password) {
        authority = this._username +
            (null != this._password ? ':' + this._password : '') + '@';
      }

      return this.protocol +
          (this._isRelative ? '//' + authority + this.host : '') +
          this.pathname + this._query + this._fragment;
    },
    set href(href) {
      clear.call(this);
      parse.call(this, href);
    },

    get protocol() {
      return this._scheme + ':';
    },
    set protocol(protocol) {
      if (this._isInvalid)
        return;
      parse.call(this, protocol + ':', 'scheme start');
    },

    get host() {
      return this._isInvalid ? '' : this._port ?
          this._host + ':' + this._port : this._host;
    },
    set host(host) {
      if (this._isInvalid || !this._isRelative)
        return;
      parse.call(this, host, 'host');
    },

    get hostname() {
      return this._host;
    },
    set hostname(hostname) {
      if (this._isInvalid || !this._isRelative)
        return;
      parse.call(this, hostname, 'hostname');
    },

    get port() {
      return this._port;
    },
    set port(port) {
      if (this._isInvalid || !this._isRelative)
        return;
      parse.call(this, port, 'port');
    },

    get pathname() {
      return this._isInvalid ? '' : this._isRelative ?
          '/' + this._path.join('/') : this._schemeData;
    },
    set pathname(pathname) {
      if (this._isInvalid || !this._isRelative)
        return;
      this._path = [];
      parse.call(this, pathname, 'relative path start');
    },

    get search() {
      return this._isInvalid || !this._query || '?' == this._query ?
          '' : this._query;
    },
    set search(search) {
      if (this._isInvalid || !this._isRelative)
        return;
      this._query = '?';
      if ('?' == search[0])
        search = search.slice(1);
      parse.call(this, search, 'query');
    },

    get hash() {
      return this._isInvalid || !this._fragment || '#' == this._fragment ?
          '' : this._fragment;
    },
    set hash(hash) {
      if (this._isInvalid)
        return;
      this._fragment = '#';
      if ('#' == hash[0])
        hash = hash.slice(1);
      parse.call(this, hash, 'fragment');
    },

    get origin() {
      var host;
      if (this._isInvalid || !this._scheme) {
        return '';
      }
      // javascript: Gecko returns String(""), WebKit/Blink String("null")
      // Gecko throws error for "data://"
      // data: Gecko returns "", Blink returns "data://", WebKit returns "null"
      // Gecko returns String("") for file: mailto:
      // WebKit/Blink returns String("SCHEME://") for file: mailto:
      switch (this._scheme) {
        case 'data':
        case 'file':
        case 'javascript':
        case 'mailto':
          return 'null';
      }
      host = this.host;
      if (!host) {
        return '';
      }
      return this._scheme + '://' + host;
    }
  };

  // Copy over the static methods
  var OriginalURL = scope.URL;
  if (OriginalURL) {
    jURL.createObjectURL = function(blob) {
      // IE extension allows a second optional options argument.
      // http://msdn.microsoft.com/en-us/library/ie/hh772302(v=vs.85).aspx
      return OriginalURL.createObjectURL.apply(OriginalURL, arguments);
    };
    jURL.revokeObjectURL = function(url) {
      OriginalURL.revokeObjectURL(url);
    };
  }

  scope.URL = jURL;

})(this);

(function(scope) {

var iterations = 0;
var callbacks = [];
var twiddle = document.createTextNode('');

function endOfMicrotask(callback) {
  twiddle.textContent = iterations++;
  callbacks.push(callback);
}

function atEndOfMicrotask() {
  while (callbacks.length) {
    callbacks.shift()();
  }
}

new (window.MutationObserver || JsMutationObserver)(atEndOfMicrotask)
  .observe(twiddle, {characterData: true})
  ;

// exports
scope.endOfMicrotask = endOfMicrotask;
// bc 
Platform.endOfMicrotask = endOfMicrotask;

})(Polymer);


(function(scope) {

/**
 * @class Polymer
 */

// imports
var endOfMicrotask = scope.endOfMicrotask;

// logging
var log = window.WebComponents ? WebComponents.flags.log : {};

// inject style sheet
var style = document.createElement('style');
style.textContent = 'template {display: none !important;} /* injected by platform.js */';
var head = document.querySelector('head');
head.insertBefore(style, head.firstChild);


/**
 * Force any pending data changes to be observed before 
 * the next task. Data changes are processed asynchronously but are guaranteed
 * to be processed, for example, before paintin. This method should rarely be 
 * needed. It does nothing when Object.observe is available; 
 * when Object.observe is not available, Polymer automatically flushes data 
 * changes approximately every 1/10 second. 
 * Therefore, `flush` should only be used when a data mutation should be 
 * observed sooner than this.
 * 
 * @method flush
 */
// flush (with logging)
var flushing;
function flush() {
  if (!flushing) {
    flushing = true;
    endOfMicrotask(function() {
      flushing = false;
      log.data && console.group('flush');
      Platform.performMicrotaskCheckpoint();
      log.data && console.groupEnd();
    });
  }
};

// polling dirty checker
// flush periodically if platform does not have object observe.
if (!Observer.hasObjectObserve) {
  var FLUSH_POLL_INTERVAL = 125;
  window.addEventListener('WebComponentsReady', function() {
    flush();
    // watch document visiblity to toggle dirty-checking
    var visibilityHandler = function() {
      // only flush if the page is visibile
      if (document.visibilityState === 'hidden') {
        if (scope.flushPoll) {
          clearInterval(scope.flushPoll);
        }
      } else {
        scope.flushPoll = setInterval(flush, FLUSH_POLL_INTERVAL);
      }
    };
    if (typeof document.visibilityState === 'string') {
      document.addEventListener('visibilitychange', visibilityHandler);
    }
    visibilityHandler();
  });
} else {
  // make flush a no-op when we have Object.observe
  flush = function() {};
}

if (window.CustomElements && !CustomElements.useNative) {
  var originalImportNode = Document.prototype.importNode;
  Document.prototype.importNode = function(node, deep) {
    var imported = originalImportNode.call(this, node, deep);
    CustomElements.upgradeAll(imported);
    return imported;
  };
}

// exports
scope.flush = flush;
// bc
Platform.flush = flush;

})(window.Polymer);


(function(scope) {

var urlResolver = {
  resolveDom: function(root, url) {
    url = url || baseUrl(root);
    this.resolveAttributes(root, url);
    this.resolveStyles(root, url);
    // handle template.content
    var templates = root.querySelectorAll('template');
    if (templates) {
      for (var i = 0, l = templates.length, t; (i < l) && (t = templates[i]); i++) {
        if (t.content) {
          this.resolveDom(t.content, url);
        }
      }
    }
  },
  resolveTemplate: function(template) {
    this.resolveDom(template.content, baseUrl(template));
  },
  resolveStyles: function(root, url) {
    var styles = root.querySelectorAll('style');
    if (styles) {
      for (var i = 0, l = styles.length, s; (i < l) && (s = styles[i]); i++) {
        this.resolveStyle(s, url);
      }
    }
  },
  resolveStyle: function(style, url) {
    url = url || baseUrl(style);
    style.textContent = this.resolveCssText(style.textContent, url);
  },
  resolveCssText: function(cssText, baseUrl, keepAbsolute) {
    cssText = replaceUrlsInCssText(cssText, baseUrl, keepAbsolute, CSS_URL_REGEXP);
    return replaceUrlsInCssText(cssText, baseUrl, keepAbsolute, CSS_IMPORT_REGEXP);
  },
  resolveAttributes: function(root, url) {
    if (root.hasAttributes && root.hasAttributes()) {
      this.resolveElementAttributes(root, url);
    }
    // search for attributes that host urls
    var nodes = root && root.querySelectorAll(URL_ATTRS_SELECTOR);
    if (nodes) {
      for (var i = 0, l = nodes.length, n; (i < l) && (n = nodes[i]); i++) {
        this.resolveElementAttributes(n, url);
      }
    }
  },
  resolveElementAttributes: function(node, url) {
    url = url || baseUrl(node);
    URL_ATTRS.forEach(function(v) {
      var attr = node.attributes[v];
      var value = attr && attr.value;
      var replacement;
      if (value && value.search(URL_TEMPLATE_SEARCH) < 0) {
        if (v === 'style') {
          replacement = replaceUrlsInCssText(value, url, false, CSS_URL_REGEXP);
        } else {
          replacement = resolveRelativeUrl(url, value);
        }
        attr.value = replacement;
      }
    });
  }
};

var CSS_URL_REGEXP = /(url\()([^)]*)(\))/g;
var CSS_IMPORT_REGEXP = /(@import[\s]+(?!url\())([^;]*)(;)/g;
var URL_ATTRS = ['href', 'src', 'action', 'style', 'url'];
var URL_ATTRS_SELECTOR = '[' + URL_ATTRS.join('],[') + ']';
var URL_TEMPLATE_SEARCH = '{{.*}}';
var URL_HASH = '#';

function baseUrl(node) {
  var u = new URL(node.ownerDocument.baseURI);
  u.search = '';
  u.hash = '';
  return u;
}

function replaceUrlsInCssText(cssText, baseUrl, keepAbsolute, regexp) {
  return cssText.replace(regexp, function(m, pre, url, post) {
    var urlPath = url.replace(/["']/g, '');
    urlPath = resolveRelativeUrl(baseUrl, urlPath, keepAbsolute);
    return pre + '\'' + urlPath + '\'' + post;
  });
}

function resolveRelativeUrl(baseUrl, url, keepAbsolute) {
  // do not resolve '/' absolute urls
  if (url && url[0] === '/') {
    return url;
  }
  var u = new URL(url, baseUrl);
  return keepAbsolute ? u.href : makeDocumentRelPath(u.href);
}

function makeDocumentRelPath(url) {
  var root = baseUrl(document.documentElement);
  var u = new URL(url, root);
  if (u.host === root.host && u.port === root.port &&
      u.protocol === root.protocol) {
    return makeRelPath(root, u);
  } else {
    return url;
  }
}

// make a relative path from source to target
function makeRelPath(sourceUrl, targetUrl) {
  var source = sourceUrl.pathname;
  var target = targetUrl.pathname;
  var s = source.split('/');
  var t = target.split('/');
  while (s.length && s[0] === t[0]){
    s.shift();
    t.shift();
  }
  for (var i = 0, l = s.length - 1; i < l; i++) {
    t.unshift('..');
  }
  // empty '#' is discarded but we need to preserve it.
  var hash = (targetUrl.href.slice(-1) === URL_HASH) ? URL_HASH : targetUrl.hash;
  return t.join('/') + targetUrl.search + hash;
}

// exports
scope.urlResolver = urlResolver;

})(Polymer);

(function(scope) {
  var endOfMicrotask = Polymer.endOfMicrotask;

  // Generic url loader
  function Loader(regex) {
    this.cache = Object.create(null);
    this.map = Object.create(null);
    this.requests = 0;
    this.regex = regex;
  }
  Loader.prototype = {

    // TODO(dfreedm): there may be a better factoring here
    // extract absolute urls from the text (full of relative urls)
    extractUrls: function(text, base) {
      var matches = [];
      var matched, u;
      while ((matched = this.regex.exec(text))) {
        u = new URL(matched[1], base);
        matches.push({matched: matched[0], url: u.href});
      }
      return matches;
    },
    // take a text blob, a root url, and a callback and load all the urls found within the text
    // returns a map of absolute url to text
    process: function(text, root, callback) {
      var matches = this.extractUrls(text, root);

      // every call to process returns all the text this loader has ever received
      var done = callback.bind(null, this.map);
      this.fetch(matches, done);
    },
    // build a mapping of url -> text from matches
    fetch: function(matches, callback) {
      var inflight = matches.length;

      // return early if there is no fetching to be done
      if (!inflight) {
        return callback();
      }

      // wait for all subrequests to return
      var done = function() {
        if (--inflight === 0) {
          callback();
        }
      };

      // start fetching all subrequests
      var m, req, url;
      for (var i = 0; i < inflight; i++) {
        m = matches[i];
        url = m.url;
        req = this.cache[url];
        // if this url has already been requested, skip requesting it again
        if (!req) {
          req = this.xhr(url);
          req.match = m;
          this.cache[url] = req;
        }
        // wait for the request to process its subrequests
        req.wait(done);
      }
    },
    handleXhr: function(request) {
      var match = request.match;
      var url = match.url;

      // handle errors with an empty string
      var response = request.response || request.responseText || '';
      this.map[url] = response;
      this.fetch(this.extractUrls(response, url), request.resolve);
    },
    xhr: function(url) {
      this.requests++;
      var request = new XMLHttpRequest();
      request.open('GET', url, true);
      request.send();
      request.onerror = request.onload = this.handleXhr.bind(this, request);

      // queue of tasks to run after XHR returns
      request.pending = [];
      request.resolve = function() {
        var pending = request.pending;
        for(var i = 0; i < pending.length; i++) {
          pending[i]();
        }
        request.pending = null;
      };

      // if we have already resolved, pending is null, async call the callback
      request.wait = function(fn) {
        if (request.pending) {
          request.pending.push(fn);
        } else {
          endOfMicrotask(fn);
        }
      };

      return request;
    }
  };

  scope.Loader = Loader;
})(Polymer);

(function(scope) {

var urlResolver = scope.urlResolver;
var Loader = scope.Loader;

function StyleResolver() {
  this.loader = new Loader(this.regex);
}
StyleResolver.prototype = {
  regex: /@import\s+(?:url)?["'\(]*([^'"\)]*)['"\)]*;/g,
  // Recursively replace @imports with the text at that url
  resolve: function(text, url, callback) {
    var done = function(map) {
      callback(this.flatten(text, url, map));
    }.bind(this);
    this.loader.process(text, url, done);
  },
  // resolve the textContent of a style node
  resolveNode: function(style, url, callback) {
    var text = style.textContent;
    var done = function(text) {
      style.textContent = text;
      callback(style);
    };
    this.resolve(text, url, done);
  },
  // flatten all the @imports to text
  flatten: function(text, base, map) {
    var matches = this.loader.extractUrls(text, base);
    var match, url, intermediate;
    for (var i = 0; i < matches.length; i++) {
      match = matches[i];
      url = match.url;
      // resolve any css text to be relative to the importer, keep absolute url
      intermediate = urlResolver.resolveCssText(map[url], url, true);
      // flatten intermediate @imports
      intermediate = this.flatten(intermediate, base, map);
      text = text.replace(match.matched, intermediate);
    }
    return text;
  },
  loadStyles: function(styles, base, callback) {
    var loaded=0, l = styles.length;
    // called in the context of the style
    function loadedStyle(style) {
      loaded++;
      if (loaded === l && callback) {
        callback();
      }
    }
    for (var i=0, s; (i<l) && (s=styles[i]); i++) {
      this.resolveNode(s, base, loadedStyle);
    }
  }
};

var styleResolver = new StyleResolver();

// exports
scope.styleResolver = styleResolver;

})(Polymer);

(function(scope) {

  // copy own properties from 'api' to 'prototype, with name hinting for 'super'
  function extend(prototype, api) {
    if (prototype && api) {
      // use only own properties of 'api'
      Object.getOwnPropertyNames(api).forEach(function(n) {
        // acquire property descriptor
        var pd = Object.getOwnPropertyDescriptor(api, n);
        if (pd) {
          // clone property via descriptor
          Object.defineProperty(prototype, n, pd);
          // cache name-of-method for 'super' engine
          if (typeof pd.value == 'function') {
            // hint the 'super' engine
            pd.value.nom = n;
          }
        }
      });
    }
    return prototype;
  }


  // mixin

  // copy all properties from inProps (et al) to inObj
  function mixin(inObj/*, inProps, inMoreProps, ...*/) {
    var obj = inObj || {};
    for (var i = 1; i < arguments.length; i++) {
      var p = arguments[i];
      try {
        for (var n in p) {
          copyProperty(n, p, obj);
        }
      } catch(x) {
      }
    }
    return obj;
  }

  // copy property inName from inSource object to inTarget object
  function copyProperty(inName, inSource, inTarget) {
    var pd = getPropertyDescriptor(inSource, inName);
    Object.defineProperty(inTarget, inName, pd);
  }

  // get property descriptor for inName on inObject, even if
  // inName exists on some link in inObject's prototype chain
  function getPropertyDescriptor(inObject, inName) {
    if (inObject) {
      var pd = Object.getOwnPropertyDescriptor(inObject, inName);
      return pd || getPropertyDescriptor(Object.getPrototypeOf(inObject), inName);
    }
  }

  // exports

  scope.extend = extend;
  scope.mixin = mixin;

  // for bc
  Platform.mixin = mixin;

})(Polymer);

(function(scope) {
  
  // usage
  
  // invoke cb.call(this) in 100ms, unless the job is re-registered,
  // which resets the timer
  // 
  // this.myJob = this.job(this.myJob, cb, 100)
  //
  // returns a job handle which can be used to re-register a job

  var Job = function(inContext) {
    this.context = inContext;
    this.boundComplete = this.complete.bind(this)
  };
  Job.prototype = {
    go: function(callback, wait) {
      this.callback = callback;
      var h;
      if (!wait) {
        h = requestAnimationFrame(this.boundComplete);
        this.handle = function() {
          cancelAnimationFrame(h);
        }
      } else {
        h = setTimeout(this.boundComplete, wait);
        this.handle = function() {
          clearTimeout(h);
        }
      }
    },
    stop: function() {
      if (this.handle) {
        this.handle();
        this.handle = null;
      }
    },
    complete: function() {
      if (this.handle) {
        this.stop();
        this.callback.call(this.context);
      }
    }
  };
  
  function job(job, callback, wait) {
    if (job) {
      job.stop();
    } else {
      job = new Job(this);
    }
    job.go(callback, wait);
    return job;
  }
  
  // exports 

  scope.job = job;
  
})(Polymer);

(function(scope) {

  // dom polyfill, additions, and utility methods

  var registry = {};

  HTMLElement.register = function(tag, prototype) {
    registry[tag] = prototype;
  };

  // get prototype mapped to node <tag>
  HTMLElement.getPrototypeForTag = function(tag) {
    var prototype = !tag ? HTMLElement.prototype : registry[tag];
    // TODO(sjmiles): creating <tag> is likely to have wasteful side-effects
    return prototype || Object.getPrototypeOf(document.createElement(tag));
  };

  // we have to flag propagation stoppage for the event dispatcher
  var originalStopPropagation = Event.prototype.stopPropagation;
  Event.prototype.stopPropagation = function() {
    this.cancelBubble = true;
    originalStopPropagation.apply(this, arguments);
  };
  
  
  // polyfill DOMTokenList
  // * add/remove: allow these methods to take multiple classNames
  // * toggle: add a 2nd argument which forces the given state rather
  //  than toggling.

  var add = DOMTokenList.prototype.add;
  var remove = DOMTokenList.prototype.remove;
  DOMTokenList.prototype.add = function() {
    for (var i = 0; i < arguments.length; i++) {
      add.call(this, arguments[i]);
    }
  };
  DOMTokenList.prototype.remove = function() {
    for (var i = 0; i < arguments.length; i++) {
      remove.call(this, arguments[i]);
    }
  };
  DOMTokenList.prototype.toggle = function(name, bool) {
    if (arguments.length == 1) {
      bool = !this.contains(name);
    }
    bool ? this.add(name) : this.remove(name);
  };
  DOMTokenList.prototype.switch = function(oldName, newName) {
    oldName && this.remove(oldName);
    newName && this.add(newName);
  };

  // add array() to NodeList, NamedNodeMap, HTMLCollection

  var ArraySlice = function() {
    return Array.prototype.slice.call(this);
  };

  var namedNodeMap = (window.NamedNodeMap || window.MozNamedAttrMap || {});

  NodeList.prototype.array = ArraySlice;
  namedNodeMap.prototype.array = ArraySlice;
  HTMLCollection.prototype.array = ArraySlice;

  // utility

  function createDOM(inTagOrNode, inHTML, inAttrs) {
    var dom = typeof inTagOrNode == 'string' ?
        document.createElement(inTagOrNode) : inTagOrNode.cloneNode(true);
    dom.innerHTML = inHTML;
    if (inAttrs) {
      for (var n in inAttrs) {
        dom.setAttribute(n, inAttrs[n]);
      }
    }
    return dom;
  }

  // exports

  scope.createDOM = createDOM;

})(Polymer);

(function(scope) {
    // super

    // `arrayOfArgs` is an optional array of args like one might pass
    // to `Function.apply`

    // TODO(sjmiles):
    //    $super must be installed on an instance or prototype chain
    //    as `super`, and invoked via `this`, e.g.
    //      `this.super();`

    //    will not work if function objects are not unique, for example,
    //    when using mixins.
    //    The memoization strategy assumes each function exists on only one 
    //    prototype chain i.e. we use the function object for memoizing)
    //    perhaps we can bookkeep on the prototype itself instead
    function $super(arrayOfArgs) {
      // since we are thunking a method call, performance is important here: 
      // memoize all lookups, once memoized the fast path calls no other 
      // functions
      //
      // find the caller (cannot be `strict` because of 'caller')
      var caller = $super.caller;
      // memoized 'name of method' 
      var nom = caller.nom;
      // memoized next implementation prototype
      var _super = caller._super;
      if (!_super) {
        if (!nom) {
          nom = caller.nom = nameInThis.call(this, caller);
        }
        if (!nom) {
          console.warn('called super() on a method not installed declaratively (has no .nom property)');
        }
        // super prototype is either cached or we have to find it
        // by searching __proto__ (at the 'top')
        // invariant: because we cache _super on fn below, we never reach 
        // here from inside a series of calls to super(), so it's ok to 
        // start searching from the prototype of 'this' (at the 'top')
        // we must never memoize a null super for this reason
        _super = memoizeSuper(caller, nom, getPrototypeOf(this));
      }
      // our super function
      var fn = _super[nom];
      if (fn) {
        // memoize information so 'fn' can call 'super'
        if (!fn._super) {
          // must not memoize null, or we lose our invariant above
          memoizeSuper(fn, nom, _super);
        }
        // invoke the inherited method
        // if 'fn' is not function valued, this will throw
        return fn.apply(this, arrayOfArgs || []);
      }
    }

    function nameInThis(value) {
      var p = this.__proto__;
      while (p && p !== HTMLElement.prototype) {
        // TODO(sjmiles): getOwnPropertyNames is absurdly expensive
        var n$ = Object.getOwnPropertyNames(p);
        for (var i=0, l=n$.length, n; i<l && (n=n$[i]); i++) {
          var d = Object.getOwnPropertyDescriptor(p, n);
          if (typeof d.value === 'function' && d.value === value) {
            return n;
          }
        }
        p = p.__proto__;
      }
    }

    function memoizeSuper(method, name, proto) {
      // find and cache next prototype containing `name`
      // we need the prototype so we can do another lookup
      // from here
      var s = nextSuper(proto, name, method);
      if (s[name]) {
        // `s` is a prototype, the actual method is `s[name]`
        // tag super method with it's name for quicker lookups
        s[name].nom = name;
      }
      return method._super = s;
    }

    function nextSuper(proto, name, caller) {
      // look for an inherited prototype that implements name
      while (proto) {
        if ((proto[name] !== caller) && proto[name]) {
          return proto;
        }
        proto = getPrototypeOf(proto);
      }
      // must not return null, or we lose our invariant above
      // in this case, a super() call was invoked where no superclass
      // method exists
      // TODO(sjmiles): thow an exception?
      return Object;
    }

    // NOTE: In some platforms (IE10) the prototype chain is faked via 
    // __proto__. Therefore, always get prototype via __proto__ instead of
    // the more standard Object.getPrototypeOf.
    function getPrototypeOf(prototype) {
      return prototype.__proto__;
    }

    // utility function to precompute name tags for functions
    // in a (unchained) prototype
    function hintSuper(prototype) {
      // tag functions with their prototype name to optimize
      // super call invocations
      for (var n in prototype) {
        var pd = Object.getOwnPropertyDescriptor(prototype, n);
        if (pd && typeof pd.value === 'function') {
          pd.value.nom = n;
        }
      }
    }

    // exports

    scope.super = $super;

})(Polymer);

(function(scope) {

  function noopHandler(value) {
    return value;
  }

  // helper for deserializing properties of various types to strings
  var typeHandlers = {
    string: noopHandler,
    'undefined': noopHandler,
    date: function(value) {
      return new Date(Date.parse(value) || Date.now());
    },
    boolean: function(value) {
      if (value === '') {
        return true;
      }
      return value === 'false' ? false : !!value;
    },
    number: function(value) {
      var n = parseFloat(value);
      // hex values like "0xFFFF" parseFloat as 0
      if (n === 0) {
        n = parseInt(value);
      }
      return isNaN(n) ? value : n;
      // this code disabled because encoded values (like "0xFFFF")
      // do not round trip to their original format
      //return (String(floatVal) === value) ? floatVal : value;
    },
    object: function(value, currentValue) {
      if (currentValue === null) {
        return value;
      }
      try {
        // If the string is an object, we can parse is with the JSON library.
        // include convenience replace for single-quotes. If the author omits
        // quotes altogether, parse will fail.
        return JSON.parse(value.replace(/'/g, '"'));
      } catch(e) {
        // The object isn't valid JSON, return the raw value
        return value;
      }
    },
    // avoid deserialization of functions
    'function': function(value, currentValue) {
      return currentValue;
    }
  };

  function deserializeValue(value, currentValue) {
    // attempt to infer type from default value
    var inferredType = typeof currentValue;
    // invent 'date' type value for Date
    if (currentValue instanceof Date) {
      inferredType = 'date';
    }
    // delegate deserialization via type string
    return typeHandlers[inferredType](value, currentValue);
  }

  // exports

  scope.deserializeValue = deserializeValue;

})(Polymer);

(function(scope) {

  // imports

  var extend = scope.extend;

  // module

  var api = {};

  api.declaration = {};
  api.instance = {};

  api.publish = function(apis, prototype) {
    for (var n in apis) {
      extend(prototype, apis[n]);
    }
  };

  // exports

  scope.api = api;

})(Polymer);

(function(scope) {

  /**
   * @class polymer-base
   */

  var utils = {

    /**
      * Invokes a function asynchronously. The context of the callback
      * function is bound to 'this' automatically. Returns a handle which may 
      * be passed to <a href="#cancelAsync">cancelAsync</a> to cancel the 
      * asynchronous call.
      *
      * @method async
      * @param {Function|String} method
      * @param {any|Array} args
      * @param {number} timeout
      */
    async: function(method, args, timeout) {
      // when polyfilling Object.observe, ensure changes 
      // propagate before executing the async method
      Polymer.flush();
      // second argument to `apply` must be an array
      args = (args && args.length) ? args : [args];
      // function to invoke
      var fn = function() {
        (this[method] || method).apply(this, args);
      }.bind(this);
      // execute `fn` sooner or later
      var handle = timeout ? setTimeout(fn, timeout) :
          requestAnimationFrame(fn);
      // NOTE: switch on inverting handle to determine which time is used.
      return timeout ? handle : ~handle;
    },

    /**
      * Cancels a pending callback that was scheduled via 
      * <a href="#async">async</a>. 
      *
      * @method cancelAsync
      * @param {handle} handle Handle of the `async` to cancel.
      */
    cancelAsync: function(handle) {
      if (handle < 0) {
        cancelAnimationFrame(~handle);
      } else {
        clearTimeout(handle);
      }
    },

    /**
      * Fire an event.
      *
      * @method fire
      * @returns {Object} event
      * @param {string} type An event name.
      * @param {any} detail
      * @param {Node} onNode Target node.
      * @param {Boolean} bubbles Set false to prevent bubbling, defaults to true
      * @param {Boolean} cancelable Set false to prevent cancellation, defaults to true
      */
    fire: function(type, detail, onNode, bubbles, cancelable) {
      var node = onNode || this;
      var detail = detail === null || detail === undefined ? {} : detail;
      var event = new CustomEvent(type, {
        bubbles: bubbles !== undefined ? bubbles : true,
        cancelable: cancelable !== undefined ? cancelable : true,
        detail: detail
      });
      node.dispatchEvent(event);
      return event;
    },

    /**
      * Fire an event asynchronously.
      *
      * @method asyncFire
      * @param {string} type An event name.
      * @param detail
      * @param {Node} toNode Target node.
      */
    asyncFire: function(/*inType, inDetail*/) {
      this.async("fire", arguments);
    },

    /**
      * Remove class from old, add class to anew, if they exist.
      *
      * @param classFollows
      * @param anew A node.
      * @param old A node
      * @param className
      */
    classFollows: function(anew, old, className) {
      if (old) {
        old.classList.remove(className);
      }
      if (anew) {
        anew.classList.add(className);
      }
    },

    /**
      * Inject HTML which contains markup bound to this element into
      * a target element (replacing target element content).
      *
      * @param String html to inject
      * @param Element target element
      */
    injectBoundHTML: function(html, element) {
      var template = document.createElement('template');
      template.innerHTML = html;
      var fragment = this.instanceTemplate(template);
      if (element) {
        element.textContent = '';
        element.appendChild(fragment);
      }
      return fragment;
    }
  };

  // no-operation function for handy stubs
  var nop = function() {};

  // null-object for handy stubs
  var nob = {};

  // deprecated

  utils.asyncMethod = utils.async;

  // exports

  scope.api.instance.utils = utils;
  scope.nop = nop;
  scope.nob = nob;

})(Polymer);

(function(scope) {

  // imports

  var log = window.WebComponents ? WebComponents.flags.log : {};
  var EVENT_PREFIX = 'on-';

  // instance events api
  var events = {
    // read-only
    EVENT_PREFIX: EVENT_PREFIX,
    // event listeners on host
    addHostListeners: function() {
      var events = this.eventDelegates;
      log.events && (Object.keys(events).length > 0) && console.log('[%s] addHostListeners:', this.localName, events);
      // NOTE: host events look like bindings but really are not;
      // (1) we don't want the attribute to be set and (2) we want to support
      // multiple event listeners ('host' and 'instance') and Node.bind
      // by default supports 1 thing being bound.
      for (var type in events) {
        var methodName = events[type];
        PolymerGestures.addEventListener(this, type, this.element.getEventHandler(this, this, methodName));
      }
    },
    // call 'method' or function method on 'obj' with 'args', if the method exists
    dispatchMethod: function(obj, method, args) {
      if (obj) {
        log.events && console.group('[%s] dispatch [%s]', obj.localName, method);
        var fn = typeof method === 'function' ? method : obj[method];
        if (fn) {
          fn[args ? 'apply' : 'call'](obj, args);
        }
        log.events && console.groupEnd();
        // NOTE: dirty check right after calling method to ensure 
        // changes apply quickly; in a very complicated app using high 
        // frequency events, this can be a perf concern; in this case,
        // imperative handlers can be used to avoid flushing.
        Polymer.flush();
      }
    }
  };

  // exports

  scope.api.instance.events = events;

  /**
   * @class Polymer
   */

  /**
   * Add a gesture aware event handler to the given `node`. Can be used 
   * in place of `element.addEventListener` and ensures gestures will function
   * as expected on mobile platforms. Please note that Polymer's declarative
   * event handlers include this functionality by default.
   * 
   * @method addEventListener
   * @param {Node} node node on which to listen
   * @param {String} eventType name of the event
   * @param {Function} handlerFn event handler function
   * @param {Boolean} capture set to true to invoke event capturing
   * @type Function
   */
  // alias PolymerGestures event listener logic
  scope.addEventListener = function(node, eventType, handlerFn, capture) {
    PolymerGestures.addEventListener(wrap(node), eventType, handlerFn, capture);
  };

  /**
   * Remove a gesture aware event handler on the given `node`. To remove an
   * event listener, the exact same arguments are required that were passed
   * to `Polymer.addEventListener`.
   * 
   * @method removeEventListener
   * @param {Node} node node on which to listen
   * @param {String} eventType name of the event
   * @param {Function} handlerFn event handler function
   * @param {Boolean} capture set to true to invoke event capturing
   * @type Function
   */
  scope.removeEventListener = function(node, eventType, handlerFn, capture) {
    PolymerGestures.removeEventListener(wrap(node), eventType, handlerFn, capture);
  };

})(Polymer);

(function(scope) {

  // instance api for attributes

  var attributes = {
    // copy attributes defined in the element declaration to the instance
    // e.g. <polymer-element name="x-foo" tabIndex="0"> tabIndex is copied
    // to the element instance here.
    copyInstanceAttributes: function () {
      var a$ = this._instanceAttributes;
      for (var k in a$) {
        if (!this.hasAttribute(k)) {
          this.setAttribute(k, a$[k]);
        }
      }
    },
    // for each attribute on this, deserialize value to property as needed
    takeAttributes: function() {
      // if we have no publish lookup table, we have no attributes to take
      // TODO(sjmiles): ad hoc
      if (this._publishLC) {
        for (var i=0, a$=this.attributes, l=a$.length, a; (a=a$[i]) && i<l; i++) {
          this.attributeToProperty(a.name, a.value);
        }
      }
    },
    // if attribute 'name' is mapped to a property, deserialize
    // 'value' into that property
    attributeToProperty: function(name, value) {
      // try to match this attribute to a property (attributes are
      // all lower-case, so this is case-insensitive search)
      var name = this.propertyForAttribute(name);
      if (name) {
        // filter out 'mustached' values, these are to be
        // replaced with bound-data and are not yet values
        // themselves
        if (value && value.search(scope.bindPattern) >= 0) {
          return;
        }
        // get original value
        var currentValue = this[name];
        // deserialize Boolean or Number values from attribute
        var value = this.deserializeValue(value, currentValue);
        // only act if the value has changed
        if (value !== currentValue) {
          // install new value (has side-effects)
          this[name] = value;
        }
      }
    },
    // return the published property matching name, or undefined
    propertyForAttribute: function(name) {
      var match = this._publishLC && this._publishLC[name];
      return match;
    },
    // convert representation of `stringValue` based on type of `currentValue`
    deserializeValue: function(stringValue, currentValue) {
      return scope.deserializeValue(stringValue, currentValue);
    },
    // convert to a string value based on the type of `inferredType`
    serializeValue: function(value, inferredType) {
      if (inferredType === 'boolean') {
        return value ? '' : undefined;
      } else if (inferredType !== 'object' && inferredType !== 'function'
          && value !== undefined) {
        return value;
      }
    },
    // serializes `name` property value and updates the corresponding attribute
    // note that reflection is opt-in.
    reflectPropertyToAttribute: function(name) {
      var inferredType = typeof this[name];
      // try to intelligently serialize property value
      var serializedValue = this.serializeValue(this[name], inferredType);
      // boolean properties must reflect as boolean attributes
      if (serializedValue !== undefined) {
        this.setAttribute(name, serializedValue);
        // TODO(sorvell): we should remove attr for all properties
        // that have undefined serialization; however, we will need to
        // refine the attr reflection system to achieve this; pica, for example,
        // relies on having inferredType object properties not removed as
        // attrs.
      } else if (inferredType === 'boolean') {
        this.removeAttribute(name);
      }
    }
  };

  // exports

  scope.api.instance.attributes = attributes;

})(Polymer);

(function(scope) {

  /**
   * @class polymer-base
   */

  // imports

  var log = window.WebComponents ? WebComponents.flags.log : {};

  // magic words

  var OBSERVE_SUFFIX = 'Changed';

  // element api

  var empty = [];

  var updateRecord = {
    object: undefined,
    type: 'update',
    name: undefined,
    oldValue: undefined
  };

  var numberIsNaN = Number.isNaN || function(value) {
    return typeof value === 'number' && isNaN(value);
  };

  function areSameValue(left, right) {
    if (left === right)
      return left !== 0 || 1 / left === 1 / right;
    if (numberIsNaN(left) && numberIsNaN(right))
      return true;
    return left !== left && right !== right;
  }

  // capture A's value if B's value is null or undefined,
  // otherwise use B's value
  function resolveBindingValue(oldValue, value) {
    if (value === undefined && oldValue === null) {
      return value;
    }
    return (value === null || value === undefined) ? oldValue : value;
  }

  var properties = {

    // creates a CompoundObserver to observe property changes
    // NOTE, this is only done there are any properties in the `observe` object
    createPropertyObserver: function() {
      var n$ = this._observeNames;
      if (n$ && n$.length) {
        var o = this._propertyObserver = new CompoundObserver(true);
        this.registerObserver(o);
        // TODO(sorvell): may not be kosher to access the value here (this[n]);
        // previously we looked at the descriptor on the prototype
        // this doesn't work for inheritance and not for accessors without
        // a value property
        for (var i=0, l=n$.length, n; (i<l) && (n=n$[i]); i++) {
          o.addPath(this, n);
          this.observeArrayValue(n, this[n], null);
        }
      }
    },

    // start observing property changes
    openPropertyObserver: function() {
      if (this._propertyObserver) {
        this._propertyObserver.open(this.notifyPropertyChanges, this);
      }
    },

    // handler for property changes; routes changes to observing methods
    // note: array valued properties are observed for array splices
    notifyPropertyChanges: function(newValues, oldValues, paths) {
      var name, method, called = {};
      for (var i in oldValues) {
        // note: paths is of form [object, path, object, path]
        name = paths[2 * i + 1];
        method = this.observe[name];
        if (method) {
          var ov = oldValues[i], nv = newValues[i];
          // observes the value if it is an array
          this.observeArrayValue(name, nv, ov);
          if (!called[method]) {
            // only invoke change method if one of ov or nv is not (undefined | null)
            if ((ov !== undefined && ov !== null) || (nv !== undefined && nv !== null)) {
              called[method] = true;
              // TODO(sorvell): call method with the set of values it's expecting;
              // e.g. 'foo bar': 'invalidate' expects the new and old values for
              // foo and bar. Currently we give only one of these and then
              // deliver all the arguments.
              this.invokeMethod(method, [ov, nv, arguments]);
            }
          }
        }
      }
    },

    // call method iff it exists.
    invokeMethod: function(method, args) {
      var fn = this[method] || method;
      if (typeof fn === 'function') {
        fn.apply(this, args);
      }
    },

    /**
     * Force any pending property changes to synchronously deliver to
     * handlers specified in the `observe` object.
     * Note, normally changes are processed at microtask time.
     *
     * @method deliverChanges
     */
    deliverChanges: function() {
      if (this._propertyObserver) {
        this._propertyObserver.deliver();
      }
    },

    observeArrayValue: function(name, value, old) {
      // we only care if there are registered side-effects
      var callbackName = this.observe[name];
      if (callbackName) {
        // if we are observing the previous value, stop
        if (Array.isArray(old)) {
          log.observe && console.log('[%s] observeArrayValue: unregister observer [%s]', this.localName, name);
          this.closeNamedObserver(name + '__array');
        }
        // if the new value is an array, being observing it
        if (Array.isArray(value)) {
          log.observe && console.log('[%s] observeArrayValue: register observer [%s]', this.localName, name, value);
          var observer = new ArrayObserver(value);
          observer.open(function(splices) {
            this.invokeMethod(callbackName, [splices]);
          }, this);
          this.registerNamedObserver(name + '__array', observer);
        }
      }
    },

    emitPropertyChangeRecord: function(name, value, oldValue) {
      var object = this;
      if (areSameValue(value, oldValue)) {
        return;
      }
      // invoke property change side effects
      this._propertyChanged(name, value, oldValue);
      // emit change record
      if (!Observer.hasObjectObserve) {
        return;
      }
      var notifier = this._objectNotifier;
      if (!notifier) {
        notifier = this._objectNotifier = Object.getNotifier(this);
      }
      updateRecord.object = this;
      updateRecord.name = name;
      updateRecord.oldValue = oldValue;
      notifier.notify(updateRecord);
    },

    _propertyChanged: function(name, value, oldValue) {
      if (this.reflect[name]) {
        this.reflectPropertyToAttribute(name);
      }
    },

    // creates a property binding (called via bind) to a published property.
    bindProperty: function(property, observable, oneTime) {
      if (oneTime) {
        this[property] = observable;
        return;
      }
      var computed = this.element.prototype.computed;
      // Binding an "out-only" value to a computed property. Note that
      // since this observer isn't opened, it doesn't need to be closed on
      // cleanup.
      if (computed && computed[property]) {
        var privateComputedBoundValue = property + 'ComputedBoundObservable_';
        this[privateComputedBoundValue] = observable;
        return;
      }
      return this.bindToAccessor(property, observable, resolveBindingValue);
    },

    // NOTE property `name` must be published. This makes it an accessor.
    bindToAccessor: function(name, observable, resolveFn) {
      var privateName = name + '_';
      var privateObservable  = name + 'Observable_';
      // Present for properties which are computed and published and have a
      // bound value.
      var privateComputedBoundValue = name + 'ComputedBoundObservable_';
      this[privateObservable] = observable;
      var oldValue = this[privateName];
      // observable callback
      var self = this;
      function updateValue(value, oldValue) {
        self[privateName] = value;
        var setObserveable = self[privateComputedBoundValue];
        if (setObserveable && typeof setObserveable.setValue == 'function') {
          setObserveable.setValue(value);
        }
        self.emitPropertyChangeRecord(name, value, oldValue);
      }
      // resolve initial value
      var value = observable.open(updateValue);
      if (resolveFn && !areSameValue(oldValue, value)) {
        var resolvedValue = resolveFn(oldValue, value);
        if (!areSameValue(value, resolvedValue)) {
          value = resolvedValue;
          if (observable.setValue) {
            observable.setValue(value);
          }
        }
      }
      updateValue(value, oldValue);
      // register and return observable
      var observer = {
        close: function() {
          observable.close();
          self[privateObservable] = undefined;
          self[privateComputedBoundValue] = undefined;
        }
      };
      this.registerObserver(observer);
      return observer;
    },

    createComputedProperties: function() {
      if (!this._computedNames) {
        return;
      }
      for (var i = 0; i < this._computedNames.length; i++) {
        var name = this._computedNames[i];
        var expressionText = this.computed[name];
        try {
          var expression = PolymerExpressions.getExpression(expressionText);
          var observable = expression.getBinding(this, this.element.syntax);
          this.bindToAccessor(name, observable);
        } catch (ex) {
          console.error('Failed to create computed property', ex);
        }
      }
    },

    // property bookkeeping
    registerObserver: function(observer) {
      if (!this._observers) {
        this._observers = [observer];
        return;
      }
      this._observers.push(observer);
    },

    closeObservers: function() {
      if (!this._observers) {
        return;
      }
      // observer array items are arrays of observers.
      var observers = this._observers;
      for (var i = 0; i < observers.length; i++) {
        var observer = observers[i];
        if (observer && typeof observer.close == 'function') {
          observer.close();
        }
      }
      this._observers = [];
    },

    // bookkeeping observers for memory management
    registerNamedObserver: function(name, observer) {
      var o$ = this._namedObservers || (this._namedObservers = {});
      o$[name] = observer;
    },

    closeNamedObserver: function(name) {
      var o$ = this._namedObservers;
      if (o$ && o$[name]) {
        o$[name].close();
        o$[name] = null;
        return true;
      }
    },

    closeNamedObservers: function() {
      if (this._namedObservers) {
        for (var i in this._namedObservers) {
          this.closeNamedObserver(i);
        }
        this._namedObservers = {};
      }
    }

  };

  // logging
  var LOG_OBSERVE = '[%s] watching [%s]';
  var LOG_OBSERVED = '[%s#%s] watch: [%s] now [%s] was [%s]';
  var LOG_CHANGED = '[%s#%s] propertyChanged: [%s] now [%s] was [%s]';

  // exports

  scope.api.instance.properties = properties;

})(Polymer);

(function(scope) {

  /**
   * @class polymer-base
   */

  // imports

  var log = window.WebComponents ? WebComponents.flags.log : {};

  // element api supporting mdv
  var mdv = {

    /**
     * Creates dom cloned from the given template, instantiating bindings
     * with this element as the template model and `PolymerExpressions` as the
     * binding delegate.
     *
     * @method instanceTemplate
     * @param {Template} template source template from which to create dom.
     */
    instanceTemplate: function(template) {
      // ensure template is decorated (lets' things like <tr template ...> work)
      HTMLTemplateElement.decorate(template);
      // ensure a default bindingDelegate
      var syntax = this.syntax || (!template.bindingDelegate &&
          this.element.syntax);
      var dom = template.createInstance(this, syntax);
      var observers = dom.bindings_;
      for (var i = 0; i < observers.length; i++) {
        this.registerObserver(observers[i]);
      }
      return dom;
    },

    // Called by TemplateBinding/NodeBind to setup a binding to the given
    // property. It's overridden here to support property bindings
    // in addition to attribute bindings that are supported by default.
    bind: function(name, observable, oneTime) {
      var property = this.propertyForAttribute(name);
      if (!property) {
        // TODO(sjmiles): this mixin method must use the special form
        // of `super` installed by `mixinMethod` in declaration/prototype.js
        return this.mixinSuper(arguments);
      } else {
        // use n-way Polymer binding
        var observer = this.bindProperty(property, observable, oneTime);
        // NOTE: reflecting binding information is typically required only for
        // tooling. It has a performance cost so it's opt-in in Node.bind.
        if (Platform.enableBindingsReflection && observer) {
          observer.path = observable.path_;
          this._recordBinding(property, observer);
        }
        if (this.reflect[property]) {
          this.reflectPropertyToAttribute(property);
        }
        return observer;
      }
    },

    _recordBinding: function(name, observer) {
      this.bindings_ = this.bindings_ || {};
      this.bindings_[name] = observer;
    },

    // Called by TemplateBinding when all bindings on an element have been 
    // executed. This signals that all element inputs have been gathered
    // and it's safe to ready the element, create shadow-root and start
    // data-observation.
    bindFinished: function() {
      this.makeElementReady();
    },

    // called at detached time to signal that an element's bindings should be
    // cleaned up. This is done asynchronously so that users have the chance
    // to call `cancelUnbindAll` to prevent unbinding.
    asyncUnbindAll: function() {
      if (!this._unbound) {
        log.unbind && console.log('[%s] asyncUnbindAll', this.localName);
        this._unbindAllJob = this.job(this._unbindAllJob, this.unbindAll, 0);
      }
    },
    
    /**
     * This method should rarely be used and only if 
     * <a href="#cancelUnbindAll">`cancelUnbindAll`</a> has been called to 
     * prevent element unbinding. In this case, the element's bindings will 
     * not be automatically cleaned up and it cannot be garbage collected 
     * by the system. If memory pressure is a concern or a 
     * large amount of elements need to be managed in this way, `unbindAll`
     * can be called to deactivate the element's bindings and allow its 
     * memory to be reclaimed.
     *
     * @method unbindAll
     */
    unbindAll: function() {
      if (!this._unbound) {
        this.closeObservers();
        this.closeNamedObservers();
        this._unbound = true;
      }
    },

    /**
     * Call in `detached` to prevent the element from unbinding when it is 
     * detached from the dom. The element is unbound as a cleanup step that 
     * allows its memory to be reclaimed. 
     * If `cancelUnbindAll` is used, consider calling 
     * <a href="#unbindAll">`unbindAll`</a> when the element is no longer
     * needed. This will allow its memory to be reclaimed.
     * 
     * @method cancelUnbindAll
     */
    cancelUnbindAll: function() {
      if (this._unbound) {
        log.unbind && console.warn('[%s] already unbound, cannot cancel unbindAll', this.localName);
        return;
      }
      log.unbind && console.log('[%s] cancelUnbindAll', this.localName);
      if (this._unbindAllJob) {
        this._unbindAllJob = this._unbindAllJob.stop();
      }
    }

  };

  function unbindNodeTree(node) {
    forNodeTree(node, _nodeUnbindAll);
  }

  function _nodeUnbindAll(node) {
    node.unbindAll();
  }

  function forNodeTree(node, callback) {
    if (node) {
      callback(node);
      for (var child = node.firstChild; child; child = child.nextSibling) {
        forNodeTree(child, callback);
      }
    }
  }

  var mustachePattern = /\{\{([^{}]*)}}/;

  // exports

  scope.bindPattern = mustachePattern;
  scope.api.instance.mdv = mdv;

})(Polymer);

(function(scope) {

  /**
   * Common prototype for all Polymer Elements.
   * 
   * @class polymer-base
   * @homepage polymer.github.io
   */
  var base = {
    /**
     * Tags this object as the canonical Base prototype.
     *
     * @property PolymerBase
     * @type boolean
     * @default true
     */
    PolymerBase: true,

    /**
     * Debounce signals. 
     * 
     * Call `job` to defer a named signal, and all subsequent matching signals, 
     * until a wait time has elapsed with no new signal.
     * 
     *     debouncedClickAction: function(e) {
     *       // processClick only when it's been 100ms since the last click
     *       this.job('click', function() {
     *        this.processClick;
     *       }, 100);
     *     }
     *
     * @method job
     * @param String {String} job A string identifier for the job to debounce.
     * @param Function {Function} callback A function that is called (with `this` context) when the wait time elapses.
     * @param Number {Number} wait Time in milliseconds (ms) after the last signal that must elapse before invoking `callback`
     * @type Handle
     */
    job: function(job, callback, wait) {
      if (typeof job === 'string') {
        var n = '___' + job;
        this[n] = Polymer.job.call(this, this[n], callback, wait);
      } else {
        // TODO(sjmiles): suggest we deprecate this call signature
        return Polymer.job.call(this, job, callback, wait);
      }
    },

    /**
     * Invoke a superclass method. 
     * 
     * Use `super()` to invoke the most recently overridden call to the 
     * currently executing function. 
     * 
     * To pass arguments through, use the literal `arguments` as the parameter 
     * to `super()`.
     *
     *     nextPageAction: function(e) {
     *       // invoke the superclass version of `nextPageAction`
     *       this.super(arguments); 
     *     }
     *
     * To pass custom arguments, arrange them in an array.
     *
     *     appendSerialNo: function(value, serial) {
     *       // prefix the superclass serial number with our lot # before
     *       // invoking the superlcass
     *       return this.super([value, this.lotNo + serial])
     *     }
     *
     * @method super
     * @type Any
     * @param {args) An array of arguments to use when calling the superclass method, or null.
     */
    super: Polymer.super,

    /**
     * Lifecycle method called when the element is instantiated.
     * 
     * Override `created` to perform custom create-time tasks. No need to call 
     * super-class `created` unless you are extending another Polymer element.
     * Created is called before the element creates `shadowRoot` or prepares
     * data-observation.
     * 
     * @method created
     * @type void
     */
    created: function() {
    },

    /**
     * Lifecycle method called when the element has populated it's `shadowRoot`,
     * prepared data-observation, and made itself ready for API interaction.
     * 
     * @method ready
     * @type void
     */
    ready: function() {
    },

    /**
     * Low-level lifecycle method called as part of standard Custom Elements
     * operation. Polymer implements this method to provide basic default 
     * functionality. For custom create-time tasks, implement `created` 
     * instead, which is called immediately after `createdCallback`. 
     * 
     * @method createdCallback
     */
    createdCallback: function() {
      if (this.templateInstance && this.templateInstance.model) {
        console.warn('Attributes on ' + this.localName + ' were data bound ' +
            'prior to Polymer upgrading the element. This may result in ' +
            'incorrect binding types.');
      }
      this.created();
      this.prepareElement();
      if (!this.ownerDocument.isStagingDocument) {
        this.makeElementReady();
      }
    },

    // system entry point, do not override
    prepareElement: function() {
      if (this._elementPrepared) {
        console.warn('Element already prepared', this.localName);
        return;
      }
      this._elementPrepared = true;
      // storage for shadowRoots info
      this.shadowRoots = {};
      // install property observers
      this.createPropertyObserver();
      this.openPropertyObserver();
      // install boilerplate attributes
      this.copyInstanceAttributes();
      // process input attributes
      this.takeAttributes();
      // add event listeners
      this.addHostListeners();
    },

    // system entry point, do not override
    makeElementReady: function() {
      if (this._readied) {
        return;
      }
      this._readied = true;
      this.createComputedProperties();
      this.parseDeclarations(this.__proto__);
      // NOTE: Support use of the `unresolved` attribute to help polyfill
      // custom elements' `:unresolved` feature.
      this.removeAttribute('unresolved');
      // user entry point
      this.ready();
    },

    /**
     * Low-level lifecycle method called as part of standard Custom Elements
     * operation. Polymer implements this method to provide basic default 
     * functionality. For custom tasks in your element, implement `attributeChanged` 
     * instead, which is called immediately after `attributeChangedCallback`. 
     * 
     * @method attributeChangedCallback
     */
    attributeChangedCallback: function(name, oldValue) {
      // TODO(sjmiles): adhoc filter
      if (name !== 'class' && name !== 'style') {
        this.attributeToProperty(name, this.getAttribute(name));
      }
      if (this.attributeChanged) {
        this.attributeChanged.apply(this, arguments);
      }
    },

    /**
     * Low-level lifecycle method called as part of standard Custom Elements
     * operation. Polymer implements this method to provide basic default 
     * functionality. For custom create-time tasks, implement `attached` 
     * instead, which is called immediately after `attachedCallback`. 
     * 
     * @method attachedCallback
     */
     attachedCallback: function() {
      // when the element is attached, prevent it from unbinding.
      this.cancelUnbindAll();
      // invoke user action
      if (this.attached) {
        this.attached();
      }
      if (!this.hasBeenAttached) {
        this.hasBeenAttached = true;
        if (this.domReady) {
          this.async('domReady');
        }
      }
    },

     /**
     * Implement to access custom elements in dom descendants, ancestors, 
     * or siblings. Because custom elements upgrade in document order, 
     * elements accessed in `ready` or `attached` may not be upgraded. When
     * `domReady` is called, all registered custom elements are guaranteed
     * to have been upgraded.
     * 
     * @method domReady
     */

    /**
     * Low-level lifecycle method called as part of standard Custom Elements
     * operation. Polymer implements this method to provide basic default 
     * functionality. For custom create-time tasks, implement `detached` 
     * instead, which is called immediately after `detachedCallback`. 
     * 
     * @method detachedCallback
     */
    detachedCallback: function() {
      if (!this.preventDispose) {
        this.asyncUnbindAll();
      }
      // invoke user action
      if (this.detached) {
        this.detached();
      }
      // TODO(sorvell): bc
      if (this.leftView) {
        this.leftView();
      }
    },

    /**
     * Walks the prototype-chain of this element and allows specific
     * classes a chance to process static declarations.
     * 
     * In particular, each polymer-element has it's own `template`.
     * `parseDeclarations` is used to accumulate all element `template`s
     * from an inheritance chain.
     *
     * `parseDeclaration` static methods implemented in the chain are called
     * recursively, oldest first, with the `<polymer-element>` associated
     * with the current prototype passed as an argument.
     * 
     * An element may override this method to customize shadow-root generation. 
     * 
     * @method parseDeclarations
     */
    parseDeclarations: function(p) {
      if (p && p.element) {
        this.parseDeclarations(p.__proto__);
        p.parseDeclaration.call(this, p.element);
      }
    },

    /**
     * Perform init-time actions based on static information in the
     * `<polymer-element>` instance argument.
     *
     * For example, the standard implementation locates the template associated
     * with the given `<polymer-element>` and stamps it into a shadow-root to
     * implement shadow inheritance.
     *  
     * An element may override this method for custom behavior. 
     * 
     * @method parseDeclaration
     */
    parseDeclaration: function(elementElement) {
      var template = this.fetchTemplate(elementElement);
      if (template) {
        var root = this.shadowFromTemplate(template);
        this.shadowRoots[elementElement.name] = root;
      }
    },

    /**
     * Given a `<polymer-element>`, find an associated template (if any) to be
     * used for shadow-root generation.
     *
     * An element may override this method for custom behavior. 
     * 
     * @method fetchTemplate
     */
    fetchTemplate: function(elementElement) {
      return elementElement.querySelector('template');
    },

    /**
     * Create a shadow-root in this host and stamp `template` as it's 
     * content. 
     *
     * An element may override this method for custom behavior. 
     * 
     * @method shadowFromTemplate
     */
    shadowFromTemplate: function(template) {
      if (template) {
        // make a shadow root
        var root = this.createShadowRoot();
        // stamp template
        // which includes parsing and applying MDV bindings before being
        // inserted (to avoid {{}} in attribute values)
        // e.g. to prevent <img src="images/{{icon}}"> from generating a 404.
        var dom = this.instanceTemplate(template);
        // append to shadow dom
        root.appendChild(dom);
        // perform post-construction initialization tasks on shadow root
        this.shadowRootReady(root, template);
        // return the created shadow root
        return root;
      }
    },

    // utility function that stamps a <template> into light-dom
    lightFromTemplate: function(template, refNode) {
      if (template) {
        // TODO(sorvell): mark this element as an eventController so that
        // event listeners on bound nodes inside it will be called on it.
        // Note, the expectation here is that events on all descendants
        // should be handled by this element.
        this.eventController = this;
        // stamp template
        // which includes parsing and applying MDV bindings before being
        // inserted (to avoid {{}} in attribute values)
        // e.g. to prevent <img src="images/{{icon}}"> from generating a 404.
        var dom = this.instanceTemplate(template);
        // append to shadow dom
        if (refNode) {
          this.insertBefore(dom, refNode);
        } else {
          this.appendChild(dom);
        }
        // perform post-construction initialization tasks on ahem, light root
        this.shadowRootReady(this);
        // return the created shadow root
        return dom;
      }
    },

    shadowRootReady: function(root) {
      // locate nodes with id and store references to them in this.$ hash
      this.marshalNodeReferences(root);
    },

    // locate nodes with id and store references to them in this.$ hash
    marshalNodeReferences: function(root) {
      // establish $ instance variable
      var $ = this.$ = this.$ || {};
      // populate $ from nodes with ID from the LOCAL tree
      if (root) {
        var n$ = root.querySelectorAll("[id]");
        for (var i=0, l=n$.length, n; (i<l) && (n=n$[i]); i++) {
          $[n.id] = n;
        };
      }
    },

    /**
     * Register a one-time callback when a child-list or sub-tree mutation
     * occurs on node. 
     *
     * For persistent callbacks, call onMutation from your listener. 
     * 
     * @method onMutation
     * @param Node {Node} node Node to watch for mutations.
     * @param Function {Function} listener Function to call on mutation. The function is invoked as `listener.call(this, observer, mutations);` where `observer` is the MutationObserver that triggered the notification, and `mutations` is the native mutation list.
     */
    onMutation: function(node, listener) {
      var observer = new MutationObserver(function(mutations) {
        listener.call(this, observer, mutations);
        observer.disconnect();
      }.bind(this));
      observer.observe(node, {childList: true, subtree: true});
    }
  };

  /**
   * @class Polymer
   */
  
  /**
   * Returns true if the object includes <a href="#polymer-base">polymer-base</a> in it's prototype chain.
   * 
   * @method isBase
   * @param Object {Object} object Object to test.
   * @type Boolean
   */
  function isBase(object) {
    return object.hasOwnProperty('PolymerBase')
  }

  // name a base constructor for dev tools

  /**
   * The Polymer base-class constructor.
   * 
   * @property Base
   * @type Function
   */
  function PolymerBase() {};
  PolymerBase.prototype = base;
  base.constructor = PolymerBase;

  // exports

  scope.Base = PolymerBase;
  scope.isBase = isBase;
  scope.api.instance.base = base;

})(Polymer);

(function(scope) {

  // imports

  var log = window.WebComponents ? WebComponents.flags.log : {};
  var hasShadowDOMPolyfill = window.ShadowDOMPolyfill;

  // magic words
  
  var STYLE_SCOPE_ATTRIBUTE = 'element';
  var STYLE_CONTROLLER_SCOPE = 'controller';
  
  var styles = {
    STYLE_SCOPE_ATTRIBUTE: STYLE_SCOPE_ATTRIBUTE,
    /**
     * Installs external stylesheets and <style> elements with the attribute 
     * polymer-scope='controller' into the scope of element. This is intended
     * to be a called during custom element construction.
    */
    installControllerStyles: function() {
      // apply controller styles, but only if they are not yet applied
      var scope = this.findStyleScope();
      if (scope && !this.scopeHasNamedStyle(scope, this.localName)) {
        // allow inherited controller styles
        var proto = getPrototypeOf(this), cssText = '';
        while (proto && proto.element) {
          cssText += proto.element.cssTextForScope(STYLE_CONTROLLER_SCOPE);
          proto = getPrototypeOf(proto);
        }
        if (cssText) {
          this.installScopeCssText(cssText, scope);
        }
      }
    },
    installScopeStyle: function(style, name, scope) {
      var scope = scope || this.findStyleScope(), name = name || '';
      if (scope && !this.scopeHasNamedStyle(scope, this.localName + name)) {
        var cssText = '';
        if (style instanceof Array) {
          for (var i=0, l=style.length, s; (i<l) && (s=style[i]); i++) {
            cssText += s.textContent + '\n\n';
          }
        } else {
          cssText = style.textContent;
        }
        this.installScopeCssText(cssText, scope, name);
      }
    },
    installScopeCssText: function(cssText, scope, name) {
      scope = scope || this.findStyleScope();
      name = name || '';
      if (!scope) {
        return;
      }
      if (hasShadowDOMPolyfill) {
        cssText = shimCssText(cssText, scope.host);
      }
      var style = this.element.cssTextToScopeStyle(cssText,
          STYLE_CONTROLLER_SCOPE);
      Polymer.applyStyleToScope(style, scope);
      // cache that this style has been applied
      this.styleCacheForScope(scope)[this.localName + name] = true;
    },
    findStyleScope: function(node) {
      // find the shadow root that contains this element
      var n = node || this;
      while (n.parentNode) {
        n = n.parentNode;
      }
      return n;
    },
    scopeHasNamedStyle: function(scope, name) {
      var cache = this.styleCacheForScope(scope);
      return cache[name];
    },
    styleCacheForScope: function(scope) {
      if (hasShadowDOMPolyfill) {
        var scopeName = scope.host ? scope.host.localName : scope.localName;
        return polyfillScopeStyleCache[scopeName] || (polyfillScopeStyleCache[scopeName] = {});
      } else {
        return scope._scopeStyles = (scope._scopeStyles || {});
      }
    }
  };

  var polyfillScopeStyleCache = {};
  
  // NOTE: use raw prototype traversal so that we ensure correct traversal
  // on platforms where the protoype chain is simulated via __proto__ (IE10)
  function getPrototypeOf(prototype) {
    return prototype.__proto__;
  }

  function shimCssText(cssText, host) {
    var name = '', is = false;
    if (host) {
      name = host.localName;
      is = host.hasAttribute('is');
    }
    var selector = WebComponents.ShadowCSS.makeScopeSelector(name, is);
    return WebComponents.ShadowCSS.shimCssText(cssText, selector);
  }

  // exports

  scope.api.instance.styles = styles;
  
})(Polymer);

(function(scope) {

  // imports

  var extend = scope.extend;
  var api = scope.api;

  // imperative implementation: Polymer()

  // specify an 'own' prototype for tag `name`
  function element(name, prototype) {
    if (typeof name !== 'string') {
      var script = prototype || document._currentScript;
      prototype = name;
      name = script && script.parentNode && script.parentNode.getAttribute ?
          script.parentNode.getAttribute('name') : '';
      if (!name) {
        throw 'Element name could not be inferred.';
      }
    }
    if (getRegisteredPrototype(name)) {
      throw 'Already registered (Polymer) prototype for element ' + name;
    }
    // cache the prototype
    registerPrototype(name, prototype);
    // notify the registrar waiting for 'name', if any
    notifyPrototype(name);
  }

  // async prototype source

  function waitingForPrototype(name, client) {
    waitPrototype[name] = client;
  }

  var waitPrototype = {};

  function notifyPrototype(name) {
    if (waitPrototype[name]) {
      waitPrototype[name].registerWhenReady();
      delete waitPrototype[name];
    }
  }

  // utility and bookkeeping

  // maps tag names to prototypes, as registered with
  // Polymer. Prototypes associated with a tag name
  // using document.registerElement are available from
  // HTMLElement.getPrototypeForTag().
  // If an element was fully registered by Polymer, then
  // Polymer.getRegisteredPrototype(name) === 
  //   HTMLElement.getPrototypeForTag(name)

  var prototypesByName = {};

  function registerPrototype(name, prototype) {
    return prototypesByName[name] = prototype || {};
  }

  function getRegisteredPrototype(name) {
    return prototypesByName[name];
  }

  function instanceOfType(element, type) {
    if (typeof type !== 'string') {
      return false;
    }
    var proto = HTMLElement.getPrototypeForTag(type);
    var ctor = proto && proto.constructor;
    if (!ctor) {
      return false;
    }
    if (CustomElements.instanceof) {
      return CustomElements.instanceof(element, ctor);
    }
    return element instanceof ctor;
  }

  // exports

  scope.getRegisteredPrototype = getRegisteredPrototype;
  scope.waitingForPrototype = waitingForPrototype;
  scope.instanceOfType = instanceOfType;

  // namespace shenanigans so we can expose our scope on the registration 
  // function

  // make window.Polymer reference `element()`

  window.Polymer = element;

  // TODO(sjmiles): find a way to do this that is less terrible
  // copy window.Polymer properties onto `element()`

  extend(Polymer, scope);

  // Under the HTMLImports polyfill, scripts in the main document
  // do not block on imports; we want to allow calls to Polymer in the main
  // document. WebComponents collects those calls until we can process them, which
  // we do here.

  if (WebComponents.consumeDeclarations) {
    WebComponents.consumeDeclarations(function(declarations) {
      if (declarations) {
        for (var i=0, l=declarations.length, d; (i<l) && (d=declarations[i]); i++) {
          element.apply(null, d);
        }
      }
    });
  }

})(Polymer);

(function(scope) {

/**
 * @class polymer-base
 */

 /**
  * Resolve a url path to be relative to a `base` url. If unspecified, `base`
  * defaults to the element's ownerDocument url. Can be used to resolve
  * paths from element's in templates loaded in HTMLImports to be relative
  * to the document containing the element. Polymer automatically does this for
  * url attributes in element templates; however, if a url, for
  * example, contains a binding, then `resolvePath` can be used to ensure it is 
  * relative to the element document. For example, in an element's template,
  *
  *     <a href="{{resolvePath(path)}}">Resolved</a>
  * 
  * @method resolvePath
  * @param {String} url Url path to resolve.
  * @param {String} base Optional base url against which to resolve, defaults
  * to the element's ownerDocument url.
  * returns {String} resolved url.
  */

var path = {
  resolveElementPaths: function(node) {
    Polymer.urlResolver.resolveDom(node);
  },
  addResolvePathApi: function() {
    // let assetpath attribute modify the resolve path
    var assetPath = this.getAttribute('assetpath') || '';
    var root = new URL(assetPath, this.ownerDocument.baseURI);
    this.prototype.resolvePath = function(urlPath, base) {
      var u = new URL(urlPath, base || root);
      return u.href;
    };
  }
};

// exports
scope.api.declaration.path = path;

})(Polymer);

(function(scope) {

  // imports

  var log = window.WebComponents ? WebComponents.flags.log : {};
  var api = scope.api.instance.styles;
  var STYLE_SCOPE_ATTRIBUTE = api.STYLE_SCOPE_ATTRIBUTE;

  var hasShadowDOMPolyfill = window.ShadowDOMPolyfill;

  // magic words

  var STYLE_SELECTOR = 'style';
  var STYLE_LOADABLE_MATCH = '@import';
  var SHEET_SELECTOR = 'link[rel=stylesheet]';
  var STYLE_GLOBAL_SCOPE = 'global';
  var SCOPE_ATTR = 'polymer-scope';

  var styles = {
    // returns true if resources are loading
    loadStyles: function(callback) {
      var template = this.fetchTemplate();
      var content = template && this.templateContent();
      if (content) {
        this.convertSheetsToStyles(content);
        var styles = this.findLoadableStyles(content);
        if (styles.length) {
          var templateUrl = template.ownerDocument.baseURI;
          return Polymer.styleResolver.loadStyles(styles, templateUrl, callback);
        }
      }
      if (callback) {
        callback();
      }
    },
    convertSheetsToStyles: function(root) {
      var s$ = root.querySelectorAll(SHEET_SELECTOR);
      for (var i=0, l=s$.length, s, c; (i<l) && (s=s$[i]); i++) {
        c = createStyleElement(importRuleForSheet(s, this.ownerDocument.baseURI),
            this.ownerDocument);
        this.copySheetAttributes(c, s);
        s.parentNode.replaceChild(c, s);
      }
    },
    copySheetAttributes: function(style, link) {
      for (var i=0, a$=link.attributes, l=a$.length, a; (a=a$[i]) && i<l; i++) {
        if (a.name !== 'rel' && a.name !== 'href') {
          style.setAttribute(a.name, a.value);
        }
      }
    },
    findLoadableStyles: function(root) {
      var loadables = [];
      if (root) {
        var s$ = root.querySelectorAll(STYLE_SELECTOR);
        for (var i=0, l=s$.length, s; (i<l) && (s=s$[i]); i++) {
          if (s.textContent.match(STYLE_LOADABLE_MATCH)) {
            loadables.push(s);
          }
        }
      }
      return loadables;
    },
    /**
     * Install external stylesheets loaded in <polymer-element> elements into the 
     * element's template.
     * @param elementElement The <element> element to style.
     */
    installSheets: function() {
      this.cacheSheets();
      this.cacheStyles();
      this.installLocalSheets();
      this.installGlobalStyles();
    },
    /**
     * Remove all sheets from element and store for later use.
     */
    cacheSheets: function() {
      this.sheets = this.findNodes(SHEET_SELECTOR);
      this.sheets.forEach(function(s) {
        if (s.parentNode) {
          s.parentNode.removeChild(s);
        }
      });
    },
    cacheStyles: function() {
      this.styles = this.findNodes(STYLE_SELECTOR + '[' + SCOPE_ATTR + ']');
      this.styles.forEach(function(s) {
        if (s.parentNode) {
          s.parentNode.removeChild(s);
        }
      });
    },
    /**
     * Takes external stylesheets loaded in an <element> element and moves
     * their content into a <style> element inside the <element>'s template.
     * The sheet is then removed from the <element>. This is done only so 
     * that if the element is loaded in the main document, the sheet does
     * not become active.
     * Note, ignores sheets with the attribute 'polymer-scope'.
     * @param elementElement The <element> element to style.
     */
    installLocalSheets: function () {
      var sheets = this.sheets.filter(function(s) {
        return !s.hasAttribute(SCOPE_ATTR);
      });
      var content = this.templateContent();
      if (content) {
        var cssText = '';
        sheets.forEach(function(sheet) {
          cssText += cssTextFromSheet(sheet) + '\n';
        });
        if (cssText) {
          var style = createStyleElement(cssText, this.ownerDocument);
          content.insertBefore(style, content.firstChild);
        }
      }
    },
    findNodes: function(selector, matcher) {
      var nodes = this.querySelectorAll(selector).array();
      var content = this.templateContent();
      if (content) {
        var templateNodes = content.querySelectorAll(selector).array();
        nodes = nodes.concat(templateNodes);
      }
      return matcher ? nodes.filter(matcher) : nodes;
    },
    /**
     * Promotes external stylesheets and <style> elements with the attribute 
     * polymer-scope='global' into global scope.
     * This is particularly useful for defining @keyframe rules which 
     * currently do not function in scoped or shadow style elements.
     * (See wkb.ug/72462)
     * @param elementElement The <element> element to style.
    */
    // TODO(sorvell): remove when wkb.ug/72462 is addressed.
    installGlobalStyles: function() {
      var style = this.styleForScope(STYLE_GLOBAL_SCOPE);
      applyStyleToScope(style, document.head);
    },
    cssTextForScope: function(scopeDescriptor) {
      var cssText = '';
      // handle stylesheets
      var selector = '[' + SCOPE_ATTR + '=' + scopeDescriptor + ']';
      var matcher = function(s) {
        return matchesSelector(s, selector);
      };
      var sheets = this.sheets.filter(matcher);
      sheets.forEach(function(sheet) {
        cssText += cssTextFromSheet(sheet) + '\n\n';
      });
      // handle cached style elements
      var styles = this.styles.filter(matcher);
      styles.forEach(function(style) {
        cssText += style.textContent + '\n\n';
      });
      return cssText;
    },
    styleForScope: function(scopeDescriptor) {
      var cssText = this.cssTextForScope(scopeDescriptor);
      return this.cssTextToScopeStyle(cssText, scopeDescriptor);
    },
    cssTextToScopeStyle: function(cssText, scopeDescriptor) {
      if (cssText) {
        var style = createStyleElement(cssText);
        style.setAttribute(STYLE_SCOPE_ATTRIBUTE, this.getAttribute('name') +
            '-' + scopeDescriptor);
        return style;
      }
    }
  };

  function importRuleForSheet(sheet, baseUrl) {
    var href = new URL(sheet.getAttribute('href'), baseUrl).href;
    return '@import \'' + href + '\';';
  }

  function applyStyleToScope(style, scope) {
    if (style) {
      if (scope === document) {
        scope = document.head;
      }
      if (hasShadowDOMPolyfill) {
        scope = document.head;
      }
      // TODO(sorvell): necessary for IE
      // see https://connect.microsoft.com/IE/feedback/details/790212/
      // cloning-a-style-element-and-adding-to-document-produces
      // -unexpected-result#details
      // var clone = style.cloneNode(true);
      var clone = createStyleElement(style.textContent);
      var attr = style.getAttribute(STYLE_SCOPE_ATTRIBUTE);
      if (attr) {
        clone.setAttribute(STYLE_SCOPE_ATTRIBUTE, attr);
      }
      // TODO(sorvell): probably too brittle; try to figure out 
      // where to put the element.
      var refNode = scope.firstElementChild;
      if (scope === document.head) {
        var selector = 'style[' + STYLE_SCOPE_ATTRIBUTE + ']';
        var s$ = document.head.querySelectorAll(selector);
        if (s$.length) {
          refNode = s$[s$.length-1].nextElementSibling;
        }
      }
      scope.insertBefore(clone, refNode);
    }
  }

  function createStyleElement(cssText, scope) {
    scope = scope || document;
    scope = scope.createElement ? scope : scope.ownerDocument;
    var style = scope.createElement('style');
    style.textContent = cssText;
    return style;
  }

  function cssTextFromSheet(sheet) {
    return (sheet && sheet.__resource) || '';
  }

  function matchesSelector(node, inSelector) {
    if (matches) {
      return matches.call(node, inSelector);
    }
  }
  var p = HTMLElement.prototype;
  var matches = p.matches || p.matchesSelector || p.webkitMatchesSelector 
      || p.mozMatchesSelector;
  
  // exports

  scope.api.declaration.styles = styles;
  scope.applyStyleToScope = applyStyleToScope;
  
})(Polymer);

(function(scope) {

  // imports

  var log = window.WebComponents ? WebComponents.flags.log : {};
  var api = scope.api.instance.events;
  var EVENT_PREFIX = api.EVENT_PREFIX;

  var mixedCaseEventTypes = {};
  [
    'webkitAnimationStart',
    'webkitAnimationEnd',
    'webkitTransitionEnd',
    'DOMFocusOut',
    'DOMFocusIn',
    'DOMMouseScroll'
  ].forEach(function(e) {
    mixedCaseEventTypes[e.toLowerCase()] = e;
  });

  // polymer-element declarative api: events feature
  var events = {
    parseHostEvents: function() {
      // our delegates map
      var delegates = this.prototype.eventDelegates;
      // extract data from attributes into delegates
      this.addAttributeDelegates(delegates);
    },
    addAttributeDelegates: function(delegates) {
      // for each attribute
      for (var i=0, a; a=this.attributes[i]; i++) {
        // does it have magic marker identifying it as an event delegate?
        if (this.hasEventPrefix(a.name)) {
          // if so, add the info to delegates
          delegates[this.removeEventPrefix(a.name)] = a.value.replace('{{', '')
              .replace('}}', '').trim();
        }
      }
    },
    // starts with 'on-'
    hasEventPrefix: function (n) {
      return n && (n[0] === 'o') && (n[1] === 'n') && (n[2] === '-');
    },
    removeEventPrefix: function(n) {
      return n.slice(prefixLength);
    },
    findController: function(node) {
      while (node.parentNode) {
        if (node.eventController) {
          return node.eventController;
        }
        node = node.parentNode;
      }
      return node.host;
    },
    getEventHandler: function(controller, target, method) {
      var events = this;
      return function(e) {
        if (!controller || !controller.PolymerBase) {
          controller = events.findController(target);
        }

        var args = [e, e.detail, e.currentTarget];
        controller.dispatchMethod(controller, method, args);
      };
    },
    prepareEventBinding: function(pathString, name, node) {
      if (!this.hasEventPrefix(name))
        return;

      var eventType = this.removeEventPrefix(name);
      eventType = mixedCaseEventTypes[eventType] || eventType;

      var events = this;

      return function(model, node, oneTime) {
        var handler = events.getEventHandler(undefined, node, pathString);
        PolymerGestures.addEventListener(node, eventType, handler);

        if (oneTime)
          return;

        // TODO(rafaelw): This is really pointless work. Aside from the cost
        // of these allocations, NodeBind is going to setAttribute back to its
        // current value. Fixing this would mean changing the TemplateBinding
        // binding delegate API.
        function bindingValue() {
          return '{{ ' + pathString + ' }}';
        }

        return {
          open: bindingValue,
          discardChanges: bindingValue,
          close: function() {
            PolymerGestures.removeEventListener(node, eventType, handler);
          }
        };
      };
    }
  };

  var prefixLength = EVENT_PREFIX.length;

  // exports
  scope.api.declaration.events = events;

})(Polymer);

(function(scope) {

  // element api

  var observationBlacklist = ['attribute'];

  var properties = {
    inferObservers: function(prototype) {
      // called before prototype.observe is chained to inherited object
      var observe = prototype.observe, property;
      for (var n in prototype) {
        if (n.slice(-7) === 'Changed') {
          property = n.slice(0, -7);
          if (this.canObserveProperty(property)) {
            if (!observe) {
              observe  = (prototype.observe = {});
            }
            observe[property] = observe[property] || n;
          }
        }
      }
    },
    canObserveProperty: function(property) {
      return (observationBlacklist.indexOf(property) < 0);
    },
    explodeObservers: function(prototype) {
      // called before prototype.observe is chained to inherited object
      var o = prototype.observe;
      if (o) {
        var exploded = {};
        for (var n in o) {
          var names = n.split(' ');
          for (var i=0, ni; ni=names[i]; i++) {
            exploded[ni] = o[n];
          }
        }
        prototype.observe = exploded;
      }
    },
    optimizePropertyMaps: function(prototype) {
      if (prototype.observe) {
        // construct name list
        var a = prototype._observeNames = [];
        for (var n in prototype.observe) {
          var names = n.split(' ');
          for (var i=0, ni; ni=names[i]; i++) {
            a.push(ni);
          }
        }
      }
      if (prototype.publish) {
        // construct name list
        var a = prototype._publishNames = [];
        for (var n in prototype.publish) {
          a.push(n);
        }
      }
      if (prototype.computed) {
        // construct name list
        var a = prototype._computedNames = [];
        for (var n in prototype.computed) {
          a.push(n);
        }
      }
    },
    publishProperties: function(prototype, base) {
      // if we have any properties to publish
      var publish = prototype.publish;
      if (publish) {
        // transcribe `publish` entries onto own prototype
        this.requireProperties(publish, prototype, base);
        // warn and remove accessor names that are broken on some browsers
        this.filterInvalidAccessorNames(publish);
        // construct map of lower-cased property names
        prototype._publishLC = this.lowerCaseMap(publish);
      }
      var computed = prototype.computed;
      if (computed) {
        // warn and remove accessor names that are broken on some browsers
        this.filterInvalidAccessorNames(computed);
      }
    },
    // Publishing/computing a property where the name might conflict with a
    // browser property is not currently supported to help users of Polymer
    // avoid browser bugs:
    //
    // https://code.google.com/p/chromium/issues/detail?id=43394
    // https://bugs.webkit.org/show_bug.cgi?id=49739
    //
    // We can lift this restriction when those bugs are fixed.
    filterInvalidAccessorNames: function(propertyNames) {
      for (var name in propertyNames) {
        // Check if the name is in our blacklist.
        if (this.propertyNameBlacklist[name]) {
          console.warn('Cannot define property "' + name + '" for element "' +
            this.name + '" because it has the same name as an HTMLElement ' +
            'property, and not all browsers support overriding that. ' +
            'Consider giving it a different name.');
          // Remove the invalid accessor from the list.
          delete propertyNames[name];
        }
      }
    },
    //
    // `name: value` entries in the `publish` object may need to generate 
    // matching properties on the prototype.
    //
    // Values that are objects may have a `reflect` property, which
    // signals that the value describes property control metadata.
    // In metadata objects, the prototype default value (if any)
    // is encoded in the `value` property.
    //
    // publish: {
    //   foo: 5, 
    //   bar: {value: true, reflect: true},
    //   zot: {}
    // }
    //
    // `reflect` metadata property controls whether changes to the property
    // are reflected back to the attribute (default false). 
    //
    // A value is stored on the prototype unless it's === `undefined`,
    // in which case the base chain is checked for a value.
    // If the basal value is also undefined, `null` is stored on the prototype.
    //
    // The reflection data is stored on another prototype object, `reflect`
    // which also can be specified directly.
    //
    // reflect: {
    //   foo: true
    // }
    //
    requireProperties: function(propertyInfos, prototype, base) {
      // per-prototype storage for reflected properties
      prototype.reflect = prototype.reflect || {};
      // ensure a prototype value for each property
      // and update the property's reflect to attribute status
      for (var n in propertyInfos) {
        var value = propertyInfos[n];
        // value has metadata if it has a `reflect` property
        if (value && value.reflect !== undefined) {
          prototype.reflect[n] = Boolean(value.reflect);
          value = value.value;
        }
        // only set a value if one is specified
        if (value !== undefined) {
          prototype[n] = value;
        }
      }
    },
    lowerCaseMap: function(properties) {
      var map = {};
      for (var n in properties) {
        map[n.toLowerCase()] = n;
      }
      return map;
    },
    createPropertyAccessor: function(name, ignoreWrites) {
      var proto = this.prototype;

      var privateName = name + '_';
      var privateObservable  = name + 'Observable_';
      proto[privateName] = proto[name];

      Object.defineProperty(proto, name, {
        get: function() {
          var observable = this[privateObservable];
          if (observable)
            observable.deliver();

          return this[privateName];
        },
        set: function(value) {
          if (ignoreWrites) {
            return this[privateName];
          }

          var observable = this[privateObservable];
          if (observable) {
            observable.setValue(value);
            return;
          }

          var oldValue = this[privateName];
          this[privateName] = value;
          this.emitPropertyChangeRecord(name, value, oldValue);

          return value;
        },
        configurable: true
      });
    },
    createPropertyAccessors: function(prototype) {
      var n$ = prototype._computedNames;
      if (n$ && n$.length) {
        for (var i=0, l=n$.length, n, fn; (i<l) && (n=n$[i]); i++) {
          this.createPropertyAccessor(n, true);
        }
      }
      var n$ = prototype._publishNames;
      if (n$ && n$.length) {
        for (var i=0, l=n$.length, n, fn; (i<l) && (n=n$[i]); i++) {
          // If the property is computed and published, the accessor is created
          // above.
          if (!prototype.computed || !prototype.computed[n]) {
            this.createPropertyAccessor(n);
          }
        }
      }
    },
    // This list contains some property names that people commonly want to use,
    // but won't work because of Chrome/Safari bugs. It isn't an exhaustive
    // list. In particular it doesn't contain any property names found on
    // subtypes of HTMLElement (e.g. name, value). Rather it attempts to catch
    // some common cases.
    propertyNameBlacklist: {
      children: 1,
      'class': 1,
      id: 1,
      hidden: 1,
      style: 1,
      title: 1,
    }
  };

  // exports

  scope.api.declaration.properties = properties;

})(Polymer);

(function(scope) {

  // magic words

  var ATTRIBUTES_ATTRIBUTE = 'attributes';
  var ATTRIBUTES_REGEX = /\s|,/;

  // attributes api

  var attributes = {
    
    inheritAttributesObjects: function(prototype) {
      // chain our lower-cased publish map to the inherited version
      this.inheritObject(prototype, 'publishLC');
      // chain our instance attributes map to the inherited version
      this.inheritObject(prototype, '_instanceAttributes');
    },

    publishAttributes: function(prototype, base) {
      // merge names from 'attributes' attribute into the 'publish' object
      var attributes = this.getAttribute(ATTRIBUTES_ATTRIBUTE);
      if (attributes) {
        // create a `publish` object if needed.
        // the `publish` object is only relevant to this prototype, the 
        // publishing logic in `declaration/properties.js` is responsible for
        // managing property values on the prototype chain.
        // TODO(sjmiles): the `publish` object is later chained to it's 
        //                ancestor object, presumably this is only for 
        //                reflection or other non-library uses. 
        var publish = prototype.publish || (prototype.publish = {}); 
        // names='a b c' or names='a,b,c'
        var names = attributes.split(ATTRIBUTES_REGEX);
        // record each name for publishing
        for (var i=0, l=names.length, n; i<l; i++) {
          // remove excess ws
          n = names[i].trim();
          // looks weird, but causes n to exist on `publish` if it does not;
          // a more careful test would need expensive `in` operator
          if (n && publish[n] === undefined) {
            publish[n] = undefined;
          }
        }
      }
    },

    // record clonable attributes from <element>
    accumulateInstanceAttributes: function() {
      // inherit instance attributes
      var clonable = this.prototype._instanceAttributes;
      // merge attributes from element
      var a$ = this.attributes;
      for (var i=0, l=a$.length, a; (i<l) && (a=a$[i]); i++) {  
        if (this.isInstanceAttribute(a.name)) {
          clonable[a.name] = a.value;
        }
      }
    },

    isInstanceAttribute: function(name) {
      return !this.blackList[name] && name.slice(0,3) !== 'on-';
    },

    // do not clone these attributes onto instances
    blackList: {
      name: 1,
      'extends': 1,
      constructor: 1,
      noscript: 1,
      assetpath: 1,
      'cache-csstext': 1
    }
    
  };

  // add ATTRIBUTES_ATTRIBUTE to the blacklist
  attributes.blackList[ATTRIBUTES_ATTRIBUTE] = 1;

  // exports

  scope.api.declaration.attributes = attributes;

})(Polymer);

(function(scope) {

  // imports
  var events = scope.api.declaration.events;

  var syntax = new PolymerExpressions();
  var prepareBinding = syntax.prepareBinding;

  // Polymer takes a first crack at the binding to see if it's a declarative
  // event handler.
  syntax.prepareBinding = function(pathString, name, node) {
    return events.prepareEventBinding(pathString, name, node) ||
           prepareBinding.call(syntax, pathString, name, node);
  };

  // declaration api supporting mdv
  var mdv = {
    syntax: syntax,
    fetchTemplate: function() {
      return this.querySelector('template');
    },
    templateContent: function() {
      var template = this.fetchTemplate();
      return template && template.content;
    },
    installBindingDelegate: function(template) {
      if (template) {
        template.bindingDelegate = this.syntax;
      }
    }
  };

  // exports
  scope.api.declaration.mdv = mdv;

})(Polymer);

(function(scope) {

  // imports
  
  var api = scope.api;
  var isBase = scope.isBase;
  var extend = scope.extend;

  var hasShadowDOMPolyfill = window.ShadowDOMPolyfill;

  // prototype api

  var prototype = {

    register: function(name, extendeeName) {
      // build prototype combining extendee, Polymer base, and named api
      this.buildPrototype(name, extendeeName);
      // register our custom element with the platform
      this.registerPrototype(name, extendeeName);
      // reference constructor in a global named by 'constructor' attribute
      this.publishConstructor();
    },

    buildPrototype: function(name, extendeeName) {
      // get our custom prototype (before chaining)
      var extension = scope.getRegisteredPrototype(name);
      // get basal prototype
      var base = this.generateBasePrototype(extendeeName);
      // implement declarative features
      this.desugarBeforeChaining(extension, base);
      // join prototypes
      this.prototype = this.chainPrototypes(extension, base);
      // more declarative features
      this.desugarAfterChaining(name, extendeeName);
    },

    desugarBeforeChaining: function(prototype, base) {
      // back reference declaration element
      // TODO(sjmiles): replace `element` with `elementElement` or `declaration`
      prototype.element = this;
      // transcribe `attributes` declarations onto own prototype's `publish`
      this.publishAttributes(prototype, base);
      // `publish` properties to the prototype and to attribute watch
      this.publishProperties(prototype, base);
      // infer observers for `observe` list based on method names
      this.inferObservers(prototype);
      // desugar compound observer syntax, e.g. 'a b c' 
      this.explodeObservers(prototype);
    },

    chainPrototypes: function(prototype, base) {
      // chain various meta-data objects to inherited versions
      this.inheritMetaData(prototype, base);
      // chain custom api to inherited
      var chained = this.chainObject(prototype, base);
      // x-platform fixup
      ensurePrototypeTraversal(chained);
      return chained;
    },

    inheritMetaData: function(prototype, base) {
      // chain observe object to inherited
      this.inheritObject('observe', prototype, base);
      // chain publish object to inherited
      this.inheritObject('publish', prototype, base);
      // chain reflect object to inherited
      this.inheritObject('reflect', prototype, base);
      // chain our lower-cased publish map to the inherited version
      this.inheritObject('_publishLC', prototype, base);
      // chain our instance attributes map to the inherited version
      this.inheritObject('_instanceAttributes', prototype, base);
      // chain our event delegates map to the inherited version
      this.inheritObject('eventDelegates', prototype, base);
    },

    // implement various declarative features
    desugarAfterChaining: function(name, extendee) {
      // build side-chained lists to optimize iterations
      this.optimizePropertyMaps(this.prototype);
      this.createPropertyAccessors(this.prototype);
      // install mdv delegate on template
      this.installBindingDelegate(this.fetchTemplate());
      // install external stylesheets as if they are inline
      this.installSheets();
      // adjust any paths in dom from imports
      this.resolveElementPaths(this);
      // compile list of attributes to copy to instances
      this.accumulateInstanceAttributes();
      // parse on-* delegates declared on `this` element
      this.parseHostEvents();
      //
      // install a helper method this.resolvePath to aid in 
      // setting resource urls. e.g.
      // this.$.image.src = this.resolvePath('images/foo.png')
      this.addResolvePathApi();
      // under ShadowDOMPolyfill, transforms to approximate missing CSS features
      if (hasShadowDOMPolyfill) {
        WebComponents.ShadowCSS.shimStyling(this.templateContent(), name,
          extendee);
      }
      // allow custom element access to the declarative context
      if (this.prototype.registerCallback) {
        this.prototype.registerCallback(this);
      }
    },

    // if a named constructor is requested in element, map a reference
    // to the constructor to the given symbol
    publishConstructor: function() {
      var symbol = this.getAttribute('constructor');
      if (symbol) {
        window[symbol] = this.ctor;
      }
    },

    // build prototype combining extendee, Polymer base, and named api
    generateBasePrototype: function(extnds) {
      var prototype = this.findBasePrototype(extnds);
      if (!prototype) {
        // create a prototype based on tag-name extension
        var prototype = HTMLElement.getPrototypeForTag(extnds);
        // insert base api in inheritance chain (if needed)
        prototype = this.ensureBaseApi(prototype);
        // memoize this base
        memoizedBases[extnds] = prototype;
      }
      return prototype;
    },

    findBasePrototype: function(name) {
      return memoizedBases[name];
    },

    // install Polymer instance api into prototype chain, as needed 
    ensureBaseApi: function(prototype) {
      if (prototype.PolymerBase) {
        return prototype;
      }
      var extended = Object.create(prototype);
      // we need a unique copy of base api for each base prototype
      // therefore we 'extend' here instead of simply chaining
      api.publish(api.instance, extended);
      // TODO(sjmiles): sharing methods across prototype chains is
      // not supported by 'super' implementation which optimizes
      // by memoizing prototype relationships.
      // Probably we should have a version of 'extend' that is 
      // share-aware: it could study the text of each function,
      // look for usage of 'super', and wrap those functions in
      // closures.
      // As of now, there is only one problematic method, so 
      // we just patch it manually.
      // To avoid re-entrancy problems, the special super method
      // installed is called `mixinSuper` and the mixin method
      // must use this method instead of the default `super`.
      this.mixinMethod(extended, prototype, api.instance.mdv, 'bind');
      // return buffed-up prototype
      return extended;
    },

    mixinMethod: function(extended, prototype, api, name) {
      var $super = function(args) {
        return prototype[name].apply(this, args);
      };
      extended[name] = function() {
        this.mixinSuper = $super;
        return api[name].apply(this, arguments);
      }
    },

    // ensure prototype[name] inherits from a prototype.prototype[name]
    inheritObject: function(name, prototype, base) {
      // require an object
      var source = prototype[name] || {};
      // chain inherited properties onto a new object
      prototype[name] = this.chainObject(source, base[name]);
    },

    // register 'prototype' to custom element 'name', store constructor 
    registerPrototype: function(name, extendee) { 
      var info = {
        prototype: this.prototype
      }
      // native element must be specified in extends
      var typeExtension = this.findTypeExtension(extendee);
      if (typeExtension) {
        info.extends = typeExtension;
      }
      // register the prototype with HTMLElement for name lookup
      HTMLElement.register(name, this.prototype);
      // register the custom type
      this.ctor = document.registerElement(name, info);
    },

    findTypeExtension: function(name) {
      if (name && name.indexOf('-') < 0) {
        return name;
      } else {
        var p = this.findBasePrototype(name);
        if (p.element) {
          return this.findTypeExtension(p.element.extends);
        }
      }
    }

  };

  // memoize base prototypes
  var memoizedBases = {};

  // implementation of 'chainObject' depends on support for __proto__
  if (Object.__proto__) {
    prototype.chainObject = function(object, inherited) {
      if (object && inherited && object !== inherited) {
        object.__proto__ = inherited;
      }
      return object;
    }
  } else {
    prototype.chainObject = function(object, inherited) {
      if (object && inherited && object !== inherited) {
        var chained = Object.create(inherited);
        object = extend(chained, object);
      }
      return object;
    }
  }

  // On platforms that do not support __proto__ (versions of IE), the prototype
  // chain of a custom element is simulated via installation of __proto__.
  // Although custom elements manages this, we install it here so it's
  // available during desugaring.
  function ensurePrototypeTraversal(prototype) {
    if (!Object.__proto__) {
      var ancestor = Object.getPrototypeOf(prototype);
      prototype.__proto__ = ancestor;
      if (isBase(ancestor)) {
        ancestor.__proto__ = Object.getPrototypeOf(ancestor);
      }
    }
  }

  // exports

  api.declaration.prototype = prototype;

})(Polymer);

(function(scope) {

  /*

    Elements are added to a registration queue so that they register in 
    the proper order at the appropriate time. We do this for a few reasons:

    * to enable elements to load resources (like stylesheets) 
    asynchronously. We need to do this until the platform provides an efficient
    alternative. One issue is that remote @import stylesheets are 
    re-fetched whenever stamped into a shadowRoot.

    * to ensure elements loaded 'at the same time' (e.g. via some set of
    imports) are registered as a batch. This allows elements to be enured from
    upgrade ordering as long as they query the dom tree 1 task after
    upgrade (aka domReady). This is a performance tradeoff. On the one hand,
    elements that could register while imports are loading are prevented from 
    doing so. On the other, grouping upgrades into a single task means less
    incremental work (for example style recalcs),  Also, we can ensure the 
    document is in a known state at the single quantum of time when 
    elements upgrade.

  */
  var queue = {

    // tell the queue to wait for an element to be ready
    wait: function(element) {
      if (!element.__queue) {
        element.__queue = {};
        elements.push(element);
      }
    },

    // enqueue an element to the next spot in the queue.
    enqueue: function(element, check, go) {
      var shouldAdd = element.__queue && !element.__queue.check;
      if (shouldAdd) {
        queueForElement(element).push(element);
        element.__queue.check = check;
        element.__queue.go = go;
      }
      return (this.indexOf(element) !== 0);
    },

    indexOf: function(element) {
      var i = queueForElement(element).indexOf(element);
      if (i >= 0 && document.contains(element)) {
        i += (HTMLImports.useNative || HTMLImports.ready) ? 
          importQueue.length : 1e9;
      }
      return i;  
    },

    // tell the queue an element is ready to be registered
    go: function(element) {
      var readied = this.remove(element);
      if (readied) {
        element.__queue.flushable = true;
        this.addToFlushQueue(readied);
        this.check();
      }
    },

    remove: function(element) {
      var i = this.indexOf(element);
      if (i !== 0) {
        //console.warn('queue order wrong', i);
        return;
      }
      return queueForElement(element).shift();
    },

    check: function() {
      // next
      var element = this.nextElement();
      if (element) {
        element.__queue.check.call(element);
      }
      if (this.canReady()) {
        this.ready();
        return true;
      }
    },

    nextElement: function() {
      return nextQueued();
    },

    canReady: function() {
      return !this.waitToReady && this.isEmpty();
    },

    isEmpty: function() {
      for (var i=0, l=elements.length, e; (i<l) && 
          (e=elements[i]); i++) {
        if (e.__queue && !e.__queue.flushable) {
          return;
        }
      }
      return true;
    },

    addToFlushQueue: function(element) {
      flushQueue.push(element);  
    },

    flush: function() {
      // prevent re-entrance
      if (this.flushing) {
        return;
      }
      this.flushing = true;
      var element;
      while (flushQueue.length) {
        element = flushQueue.shift();
        element.__queue.go.call(element);
        element.__queue = null;
      }
      this.flushing = false;
    },

    ready: function() {
      // TODO(sorvell): As an optimization, turn off CE polyfill upgrading
      // while registering. This way we avoid having to upgrade each document
      // piecemeal per registration and can instead register all elements
      // and upgrade once in a batch. Without this optimization, upgrade time
      // degrades significantly when SD polyfill is used. This is mainly because
      // querying the document tree for elements is slow under the SD polyfill.
      var polyfillWasReady = CustomElements.ready;
      CustomElements.ready = false;
      this.flush();
      if (!CustomElements.useNative) {
        CustomElements.upgradeDocumentTree(document);
      }
      CustomElements.ready = polyfillWasReady;
      Polymer.flush();
      requestAnimationFrame(this.flushReadyCallbacks);
    },

    addReadyCallback: function(callback) {
      if (callback) {
        readyCallbacks.push(callback);
      }
    },

    flushReadyCallbacks: function() {
      if (readyCallbacks) {
        var fn;
        while (readyCallbacks.length) {
          fn = readyCallbacks.shift();
          fn();
        }
      }
    },
  
    /**
    Returns a list of elements that have had polymer-elements created but 
    are not yet ready to register. The list is an array of element definitions.
    */
    waitingFor: function() {
      var e$ = [];
      for (var i=0, l=elements.length, e; (i<l) && 
          (e=elements[i]); i++) {
        if (e.__queue && !e.__queue.flushable) {
          e$.push(e);
        }
      }
      return e$;
    },

    waitToReady: true

  };

  var elements = [];
  var flushQueue = [];
  var importQueue = [];
  var mainQueue = [];
  var readyCallbacks = [];

  function queueForElement(element) {
    return document.contains(element) ? mainQueue : importQueue;
  }

  function nextQueued() {
    return importQueue.length ? importQueue[0] : mainQueue[0];
  }

  function whenReady(callback) {
    queue.waitToReady = true;
    Polymer.endOfMicrotask(function() {
      HTMLImports.whenReady(function() {
        queue.addReadyCallback(callback);
        queue.waitToReady = false;
        queue.check();
    });
    });
  }

  /**
    Forces polymer to register any pending elements. Can be used to abort
    waiting for elements that are partially defined.
    @param timeout {Integer} Optional timeout in milliseconds
  */
  function forceReady(timeout) {
    if (timeout === undefined) {
      queue.ready();
      return;
    }
    var handle = setTimeout(function() {
      queue.ready();
    }, timeout);
    Polymer.whenReady(function() {
      clearTimeout(handle);
    });
  }

  // exports
  scope.elements = elements;
  scope.waitingFor = queue.waitingFor.bind(queue);
  scope.forceReady = forceReady;
  scope.queue = queue;
  scope.whenReady = scope.whenPolymerReady = whenReady;
})(Polymer);

(function(scope) {

  // imports

  var extend = scope.extend;
  var api = scope.api;
  var queue = scope.queue;
  var whenReady = scope.whenReady;
  var getRegisteredPrototype = scope.getRegisteredPrototype;
  var waitingForPrototype = scope.waitingForPrototype;

  // declarative implementation: <polymer-element>

  var prototype = extend(Object.create(HTMLElement.prototype), {

    createdCallback: function() {
      if (this.getAttribute('name')) {
        this.init();
      }
    },

    init: function() {
      // fetch declared values
      this.name = this.getAttribute('name');
      this.extends = this.getAttribute('extends');
      queue.wait(this);
      // initiate any async resource fetches
      this.loadResources();
      // register when all constraints are met
      this.registerWhenReady();
    },

    // TODO(sorvell): we currently queue in the order the prototypes are 
    // registered, but we should queue in the order that polymer-elements
    // are registered. We are currently blocked from doing this based on 
    // crbug.com/395686.
    registerWhenReady: function() {
     if (this.registered
       || this.waitingForPrototype(this.name)
       || this.waitingForQueue()
       || this.waitingForResources()) {
          return;
      }
      queue.go(this);
    },

    _register: function() {
      //console.log('registering', this.name);
      // warn if extending from a custom element not registered via Polymer
      if (isCustomTag(this.extends) && !isRegistered(this.extends)) {
        console.warn('%s is attempting to extend %s, an unregistered element ' +
            'or one that was not registered with Polymer.', this.name,
            this.extends);
      }
      this.register(this.name, this.extends);
      this.registered = true;
    },

    waitingForPrototype: function(name) {
      if (!getRegisteredPrototype(name)) {
        // then wait for a prototype
        waitingForPrototype(name, this);
        // emulate script if user is not supplying one
        this.handleNoScript(name);
        // prototype not ready yet
        return true;
      }
    },

    handleNoScript: function(name) {
      // if explicitly marked as 'noscript'
      if (this.hasAttribute('noscript') && !this.noscript) {
        this.noscript = true;
        // imperative element registration
        Polymer(name);
      }
    },

    waitingForResources: function() {
      return this._needsResources;
    },

    // NOTE: Elements must be queued in proper order for inheritance/composition
    // dependency resolution. Previously this was enforced for inheritance,
    // and by rule for composition. It's now entirely by rule.
    waitingForQueue: function() {
      return queue.enqueue(this, this.registerWhenReady, this._register);
    },

    loadResources: function() {
      this._needsResources = true;
      this.loadStyles(function() {
        this._needsResources = false;
        this.registerWhenReady();
      }.bind(this));
    }

  });

  // semi-pluggable APIs 

  // TODO(sjmiles): should be fully pluggable (aka decoupled, currently
  // the various plugins are allowed to depend on each other directly)
  api.publish(api.declaration, prototype);

  // utility and bookkeeping

  function isRegistered(name) {
    return Boolean(HTMLElement.getPrototypeForTag(name));
  }

  function isCustomTag(name) {
    return (name && name.indexOf('-') >= 0);
  }

  // boot tasks

  whenReady(function() {
    document.body.removeAttribute('unresolved');
    document.dispatchEvent(
      new CustomEvent('polymer-ready', {bubbles: true})
    );
  });

  // register polymer-element with document

  document.registerElement('polymer-element', {prototype: prototype});

})(Polymer);

(function(scope) {

/**
 * @class Polymer
 */

var whenReady = scope.whenReady;

/**
 * Loads the set of HTMLImports contained in `node`. Notifies when all
 * the imports have loaded by calling the `callback` function argument.
 * This method can be used to lazily load imports. For example, given a 
 * template:
 *     
 *     <template>
 *       <link rel="import" href="my-import1.html">
 *       <link rel="import" href="my-import2.html">
 *     </template>
 *
 *     Polymer.importElements(template.content, function() {
 *       console.log('imports lazily loaded'); 
 *     });
 * 
 * @method importElements
 * @param {Node} node Node containing the HTMLImports to load.
 * @param {Function} callback Callback called when all imports have loaded.
 */
function importElements(node, callback) {
  if (node) {
    document.head.appendChild(node);
    whenReady(callback);
  } else if (callback) {
    callback();
  }
}

/**
 * Loads an HTMLImport for each url specified in the `urls` array.
 * Notifies when all the imports have loaded by calling the `callback` 
 * function argument. This method can be used to lazily load imports. 
 * For example,
 *
 *     Polymer.import(['my-import1.html', 'my-import2.html'], function() {
 *       console.log('imports lazily loaded'); 
 *     });
 * 
 * @method import
 * @param {Array} urls Array of urls to load as HTMLImports.
 * @param {Function} callback Callback called when all imports have loaded.
 */
function _import(urls, callback) {
  if (urls && urls.length) {
      var frag = document.createDocumentFragment();
      for (var i=0, l=urls.length, url, link; (i<l) && (url=urls[i]); i++) {
        link = document.createElement('link');
        link.rel = 'import';
        link.href = url;
        frag.appendChild(link);
      }
      importElements(frag, callback);
  } else if (callback) {
    callback();
  }
}

// exports
scope.import = _import;
scope.importElements = importElements;

})(Polymer);

/**
 * The `auto-binding` element extends the template element. It provides a quick 
 * and easy way to do data binding without the need to setup a model. 
 * The `auto-binding` element itself serves as the model and controller for the 
 * elements it contains. Both data and event handlers can be bound. 
 *
 * The `auto-binding` element acts just like a template that is bound to 
 * a model. It stamps its content in the dom adjacent to itself. When the 
 * content is stamped, the `template-bound` event is fired.
 *
 * Example:
 *
 *     <template is="auto-binding">
 *       <div>Say something: <input value="{{value}}"></div>
 *       <div>You said: {{value}}</div>
 *       <button on-tap="{{buttonTap}}">Tap me!</button>
 *     </template>
 *     <script>
 *       var template = document.querySelector('template');
 *       template.value = 'something';
 *       template.buttonTap = function() {
 *         console.log('tap!');
 *       };
 *     </script>
 *
 * @module Polymer
 * @status stable
*/

(function() {

  var element = document.createElement('polymer-element');
  element.setAttribute('name', 'auto-binding');
  element.setAttribute('extends', 'template');
  element.init();

  Polymer('auto-binding', {

    createdCallback: function() {
      this.syntax = this.bindingDelegate = this.makeSyntax();
      // delay stamping until polymer-ready so that auto-binding is not
      // required to load last.
      Polymer.whenPolymerReady(function() {
        this.model = this;
        this.setAttribute('bind', '');
        // we don't bother with an explicit signal here, we could ust a MO
        // if necessary
        this.async(function() {
          // note: this will marshall *all* the elements in the parentNode
          // rather than just stamped ones. We'd need to use createInstance
          // to fix this or something else fancier.
          this.marshalNodeReferences(this.parentNode);
          // template stamping is asynchronous so stamping isn't complete
          // by polymer-ready; fire an event so users can use stamped elements
          this.fire('template-bound');
        });
      }.bind(this));
    },

    makeSyntax: function() {
      var events = Object.create(Polymer.api.declaration.events);
      var self = this;
      events.findController = function() { return self.model; };

      var syntax = new PolymerExpressions();
      var prepareBinding = syntax.prepareBinding;  
      syntax.prepareBinding = function(pathString, name, node) {
        return events.prepareEventBinding(pathString, name, node) ||
               prepareBinding.call(syntax, pathString, name, node);
      };
      return syntax;
    }

  });

})();
</script>
<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<!--
`core-meta` provides a method of constructing a self-organizing database.
It is useful to collate element meta-data for things like catalogs and for 
designer.

Example, an element folder has a `metadata.html` file in it, that contains a 
`core-meta`, something like this:

    <core-meta id="my-element" label="My Element">
      <property name="color" value="blue"></property>
    </core-meta>

An application can import as many of these files as it wants, and then use 
`core-meta` again to access the collected data.

    <script>
      var meta = document.createElement('core-meta');
      console.log(meta.list); // dump a list of all meta-data elements that have been created
    </script>

Use `byId(id)` to retrive a specific core-meta.

    <script>
      var meta = document.createElement('core-meta');
      console.log(meta.byId('my-element'));
    </script>

By default all meta-data are stored in a single databse.  If your meta-data 
have different types and want them to be stored separately, use `type` to 
differentiate them.

Example:

    <core-meta id="x-foo" type="xElt"></core-meta>
    <core-meta id="x-bar" type="xElt"></core-meta>
    <core-meta id="y-bar" type="yElt"></core-meta>

    <script>
      var meta = document.createElement('core-meta');
      meta.type = 'xElt';
      console.log(meta.list);
    </script>

@group Polymer Core Elements
@element core-meta
@homepage github.io
-->



<polymer-element name="core-meta" attributes="label type" hidden="">
<script>

  (function() {
    
    var SKIP_ID = 'meta';
    var metaData = {}, metaArray = {};

    Polymer('core-meta', {
      
      /**
       * The type of meta-data.  All meta-data with the same type with be
       * stored together.
       * 
       * @attribute type
       * @type string
       * @default 'default'
       */
      type: 'default',
      
      alwaysPrepare: true,
      
      ready: function() {
        this.register(this.id);
      },
      
      get metaArray() {
        var t = this.type;
        if (!metaArray[t]) {
          metaArray[t] = [];
        }
        return metaArray[t];
      },
      
      get metaData() {
        var t = this.type;
        if (!metaData[t]) {
          metaData[t] = {};
        }
        return metaData[t];
      },
      
      register: function(id, old) {
        if (id && id !== SKIP_ID) {
          this.unregister(this, old);
          this.metaData[id] = this;
          this.metaArray.push(this);
        }
      },
      
      unregister: function(meta, id) {
        delete this.metaData[id || meta.id];
        var i = this.metaArray.indexOf(meta);
        if (i >= 0) {
          this.metaArray.splice(i, 1);
        }
      },
      
      /**
       * Returns a list of all meta-data elements with the same type.
       * 
       * @property list
       * @type array
       * @default []
       */
      get list() {
        return this.metaArray;
      },
      
      /**
       * Retrieves meta-data by ID.
       *
       * @method byId
       * @param {String} id The ID of the meta-data to be returned.
       * @returns Returns meta-data.
       */
      byId: function(id) {
        return this.metaData[id];
      }
      
    });
    
  })();
  
</script>
</polymer-element>
<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<!--
/**
 * @group Polymer Core Elements
 *
 * The `core-iconset` element allows users to define their own icon sets. 
 * The `src` property specifies the url of the icon image. Multiple icons may
 * be included in this image and they may be organized into rows.
 * The `icons` property is a space separated list of names corresponding to the
 * icons. The names must be ordered as the icons are ordered in the icon image.
 * Icons are expected to be square and are the size specified by the `iconSize`
 * property. The `width` property corresponds to the width of the icon image 
 * and must be specified if icons are arranged into multiple rows in the image.
 *
 * All `core-iconset` elements are available for use by other `core-iconset`
 * elements via a database keyed by id. Typically, an element author that wants
 * to support a set of custom icons uses a `core-iconset` to retrieve 
 * and use another, user-defined iconset.
 *
 * Example:
 *
 *     <core-iconset id="my-icons" src="my-icons.png" width="96" iconSize="24"
 *         icons="location place starta stopb bus car train walk">
 *     </core-iconset>
 *
 * This will automatically register the icon set "my-icons" to the iconset
 * database.  To use these icons from within another element, make a 
 * `core-iconset` element and call the `byId` method to retrieve a
 * given iconset. To apply a particular icon to an element, use the 
 * `applyIcon` method. For example:
 *
 *     iconset.applyIcon(iconNode, 'car');
 *
 * Themed icon sets are also supported. The `core-iconset` can contain child
 * `property` elements that specify a theme with an offsetX and offsetY of the
 * theme within the icon resource. For example.
 *
 *     <core-iconset id="my-icons" src="my-icons.png" width="96" iconSize="24"
 *         icons="location place starta stopb bus car train walk">
 *       <property theme="special" offsetX="256" offsetY="24"></property>
 *     </core-iconset>
 *
 * Then a themed icon can be applied like this:
 *
 *     iconset.applyIcon(iconNode, 'car', 'special');
 *
 * @element core-iconset
 * @extends core-meta
 * @homepage github.io
 */
-->



<polymer-element name="core-iconset" extends="core-meta" attributes="src width icons iconSize">
  
  <script>
  
    Polymer('core-iconset', {
  
      /**
       * The URL of the iconset image.
       *
       * @attribute src
       * @type string
       * @default ''
       */
      src: '',

      /**
       * The width of the iconset image. This must only be specified if the
       * icons are arranged into separate rows inside the image.
       *
       * @attribute width
       * @type number
       * @default 0
       */
      width: 0,

      /**
       * A space separated list of names corresponding to icons in the iconset
       * image file. This list must be ordered the same as the icon images
       * in the image file.
       *
       * @attribute icons
       * @type string
       * @default ''
       */
      icons: '',

      /**
       * The size of an individual icon. Note that icons must be square.
       *
       * @attribute iconSize
       * @type number
       * @default 24
       */
      iconSize: 24,

      /**
       * The horizontal offset of the icon images in the inconset src image.
       * This is typically used if the image resource contains additional images
       * beside those intended for the iconset.
       *
       * @attribute offsetX
       * @type number
       * @default 0
       */
      offsetX: 0,
      /**
       * The vertical offset of the icon images in the inconset src image.
       * This is typically used if the image resource contains additional images
       * beside those intended for the iconset.
       *
       * @attribute offsetY
       * @type number
       * @default 0
       */
      offsetY: 0,
      type: 'iconset',

      created: function() {
        this.iconMap = {};
        this.iconNames = [];
        this.themes = {};
      },
  
      ready: function() {
        // TODO(sorvell): ensure iconset's src is always relative to the main
        // document
        if (this.src && (this.ownerDocument !== document)) {
          this.src = this.resolvePath(this.src, this.ownerDocument.baseURI);
        }
        this.super();
        this.updateThemes();
      },

      iconsChanged: function() {
        var ox = this.offsetX;
        var oy = this.offsetY;
        this.icons && this.icons.split(/\s+/g).forEach(function(name, i) {
          this.iconNames.push(name);
          this.iconMap[name] = {
            offsetX: ox,
            offsetY: oy
          }
          if (ox + this.iconSize < this.width) {
            ox += this.iconSize;
          } else {
            ox = this.offsetX;
            oy += this.iconSize;
          }
        }, this);
      },

      updateThemes: function() {
        var ts = this.querySelectorAll('property[theme]');
        ts && ts.array().forEach(function(t) {
          this.themes[t.getAttribute('theme')] = {
            offsetX: parseInt(t.getAttribute('offsetX')) || 0,
            offsetY: parseInt(t.getAttribute('offsetY')) || 0
          };
        }, this);
      },

      // TODO(ffu): support retrived by index e.g. getOffset(10);
      /**
       * Returns an object containing `offsetX` and `offsetY` properties which
       * specify the pixel locaion in the iconset's src file for the given
       * `icon` and `theme`. It's uncommon to call this method. It is useful,
       * for example, to manually position a css backgroundImage to the proper
       * offset. It's more common to use the `applyIcon` method.
       *
       * @method getOffset
       * @param {String|Number} icon The name of the icon or the index of the
       * icon within in the icon image.
       * @param {String} theme The name of the theme.
       * @returns {Object} An object specifying the offset of the given icon 
       * within the icon resource file; `offsetX` is the horizontal offset and
       * `offsetY` is the vertical offset. Both values are in pixel units.
       */
      getOffset: function(icon, theme) {
        var i = this.iconMap[icon];
        if (!i) {
          var n = this.iconNames[Number(icon)];
          i = this.iconMap[n];
        }
        var t = this.themes[theme];
        if (i && t) {
          return {
            offsetX: i.offsetX + t.offsetX,
            offsetY: i.offsetY + t.offsetY
          }
        }
        return i;
      },

      /**
       * Applies an icon to the given element as a css background image. This
       * method does not size the element, and it's often necessary to set 
       * the element's height and width so that the background image is visible.
       *
       * @method applyIcon
       * @param {Element} element The element to which the background is
       * applied.
       * @param {String|Number} icon The name or index of the icon to apply.
       * @param {Number} scale (optional, defaults to 1) A scaling factor 
       * with which the icon can be magnified.
       * @return {Element} The icon element.
       */
      applyIcon: function(element, icon, scale) {
        var offset = this.getOffset(icon);
        scale = scale || 1;
        if (element && offset) {
          var icon = element._icon || document.createElement('div');
          var style = icon.style;
          style.backgroundImage = 'url(' + this.src + ')';
          style.backgroundPosition = (-offset.offsetX * scale + 'px') + 
             ' ' + (-offset.offsetY * scale + 'px');
          style.backgroundSize = scale === 1 ? 'auto' :
             this.width * scale + 'px';
          if (icon.parentNode !== element) {
            element.appendChild(icon);
          }
          return icon;
        }
      }

    });

  </script>

</polymer-element>
<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<!--

The `core-icon` element displays an icon. By default an icon renders as a 24px square.

Example using src:

    <core-icon src="star.png"></core-icon>

Example setting size to 32px x 32px:

    <core-icon class="big" src="big_star.png"></core-icon>

    <style>
      .big {
        height: 32px;
        width: 32px;
      }
    </style>

The core elements include several sets of icons. 
To use the default set of icons, import  `core-icons.html` and use the `icon` attribute to specify an icon:

    &lt;!-- import default iconset and core-icon --&gt;
    <link rel="import" href="/components/core-icons/core-icons.html">

    <core-icon icon="menu"></core-icon>
    
To use a different built-in set of icons, import  `core-icons/<iconset>-icons.html`, and
specify the icon as `<iconset>:<icon>`. For example:

    &lt;!-- import communication iconset and core-icon --&gt;
    <link rel="import" href="/components/core-icons/communication-icons.html">

    <core-icon icon="communication:email"></core-icon>
    
You can also create custom icon sets of bitmap or SVG icons. 

Example of using an icon named `cherry` from a custom iconset with the ID `fruit`:

    <core-icon icon="fruit:cherry"></core-icon>

See [core-iconset](#core-iconset) and [core-iconset-svg](#core-iconset-svg) for more information about
how to create a custom iconset.

See [core-icons](http://www.polymer-project.org/components/core-icons/demo.html) for the default set of icons.

@group Polymer Core Elements
@element core-icon
@homepage polymer.github.io
-->


<style>/* Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt */


html /deep/ core-icon {
  display: inline-block;
  vertical-align: middle;
  background-repeat: no-repeat;
  fill: currentcolor;
  position: relative;
  height: 24px;
  width: 24px;
}
</style>

<polymer-element name="core-icon" attributes="src icon alt">
<script>
(function() {
  
  // mono-state
  var meta;
  
  Polymer('core-icon', {

    /**
     * The URL of an image for the icon. If the src property is specified,
     * the icon property should not be.
     *
     * @attribute src
     * @type string
     * @default ''
     */
    src: '',

    /**
     * Specifies the icon name or index in the set of icons available in
     * the icon's icon set. If the icon property is specified,
     * the src property should not be.
     *
     * @attribute icon
     * @type string
     * @default ''
     */
    icon: '',

    /**
     * Alternative text content for accessibility support.
     * If alt is present and not empty, it will set the element's role to img and add an aria-label whose content matches alt.
     * If alt is present and is an empty string, '', it will hide the element from the accessibility layer
     * If alt is not present, it will set the element's role to img and the element will fallback to using the icon attribute for its aria-label.
     * 
     * @attribute alt
     * @type string
     * @default ''
     */
    alt: null,

    observe: {
      'icon': 'updateIcon',
      'alt': 'updateAlt'
    },

    defaultIconset: 'icons',

    ready: function() {
      if (!meta) {
        meta = document.createElement('core-iconset');
      }

      // Allow user-provided `aria-label` in preference to any other text alternative.
      if (this.hasAttribute('aria-label')) {
        // Set `role` if it has not been overridden.
        if (!this.hasAttribute('role')) {
          this.setAttribute('role', 'img');
        }
        return;
      }
      this.updateAlt();
    },

    srcChanged: function() {
      var icon = this._icon || document.createElement('div');
      icon.textContent = '';
      icon.setAttribute('fit', '');
      icon.style.backgroundImage = 'url(' + this.src + ')';
      icon.style.backgroundPosition = 'center';
      icon.style.backgroundSize = '100%';
      if (!icon.parentNode) {
        this.appendChild(icon);
      }
      this._icon = icon;
    },

    getIconset: function(name) {
      return meta.byId(name || this.defaultIconset);
    },

    updateIcon: function(oldVal, newVal) {
      if (!this.icon) {
        this.updateAlt();
        return;
      }
      var parts = String(this.icon).split(':');
      var icon = parts.pop();
      if (icon) {
        var set = this.getIconset(parts.pop());
        if (set) {
          this._icon = set.applyIcon(this, icon);
          if (this._icon) {
            this._icon.setAttribute('fit', '');
          }
        }
      }
      // Check to see if we're using the old icon's name for our a11y fallback
      if (oldVal) {
        if (oldVal.split(':').pop() == this.getAttribute('aria-label')) {
          this.updateAlt();
        }
      }
    },

    updateAlt: function() {
      // Respect the user's decision to remove this element from
      // the a11y tree
      if (this.getAttribute('aria-hidden')) {
        return;
      }

      // Remove element from a11y tree if `alt` is empty, otherwise
      // use `alt` as `aria-label`.
      if (this.alt === '') {
        this.setAttribute('aria-hidden', 'true');
        if (this.hasAttribute('role')) {
          this.removeAttribute('role');
        }
        if (this.hasAttribute('aria-label')) {
          this.removeAttribute('aria-label');
        }
      } else {
        this.setAttribute('aria-label', this.alt ||
                                        this.icon.split(':').pop());
        if (!this.hasAttribute('role')) {
          this.setAttribute('role', 'img');
        }
        if (this.hasAttribute('aria-hidden')) {
          this.removeAttribute('aria-hidden');
        }
      }
    }

  });
  
})();
</script>

</polymer-element>
<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<!--
/**
 * @group Polymer Core Elements
 *
 * The `core-iconset-svg` element allows users to define their own icon sets
 * that contain svg icons. The svg icon elements should be children of the
 * `core-iconset-svg` element. Multiple icons should be given distinct id's.
 *
 * Using svg elements to create icons has a few advantages over traditional
 * bitmap graphics like jpg or png. Icons that use svg are vector based so they
 * are resolution independent and should look good on any device. They are
 * stylable via css. Icons can be themed, colorized, and even animated.
 *
 * Example:
 *
 *     <core-iconset-svg id="my-svg-icons" iconSize="24">
 *       <svg>
 *         <defs>
 *           <g id="shape">
 *             <rect x="50" y="50" width="50" height="50" />
 *             <circle cx="50" cy="50" r="50" />
 *           </g>
 *         </defs>
 *       </svg>
 *     </core-iconset-svg>
 *
 * This will automatically register the icon set "my-svg-icons" to the iconset
 * database.  To use these icons from within another element, make a
 * `core-iconset` element and call the `byId` method
 * to retrieve a given iconset. To apply a particular icon inside an
 * element use the `applyIcon` method. For example:
 *
 *     iconset.applyIcon(iconNode, 'car');
 *
 * @element core-iconset-svg
 * @extends core-meta
 * @homepage github.io
 */
-->



<polymer-element name="core-iconset-svg" extends="core-meta" attributes="iconSize">

  <script>

    Polymer('core-iconset-svg', {


      /**
       * The size of an individual icon. Note that icons must be square.
       *
       * @attribute iconSize
       * @type number
       * @default 24
       */
      iconSize: 24,
      type: 'iconset',

      created: function() {
        this._icons = {};
      },

      ready: function() {
        this.super();
        this.updateIcons();
      },

      iconById: function(id) {
        return this._icons[id] || (this._icons[id] = this.querySelector('[id="' + id +'"]'));
      },

      cloneIcon: function(id) {
        var icon = this.iconById(id);
        if (icon) {
          var content = icon.cloneNode(true);
          content.removeAttribute('id');
          var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
          svg.setAttribute('viewBox', '0 0 ' + this.iconSize + ' ' +
              this.iconSize);
          // NOTE(dfreedm): work around https://crbug.com/370136
          svg.style.pointerEvents = 'none';
          svg.appendChild(content);
          return svg;
        }
      },

      get iconNames() {
        if (!this._iconNames) {
          this._iconNames = this.findIconNames();
        }
        return this._iconNames;
      },

      findIconNames: function() {
        var icons = this.querySelectorAll('[id]').array();
        if (icons.length) {
          return icons.map(function(n){ return n.id });
        }
      },

      /**
       * Applies an icon to the given element. The svg icon is added to the
       * element's shadowRoot if one exists or directly to itself.
       *
       * @method applyIcon
       * @param {Element} element The element to which the icon is
       * applied.
       * @param {String|Number} icon The name the icon to apply.
       * @return {Element} The icon element
       */
      applyIcon: function(element, icon) {
        var root = element;
        // remove old
        var old = root.querySelector('svg');
        if (old) {
          old.remove();
        }
        // install new
        var svg = this.cloneIcon(icon);
        if (!svg) {
          return;
        }
        svg.setAttribute('height', '100%');
        svg.setAttribute('width', '100%');
        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
        svg.style.display = 'block';
        root.insertBefore(svg, root.firstElementChild);
        return svg;
      },
      
      /**
       * Tell users of the iconset, that the set has loaded.
       * This finds all elements matching the selector argument and calls 
       * the method argument on them.
       * @method updateIcons
       * @param selector {string} css selector to identify iconset users, 
       * defaults to '[icon]'
       * @param method {string} method to call on found elements, 
       * defaults to 'updateIcon'
       */
      updateIcons: function(selector, method) {
        selector = selector || '[icon]';
        method = method || 'updateIcon';
        var deep = window.ShadowDOMPolyfill ? '' : 'html /deep/ ';
        var i$ = document.querySelectorAll(deep + selector);
        for (var i=0, e; e=i$[i]; i++) {
          if (e[method]) {
            e[method].call(e);
          }
        }
      }
      

    });

  </script>

</polymer-element>
<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<!--

`core-icons` is a utitliy import that includes the definition for the `core-icon` element, `core-iconset-svg` element, as well as an import for the default icon set.

The `core-icons` directory also includes imports for additional icon sets that can be loaded into your project.

Example loading icon set:

    <link rel="import" href="../core-icons/maps-icons.html">

To use an icon from one of these sets, first prefix your `core-icon` with the icon set name, followed by a colon, ":", and then the icon id.

Example using the directions-bus icon from the maps icon set:

    <core-icon icon="maps:directions-bus"></core-icon>


See [core-icon](#core-icon) for more information about working with icons.

See [core-iconset](#core-iconset) and [core-iconset-svg](#core-iconset-svg) for more information about how to create a custom iconset.

@group Polymer Core Elements
@element core-icons
@homepage polymer.github.io
-->


<core-iconset-svg id="icons" iconsize="24">
<svg><defs>
<g id="accessibility"><path d="M12 2c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm9 7h-6v13h-2v-6h-2v6h-2v-13h-6v-2h18v2z"></path></g>
<g id="account-balance"><path d="M4 10v7h3v-7h-3zm6 0v7h3v-7h-3zm-8 12h19v-3h-19v3zm14-12v7h3v-7h-3zm-4.5-9l-9.5 5v2h19v-2l-9.5-5z"></path></g>
<g id="account-balance-wallet"><path d="M21 18v1c0 1.1-.9 2-2 2h-14c-1.11 0-2-.9-2-2v-14c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10v-8h-10v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"></path></g>
<g id="account-box"><path d="M3 5v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-14c0-1.1-.9-2-2-2h-14c-1.11 0-2 .9-2 2zm12 4c0 1.66-1.34 3-3 3s-3-1.34-3-3 1.34-3 3-3 3 1.34 3 3zm-9 8c0-2 4-3.1 6-3.1s6 1.1 6 3.1v1h-12v-1z"></path></g>
<g id="account-child"><path d="M16.5 12c1.38 0 2.49-1.12 2.49-2.5s-1.11-2.5-2.49-2.5c-1.38 0-2.5 1.12-2.5 2.5s1.12 2.5 2.5 2.5zm-7.5-1c1.66 0 2.99-1.34 2.99-3s-1.33-3-2.99-3c-1.66 0-3 1.34-3 3s1.34 3 3 3zm7.5 3c-1.83 0-5.5.92-5.5 2.75v2.25h11v-2.25c0-1.83-3.67-2.75-5.5-2.75zm-7.5-1c-2.33 0-7 1.17-7 3.5v2.5h7v-2.25c0-.85.33-2.34 2.37-3.47-.87-.18-1.71-.28-2.37-.28z"></path></g>
<g id="account-circle"><path d="M12 2c-5.52 0-10 4.48-10 10s4.48 10 10 10 10-4.48 10-10-4.48-10-10-10zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2c-2.5 0-4.71-1.28-6-3.22.03-1.99 4-3.08 6-3.08 1.99 0 5.97 1.09 6 3.08-1.29 1.94-3.5 3.22-6 3.22z"></path></g>
<g id="add-box"><path d="M19 3h-14c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-14c0-1.1-.9-2-2-2zm-2 10h-4v4h-2v-4h-4v-2h4v-4h2v4h4v2z"></path></g>
<g id="add-circle-outline"><path d="M13 7h-2v4h-4v2h4v4h2v-4h4v-2h-4v-4zm-1-5c-5.52 0-10 4.48-10 10s4.48 10 10 10 10-4.48 10-10-4.48-10-10-10zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"></path></g>
<g id="add-circle"><path d="M12 2c-5.52 0-10 4.48-10 10s4.48 10 10 10 10-4.48 10-10-4.48-10-10-10zm5 11h-4v4h-2v-4h-4v-2h4v-4h2v4h4v2z"></path></g>
<g id="add"><path d="M19 13h-6v6h-2v-6h-6v-2h6v-6h2v6h6v2z"></path></g>
<g id="add-shopping-cart"><path d="M11 9h2v-3h3v-2h-3v-3h-2v3h-3v2h3v3zm-4 9c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2 2-.9 2-2-.9-2-2-2zm10 0c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2 2-.9 2-2-.9-2-2-2zm-9.83-3.25l.03-.12.9-1.63h7.45c.75 0 1.41-.41 1.75-1.03l3.86-7.01-1.74-.96h-.01l-1.1 2-2.76 5h-7.02l-.13-.27-2.24-4.73-.95-2-.94-2h-3.27v2h2l3.6 7.59-1.35 2.45c-.16.28-.25.61-.25.96 0 1.1.9 2 2 2h12v-2h-11.58c-.13 0-.25-.11-.25-.25z"></path></g>
<g id="alarm-add"><path d="M7.88 3.39l-1.28-1.53-4.6 3.85 1.29 1.53 4.59-3.85zm14.12 2.33l-4.6-3.86-1.29 1.53 4.6 3.86 1.29-1.53zm-10-1.72c-4.97 0-9 4.03-9 9s4.02 9 9 9c4.97 0 9-4.03 9-9s-4.03-9-9-9zm0 16c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7zm1-11h-2v3h-3v2h3v3h2v-3h3v-2h-3v-3z"></path></g>
<g id="alarm-off"><path d="M12 6c3.87 0 7 3.13 7 7 0 .84-.16 1.65-.43 2.4l1.52 1.52c.58-1.19.91-2.51.91-3.92 0-4.97-4.03-9-9-9-1.41 0-2.73.33-3.92.91l1.52 1.52c.75-.27 1.56-.43 2.4-.43zm10-.28l-4.6-3.86-1.29 1.53 4.6 3.86 1.29-1.53zm-19.08-3.43l-1.27 1.28 1.33 1.33-1.11.93 1.42 1.42 1.11-.94.8.8c-1.37 1.58-2.2 3.64-2.2 5.89 0 4.97 4.02 9 9 9 2.25 0 4.31-.83 5.89-2.2l2.2 2.2 1.27-1.27-17.47-17.46-.97-.98zm13.55 16.1c-1.21 1-2.77 1.61-4.47 1.61-3.87 0-7-3.13-7-7 0-1.7.61-3.26 1.61-4.47l9.86 9.86zm-8.45-15.11l-1.42-1.42-.86.71 1.42 1.42.86-.71z"></path></g>
<g id="alarm-on"><path d="M22 5.72l-4.6-3.86-1.29 1.53 4.6 3.86 1.29-1.53zm-14.12-2.33l-1.28-1.53-4.6 3.85 1.29 1.53 4.59-3.85zm4.12.61c-4.97 0-9 4.03-9 9s4.02 9 9 9c4.97 0 9-4.03 9-9s-4.03-9-9-9zm0 16c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7zm-1.46-5.47l-2.13-2.13-1.06 1.06 3.18 3.18 6-6-1.06-1.06-4.93 4.95z"></path></g>
<g id="alarm"><path d="M22 5.72l-4.6-3.86-1.29 1.53 4.6 3.86 1.29-1.53zm-14.12-2.33l-1.28-1.53-4.6 3.85 1.29 1.53 4.59-3.85zm4.62 4.61h-1.5v6l4.75 2.85.75-1.23-4-2.37v-5.25zm-.5-4c-4.97 0-9 4.03-9 9s4.02 9 9 9c4.97 0 9-4.03 9-9s-4.03-9-9-9zm0 16c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"></path></g>
<g id="android"><path d="M6 18c0 .55.45 1 1 1h1v3.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5v-3.5h2v3.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5v-3.5h1c.55 0 1-.45 1-1v-10h-12v10zm-2.5-10c-.83 0-1.5.67-1.5 1.5v7c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5v-7c0-.83-.67-1.5-1.5-1.5zm17 0c-.83 0-1.5.67-1.5 1.5v7c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5v-7c0-.83-.67-1.5-1.5-1.5zm-4.97-5.84l1.3-1.3c.2-.2.2-.51 0-.71-.2-.2-.51-.2-.71 0l-1.48 1.48c-.79-.4-1.69-.63-2.64-.63-.96 0-1.86.23-2.66.63l-1.49-1.48c-.2-.2-.51-.2-.71 0-.2.2-.2.51 0 .71l1.31 1.31c-1.48 1.09-2.45 2.84-2.45 4.83h12c0-1.99-.97-3.75-2.47-4.84zm-5.53 2.84h-1v-1h1v1zm5 0h-1v-1h1v1z"></path></g>
<g id="announcement"><path d="M20 2h-16c-1.1 0-1.99.9-1.99 2l-.01 18 4-4h14c1.1 0 2-.9 2-2v-12c0-1.1-.9-2-2-2zm-7 9h-2v-6h2v6zm0 4h-2v-2h2v2z"></path></g>
<g id="apps"><path d="M4 8h4v-4h-4v4zm6 12h4v-4h-4v4zm-6 0h4v-4h-4v4zm0-6h4v-4h-4v4zm6 0h4v-4h-4v4zm6-10v4h4v-4h-4zm-6 4h4v-4h-4v4zm6 6h4v-4h-4v4zm0 6h4v-4h-4v4z"></path></g>
<g id="archive"><path d="M20.54 5.23l-1.39-1.68c-.27-.34-.68-.55-1.15-.55h-12c-.47 0-.88.21-1.16.55l-1.38 1.68c-.29.34-.46.79-.46 1.27v12.5c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-12.5c0-.48-.17-.93-.46-1.27zm-8.54 12.27l-5.5-5.5h3.5v-2h4v2h3.5l-5.5 5.5zm-6.88-12.5l.81-1h12l.94 1h-13.75z"></path></g>
<g id="arrow-back"><path d="M20 11h-12.17l5.59-5.59-1.42-1.41-8 8 8 8 1.41-1.41-5.58-5.59h12.17v-2z"></path></g>
<g id="arrow-drop-down-circle"><path d="M12 2c-5.52 0-10 4.48-10 10s4.48 10 10 10 10-4.48 10-10-4.48-10-10-10zm0 12l-4-4h8l-4 4z"></path></g>
<g id="arrow-drop-down"><path d="M7 10l5 5 5-5z"></path></g>
<g id="arrow-drop-up"><path d="M7 14l5-5 5 5z"></path></g>
<g id="arrow-forward"><path d="M12 4l-1.41 1.41 5.58 5.59h-12.17v2h12.17l-5.58 5.59 1.41 1.41 8-8z"></path></g>
<g id="aspect-ratio"><path d="M19 12h-2v3h-3v2h5v-5zm-12-3h3v-2h-5v5h2v-3zm14-6h-18c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2v-14c0-1.1-.9-2-2-2zm0 16.01h-18v-14.02h18v14.02z"></path></g>
<g id="assessment"><path d="M19 3h-14c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-14c0-1.1-.9-2-2-2zm-10 14h-2v-7h2v7zm4 0h-2v-10h2v10zm4 0h-2v-4h2v4z"></path></g>
<g id="assignment-ind"><path d="M19 3h-4.18c-.42-1.16-1.52-2-2.82-2-1.3 0-2.4.84-2.82 2h-4.18c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-14c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm0 4c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm6 12h-12v-1.4c0-2 4-3.1 6-3.1s6 1.1 6 3.1v1.4z"></path></g>
<g id="assignment-late"><path d="M19 3h-4.18c-.42-1.16-1.52-2-2.82-2-1.3 0-2.4.84-2.82 2h-4.18c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-14c0-1.1-.9-2-2-2zm-6 15h-2v-2h2v2zm0-4h-2v-6h2v6zm-1-9c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z"></path></g>
<g id="assignment"><path d="M19 3h-4.18c-.42-1.16-1.52-2-2.82-2-1.3 0-2.4.84-2.82 2h-4.18c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-14c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm2 14h-7v-2h7v2zm3-4h-10v-2h10v2zm0-4h-10v-2h10v2z"></path></g>
<g id="assignment-returned"><path d="M19 3h-4.18c-.42-1.16-1.52-2-2.82-2-1.3 0-2.4.84-2.82 2h-4.18c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-14c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm0 15l-5-5h3v-4h4v4h3l-5 5z"></path></g>
<g id="assignment-return"><path d="M19 3h-4.18c-.42-1.16-1.52-2-2.82-2-1.3 0-2.4.84-2.82 2h-4.18c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-14c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm4 12h-4v3l-5-5 5-5v3h4v4z"></path></g>
<g id="assignment-turned-in"><path d="M19 3h-4.18c-.42-1.16-1.52-2-2.82-2-1.3 0-2.4.84-2.82 2h-4.18c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-14c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm-2 14l-4-4 1.41-1.41 2.59 2.58 6.59-6.59 1.41 1.42-8 8z"></path></g>
<g id="attachment"><path d="M7.5 18c-3.04 0-5.5-2.46-5.5-5.5s2.46-5.5 5.5-5.5h10.5c2.21 0 4 1.79 4 4s-1.79 4-4 4h-8.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5h7.5v1.5h-7.5c-.55 0-1 .45-1 1s.45 1 1 1h8.5c1.38 0 2.5-1.12 2.5-2.5s-1.12-2.5-2.5-2.5h-10.5c-2.21 0-4 1.79-4 4s1.79 4 4 4h9.5v1.5h-9.5z"></path></g>
<g id="autorenew"><path d="M12 6v3l4-4-4-4v3c-4.42 0-8 3.58-8 8 0 1.57.46 3.03 1.24 4.26l1.46-1.46c-.45-.83-.7-1.79-.7-2.8 0-3.31 2.69-6 6-6zm6.76 1.74l-1.46 1.46c.44.84.7 1.79.7 2.8 0 3.31-2.69 6-6 6v-3l-4 4 4 4v-3c4.42 0 8-3.58 8-8 0-1.57-.46-3.03-1.24-4.26z"></path></g>
<g id="backspace"><path d="M22 3h-15c-.69 0-1.23.35-1.59.88l-5.41 8.12 5.41 8.11c.36.53.9.89 1.59.89h15c1.1 0 2-.9 2-2v-14c0-1.1-.9-2-2-2zm-3 12.59l-1.41 1.41-3.59-3.59-3.59 3.59-1.41-1.41 3.59-3.59-3.59-3.59 1.41-1.41 3.59 3.59 3.59-3.59 1.41 1.41-3.59 3.59 3.59 3.59z"></path></g>
<g id="backup"><path d="M19.35 10.04c-.68-3.45-3.71-6.04-7.35-6.04-2.89 0-5.4 1.64-6.65 4.04-3.01.32-5.35 2.87-5.35 5.96 0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zm-5.35 2.96v4h-4v-4h-3l5-5 5 5h-3z"></path></g>
<g id="block"><path d="M12 2c-5.52 0-10 4.48-10 10s4.48 10 10 10 10-4.48 10-10-4.48-10-10-10zm-8 10c0-4.42 3.58-8 8-8 1.85 0 3.55.63 4.9 1.69l-11.21 11.21c-1.06-1.35-1.69-3.05-1.69-4.9zm8 8c-1.85 0-3.55-.63-4.9-1.69l11.21-11.21c1.06 1.35 1.69 3.05 1.69 4.9 0 4.42-3.58 8-8 8z"></path></g>
<g id="bookmark-outline"><path d="M17 3h-10c-1.1 0-1.99.9-1.99 2l-.01 16 7-3 7 3v-16c0-1.1-.9-2-2-2zm0 15l-5-2.18-5 2.18v-13h10v13z"></path></g>
<g id="bookmark"><path d="M17 3h-10c-1.1 0-1.99.9-1.99 2l-.01 16 7-3 7 3v-16c0-1.1-.9-2-2-2z"></path></g>
<g id="book"><path d="M18 2h-12c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-16c0-1.1-.9-2-2-2zm-12 2h5v8l-2.5-1.5-2.5 1.5v-8z"></path></g>
<g id="bug-report"><path d="M20 8h-2.81c-.45-.78-1.07-1.45-1.82-1.96l1.63-1.63-1.41-1.41-2.17 2.17c-.46-.11-.93-.17-1.42-.17-.49 0-.96.06-1.41.17l-2.18-2.17-1.41 1.41 1.62 1.63c-.74.51-1.36 1.18-1.81 1.96h-2.81v2h2.09c-.05.33-.09.66-.09 1v1h-2v2h2v1c0 .34.04.67.09 1h-2.09v2h2.81c1.04 1.79 2.97 3 5.19 3s4.15-1.21 5.19-3h2.81v-2h-2.09c.05-.33.09-.66.09-1v-1h2v-2h-2v-1c0-.34-.04-.67-.09-1h2.09v-2zm-6 8h-4v-2h4v2zm0-4h-4v-2h4v2z"></path></g>
<g id="cached"><path d="M19 8l-4 4h3c0 3.31-2.69 6-6 6-1.01 0-1.97-.25-2.8-.7l-1.46 1.46c1.23.78 2.69 1.24 4.26 1.24 4.42 0 8-3.58 8-8h3l-4-4zm-13 4c0-3.31 2.69-6 6-6 1.01 0 1.97.25 2.8.7l1.46-1.46c-1.23-.78-2.69-1.24-4.26-1.24-4.42 0-8 3.58-8 8h-3l4 4 4-4h-3z"></path></g>
<g id="cancel"><path d="M12 2c-5.53 0-10 4.47-10 10s4.47 10 10 10 10-4.47 10-10-4.47-10-10-10zm5 13.59l-1.41 1.41-3.59-3.59-3.59 3.59-1.41-1.41 3.59-3.59-3.59-3.59 1.41-1.41 3.59 3.59 3.59-3.59 1.41 1.41-3.59 3.59 3.59 3.59z"></path></g>
<g id="check-box-outline-blank"><path d="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"></path></g>
<g id="check-box"><path d="M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"></path></g>
<g id="check"><path d="M9 16.17l-4.17-4.17-1.42 1.41 5.59 5.59 12-12-1.41-1.41z"></path></g>
<g id="chevron-left"><path d="M15.41 7.41l-1.41-1.41-6 6 6 6 1.41-1.41-4.58-4.59z"></path></g>
<g id="chevron-right"><path d="M10 6l-1.41 1.41 4.58 4.59-4.58 4.59 1.41 1.41 6-6z"></path></g>
<g id="class"><path d="M18 2h-12c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-16c0-1.1-.9-2-2-2zm-12 2h5v8l-2.5-1.5-2.5 1.5v-8z"></path></g>
<g id="clear"><path d="M19 6.41l-1.41-1.41-5.59 5.59-5.59-5.59-1.41 1.41 5.59 5.59-5.59 5.59 1.41 1.41 5.59-5.59 5.59 5.59 1.41-1.41-5.59-5.59z"></path></g>
<g id="close"><path d="M19 6.41l-1.41-1.41-5.59 5.59-5.59-5.59-1.41 1.41 5.59 5.59-5.59 5.59 1.41 1.41 5.59-5.59 5.59 5.59 1.41-1.41-5.59-5.59z"></path></g>
<g id="cloud-circle"><path d="M12 2c-5.52 0-10 4.48-10 10s4.48 10 10 10 10-4.48 10-10-4.48-10-10-10zm4.5 14h-8.5c-1.66 0-3-1.34-3-3s1.34-3 3-3l.14.01c.44-1.73 1.99-3.01 3.86-3.01 2.21 0 4 1.79 4 4h.5c1.38 0 2.5 1.12 2.5 2.5s-1.12 2.5-2.5 2.5z"></path></g>
<g id="cloud-done"><path d="M19.35 10.04c-.68-3.45-3.71-6.04-7.35-6.04-2.89 0-5.4 1.64-6.65 4.04-3.01.32-5.35 2.87-5.35 5.96 0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zm-9.35 6.96l-3.5-3.5 1.41-1.41 2.09 2.08 5.18-5.17 1.41 1.41-6.59 6.59z"></path></g>
<g id="cloud-download"><path d="M19.35 10.04c-.68-3.45-3.71-6.04-7.35-6.04-2.89 0-5.4 1.64-6.65 4.04-3.01.32-5.35 2.87-5.35 5.96 0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zm-2.35 2.96l-5 5-5-5h3v-4h4v4h3z"></path></g>
<g id="cloud-off"><path d="M19.35 10.04c-.68-3.45-3.71-6.04-7.35-6.04-1.48 0-2.85.43-4.01 1.17l1.46 1.46c.76-.4 1.63-.63 2.55-.63 3.04 0 5.5 2.46 5.5 5.5v.5h1.5c1.66 0 3 1.34 3 3 0 1.13-.64 2.11-1.56 2.62l1.45 1.45c1.27-.91 2.11-2.39 2.11-4.07 0-2.64-2.05-4.78-4.65-4.96zm-16.35-4.77l2.75 2.74c-3.19.14-5.75 2.76-5.75 5.99 0 3.31 2.69 6 6 6h11.73l2 2 1.27-1.27-16.73-16.73-1.27 1.27zm4.73 4.73l8 8h-9.73c-2.21 0-4-1.79-4-4s1.79-4 4-4h1.73z"></path></g>
<g id="cloud"><path d="M19.35 10.04c-.68-3.45-3.71-6.04-7.35-6.04-2.89 0-5.4 1.64-6.65 4.04-3.01.32-5.35 2.87-5.35 5.96 0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96z"></path></g>
<g id="cloud-queue"><path d="M19.35 10.04c-.68-3.45-3.71-6.04-7.35-6.04-2.89 0-5.4 1.64-6.65 4.04-3.01.32-5.35 2.87-5.35 5.96 0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zm-.35 7.96h-13c-2.21 0-4-1.79-4-4s1.79-4 4-4h.71c.66-2.31 2.77-4 5.29-4 3.04 0 5.5 2.46 5.5 5.5v.5h1.5c1.66 0 3 1.34 3 3s-1.34 3-3 3z"></path></g>
<g id="cloud-upload"><path d="M19.35 10.04c-.68-3.45-3.71-6.04-7.35-6.04-2.89 0-5.4 1.64-6.65 4.04-3.01.32-5.35 2.87-5.35 5.96 0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zm-5.35 2.96v4h-4v-4h-3l5-5 5 5h-3z"></path></g>
<g id="content-copy"><path d="M16 1h-12c-1.1 0-2 .9-2 2v14h2v-14h12v-2zm3 4h-11c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2v-14c0-1.1-.9-2-2-2zm0 16h-11v-14h11v14z"></path></g>
<g id="content-cut"><path d="M9.64 7.64c.23-.5.36-1.05.36-1.64 0-2.21-1.79-4-4-4s-4 1.79-4 4 1.79 4 4 4c.59 0 1.14-.13 1.64-.36l2.36 2.36-2.36 2.36c-.5-.23-1.05-.36-1.64-.36-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4c0-.59-.13-1.14-.36-1.64l2.36-2.36 7 7h3v-1l-12.36-12.36zm-3.64.36c-1.1 0-2-.89-2-2s.9-2 2-2 2 .89 2 2-.9 2-2 2zm0 12c-1.1 0-2-.89-2-2s.9-2 2-2 2 .89 2 2-.9 2-2 2zm6-7.5c-.28 0-.5-.22-.5-.5s.22-.5.5-.5.5.22.5.5-.22.5-.5.5zm7-9.5l-6 6 2 2 7-7v-1z"></path></g>
<g id="content-paste"><path d="M19 2h-4.18c-.42-1.16-1.52-2-2.82-2-1.3 0-2.4.84-2.82 2h-4.18c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-16c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm7 18h-14v-16h2v3h10v-3h2v16z"></path></g>
<g id="create"><path d="M3 17.25v3.75h3.75l11.06-11.06-3.75-3.75-11.06 11.06zm17.71-10.21c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"></path></g>
<g id="credit-card"><path d="M4 12h16v6h-16z"></path><path d="M20 4h-16c-1.11 0-1.99.89-1.99 2l-.01 12c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2v-12c0-1.11-.89-2-2-2zm0 14h-16v-6h16v6zm0-10h-16v-2h16v2z"></path></g>
<g id="dashboard"><path d="M3 13h8v-10h-8v10zm0 8h8v-6h-8v6zm10 0h8v-10h-8v10zm0-18v6h8v-6h-8z"></path></g>
<g id="delete"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2v-12h-12v12zm13-15h-3.5l-1-1h-5l-1 1h-3.5v2h14v-2z"></path></g>
<g id="description"><path d="M14 2h-8c-1.1 0-1.99.9-1.99 2l-.01 16c0 1.1.89 2 1.99 2h12.01c1.1 0 2-.9 2-2v-12l-6-6zm2 16h-8v-2h8v2zm0-4h-8v-2h8v2zm-3-5v-5.5l5.5 5.5h-5.5z"></path></g>
<g id="developer-mode-tv"><path d="M4 5h16v2h2v-2c0-1.1-.9-2-2-2h-16c-1.1 0-2 .9-2 2v2h2v-2zm3.55 8.83l-2.83-2.83 2.83-2.83-1.41-1.41-4.25 4.24 4.24 4.24 1.42-1.41zm12.45 3.17h-16v-2h-2v2c0 1.1.9 2 2 2h4v2h8v-2h4c1.1 0 1.99-.9 1.99-2v-2h-1.99v2zm2-6.01l-4.24-4.24-1.41 1.41 2.82 2.84-2.83 2.83 1.41 1.41 4.25-4.23v-.02z"></path></g>
<g id="dns"><path d="M20 13h-16c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h16c.55 0 1-.45 1-1v-6c0-.55-.45-1-1-1zm-13 6c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm13-16h-16c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h16c.55 0 1-.45 1-1v-6c0-.55-.45-1-1-1zm-13 6c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"></path></g>
<g id="done-all"><path d="M18 7l-1.41-1.41-6.34 6.34 1.41 1.41 6.34-6.34zm4.24-1.41l-10.58 10.58-4.18-4.17-1.41 1.41 5.59 5.59 12-12-1.42-1.41zm-21.83 7.82l5.59 5.59 1.41-1.41-5.58-5.59-1.42 1.41z"></path></g>
<g id="done"><path d="M9 16.17l-4.17-4.17-1.42 1.41 5.59 5.59 12-12-1.41-1.41z"></path></g>
<g id="drafts"><path d="M21.99 8c0-.72-.37-1.35-.94-1.7l-9.05-5.3-9.05 5.3c-.57.35-.95.98-.95 1.7v10c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2l-.01-10zm-9.99 5l-8.26-5.16 8.26-4.84 8.26 4.84-8.26 5.16z"></path></g>
<g id="drawer"><path d="M20,4H4C2.8,4,2,4.8,2,6v12c0,1.2,0.8,2,2,2h16c1,0,2-0.8,2-2V6C22,4.8,21,4,20,4z M20,18h-6V6h6V18z"></path></g>
<g id="error"><path d="M12 2c-5.52 0-10 4.48-10 10s4.48 10 10 10 10-4.48 10-10-4.48-10-10-10zm1 15h-2v-2h2v2zm0-4h-2v-6h2v6z"></path></g>
<g id="event"><path d="M17 12h-5v5h5v-5zm-1-11v2h-8v-2h-2v2h-1c-1.11 0-1.99.9-1.99 2l-.01 14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-14c0-1.1-.9-2-2-2h-1v-2h-2zm3 18h-14v-11h14v11z"></path></g>
<g id="exit-to-app"><path d="M10.09 15.59l1.41 1.41 5-5-5-5-1.41 1.41 2.58 2.59h-9.67v2h9.67l-2.58 2.59zm8.91-12.59h-14c-1.11 0-2 .9-2 2v4h2v-4h14v14h-14v-4h-2v4c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-14c0-1.1-.9-2-2-2z"></path></g>
<g id="expand-less"><path d="M12 8l-6 6 1.41 1.41 4.59-4.58 4.59 4.58 1.41-1.41z"></path></g>
<g id="expand-more"><path d="M16.59 8.59l-4.59 4.58-4.59-4.58-1.41 1.41 6 6 6-6z"></path></g>
<g id="explore"><path d="M12 10.9c-.61 0-1.1.49-1.1 1.1s.49 1.1 1.1 1.1c.61 0 1.1-.49 1.1-1.1s-.49-1.1-1.1-1.1zm0-8.9c-5.52 0-10 4.48-10 10s4.48 10 10 10 10-4.48 10-10-4.48-10-10-10zm2.19 12.19l-8.19 3.81 3.81-8.19 8.19-3.81-3.81 8.19z"></path></g>
<g id="extension"><path d="M20.5 11h-1.5v-4c0-1.1-.9-2-2-2h-4v-1.5c0-1.38-1.12-2.5-2.5-2.5s-2.5 1.12-2.5 2.5v1.5h-4c-1.1 0-1.99.9-1.99 2v3.8h1.49c1.49 0 2.7 1.21 2.7 2.7s-1.21 2.7-2.7 2.7h-1.5v3.8c0 1.1.9 2 2 2h3.8v-1.5c0-1.49 1.21-2.7 2.7-2.7 1.49 0 2.7 1.21 2.7 2.7v1.5h3.8c1.1 0 2-.9 2-2v-4h1.5c1.38 0 2.5-1.12 2.5-2.5s-1.12-2.5-2.5-2.5z"></path></g>
<g id="face-unlock"><path d="M14.69 17.1c-.74.58-1.7.9-2.69.9s-1.95-.32-2.69-.9c-.22-.17-.53-.13-.7.09-.17.22-.13.53.09.7.91.72 2.09 1.11 3.3 1.11s2.39-.39 3.31-1.1c.22-.17.26-.48.09-.7-.17-.23-.49-.26-.71-.1z"></path><circle cx="8.5" cy="12.5" r="1"></circle><path d="M12 0c-6.63 0-12 5.37-12 12s5.37 12 12 12 12-5.37 12-12-5.37-12-12-12zm7.96 14.82c-1.09 3.74-4.27 6.46-8.04 6.46-3.78 0-6.96-2.72-8.04-6.47-1.19-.11-2.13-1.18-2.13-2.52 0-1.27.85-2.31 1.97-2.5 2.09-1.46 3.8-3.49 4.09-5.05v-.01c1.35 2.63 6.3 5.19 11.83 5.06l.3-.03c1.28 0 2.31 1.14 2.31 2.54 0 1.38-1.02 2.51-2.29 2.52z"></path><circle cx="15.5" cy="12.5" r="1"></circle></g>
<g id="favorite-outline"><path d="M16.5 3c-1.74 0-3.41.81-4.5 2.09-1.09-1.28-2.76-2.09-4.5-2.09-3.08 0-5.5 2.42-5.5 5.5 0 3.78 3.4 6.86 8.55 11.54l1.45 1.31 1.45-1.32c5.15-4.67 8.55-7.75 8.55-11.53 0-3.08-2.42-5.5-5.5-5.5zm-4.4 15.55l-.1.1-.1-.1c-4.76-4.31-7.9-7.16-7.9-10.05 0-2 1.5-3.5 3.5-3.5 1.54 0 3.04.99 3.57 2.36h1.87c.52-1.37 2.02-2.36 3.56-2.36 2 0 3.5 1.5 3.5 3.5 0 2.89-3.14 5.74-7.9 10.05z"></path></g>
<g id="favorite"><path d="M12 21.35l-1.45-1.32c-5.15-4.67-8.55-7.75-8.55-11.53 0-3.08 2.42-5.5 5.5-5.5 1.74 0 3.41.81 4.5 2.09 1.09-1.28 2.76-2.09 4.5-2.09 3.08 0 5.5 2.42 5.5 5.5 0 3.78-3.4 6.86-8.55 11.54l-1.45 1.31z"></path></g>
<g id="file-download"><path d="M19 9h-4v-6h-6v6h-4l7 7 7-7zm-14 9v2h14v-2h-14z"></path></g>
<g id="file-map"><path d="M12 6.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm7-5.5h-14c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-14c0-1.1-.9-2-2-2zm-6.5 16h-1c-.95-4.09-3.99-5.84-3.99-9 0-2.49 2-4.5 4.49-4.5s4.51 2.01 4.51 4.5c0 3.16-3.06 4.91-4.01 9z"></path></g>
<g id="file-upload"><path d="M9 16h6v-6h4l-7-7-7 7h4zm-4 2h14v2h-14z"></path></g>
<g id="filter-list"><path d="M10 18h4v-2h-4v2zm-7-12v2h18v-2h-18zm3 7h12v-2h-12v2z"></path></g>
<g id="find-in-page"><path d="M20 19.59v-11.59l-6-6h-8c-1.1 0-1.99.9-1.99 2l-.01 16c0 1.1.89 2 1.99 2h12.01c.45 0 .85-.15 1.19-.4l-4.43-4.43c-.8.52-1.74.83-2.76.83-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5c0 1.02-.31 1.96-.83 2.75l3.83 3.84zm-11-6.59c0 1.66 1.34 3 3 3s3-1.34 3-3-1.34-3-3-3-3 1.34-3 3z"></path></g>
<g id="find-replace"><path d="M11 6c1.38 0 2.63.56 3.54 1.46l-2.54 2.54h6v-6l-2.05 2.05c-1.27-1.27-3.02-2.05-4.95-2.05-3.53 0-6.43 2.61-6.92 6h2.02c.46-2.28 2.48-4 4.9-4zm5.64 9.14c.66-.9 1.12-1.97 1.28-3.14h-2.02c-.46 2.28-2.48 4-4.9 4-1.38 0-2.63-.56-3.54-1.46l2.54-2.54h-6v6l2.05-2.05c1.27 1.27 3.02 2.05 4.95 2.05 1.55 0 2.98-.51 4.14-1.36l4.86 4.85 1.49-1.49-4.85-4.86z"></path></g>
<g id="flag"><path d="M14.4 6l-.4-2h-9v17h2v-7h5.6l.4 2h7v-10z"></path></g>
<g id="flip-to-back"><path d="M9 7h-2v2h2v-2zm0 4h-2v2h2v-2zm0-8c-1.11 0-2 .9-2 2h2v-2zm4 12h-2v2h2v-2zm6-12v2h2c0-1.1-.9-2-2-2zm-6 0h-2v2h2v-2zm-4 14v-2h-2c0 1.1.89 2 2 2zm10-4h2v-2h-2v2zm0-4h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm-14-10h-2v12c0 1.1.89 2 2 2h12v-2h-12v-12zm10-2h2v-2h-2v2zm0 12h2v-2h-2v2z"></path></g>
<g id="flip-to-front"><path d="M3 13h2v-2h-2v2zm0 4h2v-2h-2v2zm2 4v-2h-2c0 1.1.89 2 2 2zm-2-12h2v-2h-2v2zm12 12h2v-2h-2v2zm4-18h-10c-1.11 0-2 .9-2 2v10c0 1.1.89 2 2 2h10c1.1 0 2-.9 2-2v-10c0-1.1-.9-2-2-2zm0 12h-10v-10h10v10zm-8 6h2v-2h-2v2zm-4 0h2v-2h-2v2z"></path></g>
<g id="folder-open"><path d="M20 6h-8l-2-2h-6c-1.1 0-1.99.9-1.99 2l-.01 12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2v-10c0-1.1-.9-2-2-2zm0 12h-16v-10h16v10z"></path></g>
<g id="folder"><path d="M10 4h-6c-1.1 0-1.99.9-1.99 2l-.01 12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2v-10c0-1.1-.9-2-2-2h-8l-2-2z"></path></g>
<g id="folder-shared"><path d="M20 6h-8l-2-2h-6c-1.1 0-1.99.9-1.99 2l-.01 12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2v-10c0-1.1-.9-2-2-2zm-5 3c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm4 8h-8v-1c0-1.33 2.67-2 4-2s4 .67 4 2v1z"></path></g>
<g id="forward"><path d="M12 8v-4l8 8-8 8v-4h-8v-8z"></path></g>
<g id="fullscreen-exit"><path d="M5 16h3v3h2v-5h-5v2zm3-8h-3v2h5v-5h-2v3zm6 11h2v-3h3v-2h-5v5zm2-11v-3h-2v5h5v-2h-3z"></path></g>
<g id="fullscreen"><path d="M7 14h-2v5h5v-2h-3v-3zm-2-4h2v-3h3v-2h-5v5zm12 7h-3v2h5v-5h-2v3zm-3-12v2h3v3h2v-5h-5z"></path></g>
<g id="gesture"><path d="M4.59 6.89c.7-.71 1.4-1.35 1.71-1.22.5.2 0 1.03-.3 1.52-.25.42-2.86 3.89-2.86 6.31 0 1.28.48 2.34 1.34 2.98.75.56 1.74.73 2.64.46 1.07-.31 1.95-1.4 3.06-2.77 1.21-1.49 2.83-3.44 4.08-3.44 1.63 0 1.65 1.01 1.76 1.79-3.78.64-5.38 3.67-5.38 5.37 0 1.7 1.44 3.09 3.21 3.09 1.63 0 4.29-1.33 4.69-6.1h2.46v-2.5h-2.47c-.15-1.65-1.09-4.2-4.03-4.2-2.25 0-4.18 1.91-4.94 2.84-.58.73-2.06 2.48-2.29 2.72-.25.3-.68.84-1.11.84-.45 0-.72-.83-.36-1.92.35-1.09 1.4-2.86 1.85-3.52.78-1.14 1.3-1.92 1.3-3.28 0-2.17-1.64-2.86-2.51-2.86-1.32 0-2.47 1-2.72 1.25-.36.36-.66.66-.88.93l1.75 1.71zm9.29 11.66c-.31 0-.74-.26-.74-.72 0-.6.73-2.2 2.87-2.76-.3 2.69-1.43 3.48-2.13 3.48z"></path></g>
<g id="get-app"><path d="M19 9h-4v-6h-6v6h-4l7 7 7-7zm-14 9v2h14v-2h-14z"></path></g>
<g id="grade"><path d="M12 17.27l6.18 3.73-1.64-7.03 5.46-4.73-7.19-.61-2.81-6.63-2.81 6.63-7.19.61 5.46 4.73-1.64 7.03z"></path></g>
<g id="group-work"><path d="M12 2c-5.52 0-10 4.48-10 10s4.48 10 10 10 10-4.48 10-10-4.48-10-10-10zm-4 15.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5zm1.5-9.5c0-1.38 1.12-2.5 2.5-2.5s2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5-2.5-1.12-2.5-2.5zm6.5 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"></path></g>
<g id="help"><path d="M12 2c-5.52 0-10 4.48-10 10s4.48 10 10 10 10-4.48 10-10-4.48-10-10-10zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92c-.72.73-1.17 1.33-1.17 2.83h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2h-2c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"></path></g>
<g id="highlight-remove"><path d="M14.59 8l-2.59 2.59-2.59-2.59-1.41 1.41 2.59 2.59-2.59 2.59 1.41 1.41 2.59-2.59 2.59 2.59 1.41-1.41-2.59-2.59 2.59-2.59-1.41-1.41zm-2.59-6c-5.53 0-10 4.47-10 10s4.47 10 10 10 10-4.47 10-10-4.47-10-10-10zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"></path></g>
<g id="history"><path opacity=".9" d="M13 3c-4.97 0-9 4.03-9 9h-3l3.89 3.89.07.14 4.04-4.03h-3c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42c1.63 1.63 3.87 2.64 6.36 2.64 4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08v-4.25h-1.5z"></path></g>
<g id="home"><path d="M10 20v-6h4v6h5v-8h3l-10-9-10 9h3v8z"></path></g>
<g id="https"><path d="M18 8h-1v-2c0-2.76-2.24-5-5-5s-5 2.24-5 5v2h-1c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9h-6.2v-2c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"></path></g>
<g id="inbox"><path d="M19 3h-14.01c-1.1 0-1.98.9-1.98 2l-.01 14c0 1.1.89 2 1.99 2h14.01c1.1 0 2-.9 2-2v-14c0-1.1-.9-2-2-2zm0 12h-4c0 1.66-1.34 3-3 3s-3-1.34-3-3h-4.01v-10h14.01v10zm-3-5h-2v-3h-4v3h-2l4 4 4-4z"></path></g>
<g id="info-outline"><path d="M11 17h2v-6h-2v6zm1-15c-5.52 0-10 4.48-10 10s4.48 10 10 10 10-4.48 10-10-4.48-10-10-10zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-11h2v-2h-2v2z"></path></g>
<g id="info"><path d="M12 2c-5.52 0-10 4.48-10 10s4.48 10 10 10 10-4.48 10-10-4.48-10-10-10zm1 15h-2v-6h2v6zm0-8h-2v-2h2v2z"></path></g>
<g id="input"><path d="M21 3.01h-18c-1.1 0-2 .9-2 2v3.99h2v-4.01h18v14.03h-18v-4.02h-2v4.01c0 1.1.9 1.98 2 1.98h18c1.1 0 2-.88 2-1.98v-14c0-1.11-.9-2-2-2zm-10 12.99l4-4-4-4v3h-10v2h10v3z"></path></g>
<g id="invert-colors"><path d="M17.66 7.93l-5.66-5.66-5.66 5.66c-3.12 3.12-3.12 8.19 0 11.31 1.56 1.56 3.61 2.34 5.66 2.34 2.05 0 4.1-.78 5.66-2.34 3.12-3.12 3.12-8.19 0-11.31zm-5.66 11.66c-1.6 0-3.11-.62-4.24-1.76-1.14-1.14-1.76-2.64-1.76-4.24s.62-3.11 1.76-4.24l4.24-4.25v14.49z"></path></g>
<g id="label-outline"><path d="M17.63 5.84c-.36-.51-.96-.84-1.63-.84l-11 .01c-1.1 0-2 .89-2 1.99v10c0 1.1.9 1.99 2 1.99l11 .01c.67 0 1.27-.33 1.63-.84l4.37-6.16-4.37-6.16zm-1.63 11.16h-11v-10h11l3.55 5-3.55 5z"></path></g>
<g id="label"><path d="M17.63 5.84c-.36-.51-.96-.84-1.63-.84l-11 .01c-1.1 0-2 .89-2 1.99v10c0 1.1.9 1.99 2 1.99l11 .01c.67 0 1.27-.33 1.63-.84l4.37-6.16-4.37-6.16z"></path></g>
<g id="language"><path d="M11.99 2c-5.52 0-9.99 4.48-9.99 10s4.47 10 9.99 10c5.53 0 10.01-4.48 10.01-10s-4.48-10-10.01-10zm6.93 6h-2.95c-.32-1.25-.78-2.45-1.38-3.56 1.84.63 3.37 1.91 4.33 3.56zm-6.92-3.96c.83 1.2 1.48 2.53 1.91 3.96h-3.82c.43-1.43 1.08-2.76 1.91-3.96zm-7.74 9.96c-.16-.64-.26-1.31-.26-2s.1-1.36.26-2h3.38c-.08.66-.14 1.32-.14 2 0 .68.06 1.34.14 2h-3.38zm.82 2h2.95c.32 1.25.78 2.45 1.38 3.56-1.84-.63-3.37-1.9-4.33-3.56zm2.95-8h-2.95c.96-1.66 2.49-2.93 4.33-3.56-.6 1.11-1.06 2.31-1.38 3.56zm3.97 11.96c-.83-1.2-1.48-2.53-1.91-3.96h3.82c-.43 1.43-1.08 2.76-1.91 3.96zm2.34-5.96h-4.68c-.09-.66-.16-1.32-.16-2 0-.68.07-1.35.16-2h4.68c.09.65.16 1.32.16 2 0 .68-.07 1.34-.16 2zm.25 5.56c.6-1.11 1.06-2.31 1.38-3.56h2.95c-.96 1.65-2.49 2.93-4.33 3.56zm1.77-5.56c.08-.66.14-1.32.14-2 0-.68-.06-1.34-.14-2h3.38c.16.64.26 1.31.26 2s-.1 1.36-.26 2h-3.38z"></path></g>
<g id="launch"><path d="M19 19h-14v-14h7v-2h-7c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zm-5-16v2h3.59l-9.83 9.83 1.41 1.41 9.83-9.83v3.59h2v-7h-7z"></path></g>
<g id="link"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4v-1.9h-4c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9h-4c-1.71 0-3.1-1.39-3.1-3.1zm4.1 1h8v-2h-8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4v1.9h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"></path></g>
<g id="list"><path d="M3 13h2v-2h-2v2zm0 4h2v-2h-2v2zm0-8h2v-2h-2v2zm4 4h14v-2h-14v2zm0 4h14v-2h-14v2zm0-10v2h14v-2h-14z"></path></g>
<g id="lock-open"><path d="M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm6-9h-1v-2c0-2.76-2.24-5-5-5s-5 2.24-5 5h1.9c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2h-9.1c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-10c0-1.1-.9-2-2-2zm0 12h-12v-10h12v10z"></path></g>
<g id="lock-outline"><path d="M18 8h-1v-2c0-2.76-2.24-5-5-5s-5 2.24-5 5v2h-1c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-10c0-1.1-.9-2-2-2zm-6-5.1c1.71 0 3.1 1.39 3.1 3.1v2h-6.1v-2h-.1c0-1.71 1.39-3.1 3.1-3.1zm6 17.1h-12v-10h12v10zm-6-3c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2z"></path></g>
<g id="lock"><path d="M18 8h-1v-2c0-2.76-2.24-5-5-5s-5 2.24-5 5v2h-1c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9h-6.2v-2c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"></path></g>
<g id="loyalty"><path d="M21.41 11.58l-9-9c-.36-.36-.86-.58-1.41-.58h-7c-1.1 0-2 .9-2 2v7c0 .55.22 1.05.59 1.42l9 9c.36.36.86.58 1.41.58.55 0 1.05-.22 1.41-.59l7-7c.37-.36.59-.86.59-1.41 0-.55-.23-1.06-.59-1.42zm-15.91-4.58c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm11.77 8.27l-4.27 4.27-4.27-4.27c-.45-.46-.73-1.08-.73-1.77 0-1.38 1.12-2.5 2.5-2.5.69 0 1.32.28 1.77.74l.73.72.73-.73c.45-.45 1.08-.73 1.77-.73 1.38 0 2.5 1.12 2.5 2.5 0 .69-.28 1.32-.73 1.77z"></path></g>
<g id="mail"><path d="M20 4h-16c-1.1 0-1.99.9-1.99 2l-.01 12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2v-12c0-1.1-.9-2-2-2zm0 4l-8 5-8-5v-2l8 5 8-5v2z"></path></g>
<g id="markunread-mailbox"><path d="M20 6h-10v6h-2v-8h6v-4h-8v6h-2c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2v-12c0-1.1-.9-2-2-2z"></path></g>
<g id="markunread"><path d="M20 4h-16c-1.1 0-1.99.9-1.99 2l-.01 12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2v-12c0-1.1-.9-2-2-2zm0 4l-8 5-8-5v-2l8 5 8-5v2z"></path></g>
<g id="menu"><path d="M3 18h18v-2h-18v2zm0-5h18v-2h-18v2zm0-7v2h18v-2h-18z"></path></g>
<g id="more-horiz"><path d="M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></g>
<g id="more-vert"><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></g>
<g id="note-add"><path d="M14 2h-8c-1.1 0-1.99.9-1.99 2l-.01 16c0 1.1.89 2 1.99 2h12.01c1.1 0 2-.9 2-2v-12l-6-6zm2 14h-3v3h-2v-3h-3v-2h3v-3h2v3h3v2zm-3-7v-5.5l5.5 5.5h-5.5z"></path></g>
<g id="open-in-browser"><path d="M19 4h-14c-1.11 0-2 .9-2 2v12c0 1.1.89 2 2 2h4v-2h-4v-10h14v10h-4v2h4c1.1 0 2-.9 2-2v-12c0-1.1-.89-2-2-2zm-7 6l-4 4h3v6h2v-6h3l-4-4z"></path></g>
<g id="open-in-new"><path d="M19 19h-14v-14h7v-2h-7c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zm-5-16v2h3.59l-9.83 9.83 1.41 1.41 9.83-9.83v3.59h2v-7h-7z"></path></g>
<g id="open-with"><path d="M10 9h4v-3h3l-5-5-5 5h3v3zm-1 1h-3v-3l-5 5 5 5v-3h3v-4zm14 2l-5-5v3h-3v4h3v3l5-5zm-9 3h-4v3h-3l5 5 5-5h-3v-3z"></path></g>
<g id="pageview"><path d="M11 8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3zm8-5h-14c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-14c0-1.1-.9-2-2-2zm-1.41 16l-3.83-3.83c-.8.52-1.74.83-2.76.83-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5c0 1.02-.31 1.96-.83 2.75l3.83 3.84-1.41 1.41z"></path></g>
<g id="payment"><path d="M20 4h-16c-1.11 0-1.99.89-1.99 2l-.01 12c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2v-12c0-1.11-.89-2-2-2zm0 14h-16v-6h16v6zm0-10h-16v-2h16v2z"></path></g>
<g id="perm-camera-mic"><path d="M20 5h-3.17l-1.83-2h-6l-1.83 2h-3.17c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h7v-2.09c-2.83-.48-5-2.94-5-5.91h2c0 2.21 1.79 4 4 4s4-1.79 4-4h2c0 2.97-2.17 5.43-5 5.91v2.09h7c1.1 0 2-.9 2-2v-12c0-1.1-.9-2-2-2zm-6 8c0 1.1-.9 2-2 2s-2-.9-2-2v-4c0-1.1.9-2 2-2s2 .9 2 2v4z"></path></g>
<g id="perm-contact-cal"><path d="M19 3h-1v-2h-2v2h-8v-2h-2v2h-1c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-14c0-1.1-.9-2-2-2zm-7 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm6 12h-12v-1c0-2 4-3.1 6-3.1s6 1.1 6 3.1v1z"></path></g>
<g id="perm-data-setting"><path d="M18.99 11.5c.34 0 .67.03 1 .07l.01-11.57-20 20h11.56c-.04-.33-.07-.66-.07-1 0-4.14 3.36-7.5 7.5-7.5zm3.71 7.99c.02-.16.04-.32.04-.49 0-.17-.01-.33-.04-.49l1.06-.83c.09-.08.12-.21.06-.32l-1-1.73c-.06-.11-.19-.15-.31-.11l-1.24.5c-.26-.2-.54-.37-.85-.49l-.19-1.32c-.01-.12-.12-.21-.24-.21h-2c-.12 0-.23.09-.25.21l-.19 1.32c-.3.13-.59.29-.85.49l-1.24-.5c-.11-.04-.24 0-.31.11l-1 1.73c-.06.11-.04.24.06.32l1.06.83c-.02.16-.03.32-.03.49 0 .17.01.33.03.49l-1.06.83c-.09.08-.12.21-.06.32l1 1.73c.06.11.19.15.31.11l1.24-.5c.26.2.54.37.85.49l.19 1.32c.02.12.12.21.25.21h2c.12 0 .23-.09.25-.21l.19-1.32c.3-.13.59-.29.84-.49l1.25.5c.11.04.24 0 .31-.11l1-1.73c.06-.11.03-.24-.06-.32l-1.07-.83zm-3.71 1.01c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"></path></g>
<g id="perm-device-info"><path d="M13 7h-2v2h2v-2zm0 4h-2v6h2v-6zm4-9.99l-10-.01c-1.1 0-2 .9-2 2v18c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2v-18c0-1.1-.9-1.99-2-1.99zm0 17.99h-10v-14h10v14z"></path></g>
<g id="perm-identity"><path d="M12 5.9c1.16 0 2.1.94 2.1 2.1s-.94 2.1-2.1 2.1-2.1-.94-2.1-2.1.94-2.1 2.1-2.1m0 9c2.97 0 6.1 1.46 6.1 2.1v1.1h-12.2v-1.1c0-.64 3.13-2.1 6.1-2.1m0-10.9c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 9c-2.67 0-8 1.34-8 4v3h16v-3c0-2.66-5.33-4-8-4z"></path></g>
<g id="perm-media"><path d="M2 6h-2v5h.01l-.01 9c0 1.1.9 2 2 2h18v-2h-18v-14zm20-2h-8l-2-2h-6c-1.1 0-1.99.9-1.99 2l-.01 12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2v-10c0-1.1-.9-2-2-2zm-15 11l4.5-6 3.5 4.51 2.5-3.01 3.5 4.5h-14z"></path></g>
<g id="perm-phone-msg"><path d="M20 15.5c-1.25 0-2.45-.2-3.57-.57-.35-.11-.74-.03-1.02.24l-2.2 2.2c-2.83-1.44-5.15-3.75-6.59-6.58l2.2-2.21c.28-.27.36-.66.25-1.01-.37-1.12-.57-2.32-.57-3.57 0-.55-.45-1-1-1h-3.5c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.5c0-.55-.45-1-1-1zm-8-12.5v10l3-3h6v-7h-9z"></path></g>
<g id="perm-scan-wifi"><path d="M12 3c-5.05 0-8.85 1.85-12 4.23l12 14.77 12-14.75c-3.15-2.38-6.95-4.25-12-4.25zm1 13h-2v-6h2v6zm-2-8v-2h2v2h-2z"></path></g>
<g id="picture-in-picture"><path d="M19 7h-8v6h8v-6zm2-4h-18c-1.1 0-2 .9-2 2v14c0 1.1.9 1.98 2 1.98h18c1.1 0 2-.88 2-1.98v-14c0-1.1-.9-2-2-2zm0 16.01h-18v-14.03h18v14.03z"></path></g>
<g id="polymer"><path d="M19 4h-4l-7.89 12.63-2.61-4.63 4.5-8h-4l-4.5 8 4.5 8h4l7.89-12.63 2.61 4.63-4.5 8h4l4.5-8z"></path></g>
<g id="print"><path d="M19 8h-14c-1.66 0-3 1.34-3 3v6h4v4h12v-4h4v-6c0-1.66-1.34-3-3-3zm-3 11h-8v-5h8v5zm3-7c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm-1-9h-12v4h12v-4z"></path></g>
<g id="query-builder"><path d="M11.99 2c-5.52 0-9.99 4.48-9.99 10s4.47 10 9.99 10c5.53 0 10.01-4.48 10.01-10s-4.48-10-10.01-10zm.01 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"></path><path d="M12.5 7h-1.5v6l5.25 3.15.75-1.23-4.5-2.67z"></path></g>
<g id="question-answer"><path d="M21 6h-2v9h-13v2c0 .55.45 1 1 1h11l4 4v-15c0-.55-.45-1-1-1zm-4 6v-9c0-.55-.45-1-1-1h-13c-.55 0-1 .45-1 1v14l4-4h10c.55 0 1-.45 1-1z"></path></g>
<g id="radio-button-off"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"></path></g>
<g id="radio-button-on"><path d="M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zm0-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"></path></g>
<g id="receipt"><path d="M18 17h-12v-2h12v2zm0-4h-12v-2h12v2zm0-4h-12v-2h12v2zm-15 13l1.5-1.5 1.5 1.5 1.5-1.5 1.5 1.5 1.5-1.5 1.5 1.5 1.5-1.5 1.5 1.5 1.5-1.5 1.5 1.5 1.5-1.5 1.5 1.5v-20l-1.5 1.5-1.5-1.5-1.5 1.5-1.5-1.5-1.5 1.5-1.5-1.5-1.5 1.5-1.5-1.5-1.5 1.5-1.5-1.5-1.5 1.5-1.5-1.5v20z"></path></g>
<g id="redeem"><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68c-.54-.8-1.45-1.34-2.5-1.34-1.66 0-3 1.34-3 3 0 .35.07.69.18 1h-2.18c-1.11 0-1.99.89-1.99 2l-.01 11c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2v-11c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm-6 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15h-16v-2h16v2zm0-5h-16v-6h5.08l-2.08 2.83 1.62 1.17 2.38-3.24 1-1.36 1 1.36 2.38 3.24 1.62-1.17-2.08-2.83h5.08v6z"></path></g>
<g id="redo"><path d="M18.4 10.6c-1.85-1.61-4.25-2.6-6.9-2.6-4.65 0-8.58 3.03-9.96 7.22l2.36.78c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88l-3.62 3.62h9v-9l-3.6 3.6z"></path></g>
<g id="refresh"><path d="M17.65 6.35c-1.45-1.45-3.44-2.35-5.65-2.35-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78l-3.22 3.22h7v-7l-2.35 2.35z"></path></g>
<g id="remove-circle-outline"><path d="M7 11v2h10v-2h-10zm5-9c-5.52 0-10 4.48-10 10s4.48 10 10 10 10-4.48 10-10-4.48-10-10-10zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"></path></g>
<g id="remove-circle"><path d="M12 2c-5.52 0-10 4.48-10 10s4.48 10 10 10 10-4.48 10-10-4.48-10-10-10zm5 11h-10v-2h10v2z"></path></g>
<g id="remove"><path d="M19 13h-14v-2h14v2z"></path></g>
<g id="reorder"><path d="M3,15h18v-2H3V15z M3,19h18v-2H3V19z M3,11h18V9H3V11z M3,5v2h18V5H3z"></path></g>
<g id="reply-all"><path d="M7 8v-3l-7 7 7 7v-3l-4-4 4-4zm6 1v-4l-7 7 7 7v-4.1c5 0 8.5 1.6 11 5.1-1-5-4-10-11-11z"></path></g>
<g id="reply"><path d="M10 9v-4l-7 7 7 7v-4.1c5 0 8.5 1.6 11 5.1-1-5-4-10-11-11z"></path></g>
<g id="report"><path d="M15.73 3h-7.46l-5.27 5.27v7.46l5.27 5.27h7.46l5.27-5.27v-7.46l-5.27-5.27zm-3.73 14.3c-.72 0-1.3-.58-1.3-1.3 0-.72.58-1.3 1.3-1.3.72 0 1.3.58 1.3 1.3 0 .72-.58 1.3-1.3 1.3zm1-4.3h-2v-6h2v6z"></path></g>
<g id="report-problem"><path d="M1 21h22l-11-19-11 19zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"></path></g>
<g id="restore"><path d="M13 3c-4.97 0-9 4.03-9 9h-3l3.89 3.89.07.14 4.04-4.03h-3c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42c1.63 1.63 3.87 2.64 6.36 2.64 4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08v-4.25h-1.5z"></path></g>
<g id="room"><path d="M12 2c-3.87 0-7 3.13-7 7 0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"></path></g>
<g id="rotation-3d"><path d="M7.52 21.48c-3.27-1.54-5.61-4.72-5.97-8.48h-1.5c.51 6.16 5.66 11 11.95 11l.66-.03-3.81-3.81-1.33 1.32zm.89-6.52c-.19 0-.37-.03-.52-.08-.16-.06-.29-.13-.4-.24-.11-.1-.2-.22-.26-.37-.06-.14-.09-.3-.09-.47h-1.3c0 .36.07.68.21.95.14.27.33.5.56.69.24.18.51.32.82.41.3.1.62.15.96.15.37 0 .72-.05 1.03-.15.32-.1.6-.25.83-.44s.42-.43.55-.72c.13-.29.2-.61.2-.97 0-.19-.02-.38-.07-.56-.05-.18-.12-.35-.23-.51-.1-.16-.24-.3-.4-.43-.17-.13-.37-.23-.61-.31.2-.09.37-.2.52-.33.15-.13.27-.27.37-.42.1-.15.17-.3.22-.46.05-.16.07-.32.07-.48 0-.36-.06-.68-.18-.96-.12-.28-.29-.51-.51-.69-.2-.19-.47-.33-.77-.43-.31-.09-.65-.14-1.02-.14-.36 0-.69.05-1 .16-.3.11-.57.26-.79.45-.21.19-.38.41-.51.67-.12.26-.18.54-.18.85h1.3c0-.17.03-.32.09-.45s.14-.25.25-.34c.11-.09.23-.17.38-.22.15-.05.3-.08.48-.08.4 0 .7.1.89.31.19.2.29.49.29.86 0 .18-.03.34-.08.49-.05.15-.14.27-.25.37-.11.1-.25.18-.41.24-.16.06-.36.09-.58.09h-.77v1.03h.77c.22 0 .42.02.6.07s.33.13.45.23c.12.11.22.24.29.4.07.16.1.35.1.57 0 .41-.12.72-.35.93-.23.23-.55.33-.95.33zm8.55-5.92c-.32-.33-.7-.59-1.14-.77-.43-.18-.92-.27-1.46-.27h-2.36v8h2.3c.55 0 1.06-.09 1.51-.27.45-.18.84-.43 1.16-.76.32-.33.57-.73.74-1.19.17-.47.26-.99.26-1.57v-.4c0-.58-.09-1.1-.26-1.57-.18-.47-.43-.87-.75-1.2zm-.39 3.16c0 .42-.05.79-.14 1.13-.1.33-.24.62-.43.85-.19.23-.43.41-.71.53-.29.12-.62.18-.99.18h-.91v-5.77h.97c.72 0 1.27.23 1.64.69.38.46.57 1.12.57 1.99v.4zm-4.57-12.2l-.66.03 3.81 3.81 1.33-1.33c3.27 1.55 5.61 4.72 5.96 8.48h1.5c-.5-6.15-5.65-10.99-11.94-10.99z"></path></g>
<g id="save"><path d="M17 3h-12c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-12l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10h-10v-4h10v4z"></path></g>
<g id="schedule"><path fill-opacity=".9" d="M11.99 2c-5.52 0-9.99 4.48-9.99 10s4.47 10 9.99 10c5.53 0 10.01-4.48 10.01-10s-4.48-10-10.01-10zm.01 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"></path><path fill-opacity=".9" d="M12.5 7h-1.5v6l5.25 3.15.75-1.23-4.5-2.67z"></path></g>
<g id="search"><path d="M15.5 14h-.79l-.28-.27c.98-1.14 1.57-2.62 1.57-4.23 0-3.59-2.91-6.5-6.5-6.5s-6.5 2.91-6.5 6.5 2.91 6.5 6.5 6.5c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99 1.49-1.49-4.99-5zm-6 0c-2.49 0-4.5-2.01-4.5-4.5s2.01-4.5 4.5-4.5 4.5 2.01 4.5 4.5-2.01 4.5-4.5 4.5z"></path></g>
<g id="select-all"><path d="M3 5h2v-2c-1.1 0-2 .9-2 2zm0 8h2v-2h-2v2zm4 8h2v-2h-2v2zm-4-12h2v-2h-2v2zm10-6h-2v2h2v-2zm6 0v2h2c0-1.1-.9-2-2-2zm-14 18v-2h-2c0 1.1.9 2 2 2zm-2-4h2v-2h-2v2zm6-14h-2v2h2v-2zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2v-2h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2v-2h-2v2zm-8 12h10v-10h-10v10zm2-8h6v6h-6v-6z"></path></g>
<g id="send-money"><path d="M2 12c0-2.61 1.67-4.83 4-5.65v-2.09c-3.45.89-6 4.01-6 7.74s2.55 6.85 6 7.74v-2.09c-2.33-.82-4-3.04-4-5.65zm22 0l-4-4v3h-7v2h7v3l4-4zm-10 6c-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.16.67 4.24 1.76l1.42-1.41c-1.45-1.45-3.45-2.35-5.66-2.35-4.42 0-8 3.58-8 8s3.58 8 8 8c2.21 0 4.21-.9 5.66-2.34l-1.42-1.41c-1.08 1.08-2.58 1.75-4.24 1.75z"></path></g>
<g id="send"><path d="M2.01 21l20.99-9-20.99-9-.01 7 15 2-15 2z"></path></g>
<g id="settings-applications"><path d="M12 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm7-7h-14c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2v-14c0-1.1-.89-2-2-2zm-1.75 9c0 .23-.02.46-.05.68l1.48 1.16c.13.11.17.3.08.45l-1.4 2.42c-.09.15-.27.21-.43.15l-1.74-.7c-.36.28-.76.51-1.18.69l-.26 1.85c-.03.17-.18.3-.35.3h-2.8c-.17 0-.32-.13-.35-.29l-.26-1.85c-.43-.18-.82-.41-1.18-.69l-1.74.7c-.16.06-.34 0-.43-.15l-1.4-2.42c-.09-.15-.05-.34.08-.45l1.48-1.16c-.03-.23-.05-.46-.05-.69 0-.23.02-.46.05-.68l-1.48-1.16c-.13-.11-.17-.3-.08-.45l1.4-2.42c.09-.15.27-.21.43-.15l1.74.7c.36-.28.76-.51 1.18-.69l.26-1.85c.03-.17.18-.3.35-.3h2.8c.17 0 .32.13.35.29l.26 1.85c.43.18.82.41 1.18.69l1.74-.7c.16-.06.34 0 .43.15l1.4 2.42c.09.15.05.34-.08.45l-1.48 1.16c.03.23.05.46.05.69z"></path></g>
<g id="settings-backup-restore"><path d="M14 12c0-1.1-.9-2-2-2s-2 .9-2 2 .9 2 2 2 2-.9 2-2zm-2-9c-4.97 0-9 4.03-9 9h-3l4 4 4-4h-3c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.51 0-2.91-.49-4.06-1.3l-1.42 1.44c1.52 1.16 3.42 1.86 5.48 1.86 4.97 0 9-4.03 9-9s-4.03-9-9-9z"></path></g>
<g id="settings-bluetooth"><path d="M11 24h2v-2h-2v2zm-4 0h2v-2h-2v2zm8 0h2v-2h-2v2zm2.71-18.29l-5.71-5.71h-1v7.59l-4.59-4.59-1.41 1.41 5.59 5.59-5.59 5.59 1.41 1.41 4.59-4.59v7.59h1l5.71-5.71-4.3-4.29 4.3-4.29zm-4.71-1.88l1.88 1.88-1.88 1.88v-3.76zm1.88 10.46l-1.88 1.88v-3.76l1.88 1.88z"></path></g>
<g id="settings-cell"><path d="M7 24h2v-2h-2v2zm4 0h2v-2h-2v2zm4 0h2v-2h-2v2zm1-23.99l-8-.01c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2v-16c0-1.1-.9-1.99-2-1.99zm0 15.99h-8v-12h8v12z"></path></g>
<g id="settings-display"><path d="M21 3h-18c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2v-14c0-1.1-.9-2-2-2zm0 16.01h-18v-14.02h18v14.02zm-13-3.01h2.5l1.5 1.5 1.5-1.5h2.5v-2.5l1.5-1.5-1.5-1.5v-2.5h-2.5l-1.5-1.5-1.5 1.5h-2.5v2.5l-1.5 1.5 1.5 1.5v2.5zm4-7c1.66 0 3 1.34 3 3s-1.34 3-3 3v-6z"></path></g>
<g id="settings-ethernet"><path d="M7.77 6.76l-1.54-1.28-5.41 6.52 5.41 6.52 1.54-1.28-4.35-5.24 4.35-5.24zm-.77 6.24h2v-2h-2v2zm10-2h-2v2h2v-2zm-6 2h2v-2h-2v2zm6.77-7.52l-1.54 1.28 4.35 5.24-4.35 5.24 1.54 1.28 5.41-6.52-5.41-6.52z"></path></g>
<g id="settings-input-antenna"><path d="M12 5c-3.87 0-7 3.13-7 7h2c0-2.76 2.24-5 5-5s5 2.24 5 5h2c0-3.87-3.13-7-7-7zm1 9.29c.88-.39 1.5-1.26 1.5-2.29 0-1.38-1.12-2.5-2.5-2.5s-2.5 1.12-2.5 2.5c0 1.02.62 1.9 1.5 2.29v3.3l-3.41 3.41 1.41 1.41 3-3 3 3 1.41-1.41-3.41-3.41v-3.3zm-1-13.29c-6.07 0-11 4.93-11 11h2c0-4.97 4.03-9 9-9s9 4.03 9 9h2c0-6.07-4.93-11-11-11z"></path></g>
<g id="settings-input-component"><path d="M5 2c0-.55-.45-1-1-1s-1 .45-1 1v4h-2v6h6v-6h-2v-4zm4 14c0 1.3.84 2.4 2 2.82v4.18h2v-4.18c1.16-.41 2-1.51 2-2.82v-2h-6v2zm-8 0c0 1.3.84 2.4 2 2.82v4.18h2v-4.18c1.16-.42 2-1.52 2-2.82v-2h-6v2zm20-10v-4c0-.55-.45-1-1-1s-1 .45-1 1v4h-2v6h6v-6h-2zm-8-4c0-.55-.45-1-1-1s-1 .45-1 1v4h-2v6h6v-6h-2v-4zm4 14c0 1.3.84 2.4 2 2.82v4.18h2v-4.18c1.16-.41 2-1.51 2-2.82v-2h-6v2z"></path></g>
<g id="settings-input-composite"><path d="M5 2c0-.55-.45-1-1-1s-1 .45-1 1v4h-2v6h6v-6h-2v-4zm4 14c0 1.3.84 2.4 2 2.82v4.18h2v-4.18c1.16-.41 2-1.51 2-2.82v-2h-6v2zm-8 0c0 1.3.84 2.4 2 2.82v4.18h2v-4.18c1.16-.42 2-1.52 2-2.82v-2h-6v2zm20-10v-4c0-.55-.45-1-1-1s-1 .45-1 1v4h-2v6h6v-6h-2zm-8-4c0-.55-.45-1-1-1s-1 .45-1 1v4h-2v6h6v-6h-2v-4zm4 14c0 1.3.84 2.4 2 2.82v4.18h2v-4.18c1.16-.41 2-1.51 2-2.82v-2h-6v2z"></path></g>
<g id="settings-input-hdmi"><path d="M18 7v-3c0-1.1-.9-2-2-2h-8c-1.1 0-2 .9-2 2v3h-1v6l3 6v3h8v-3l3-6v-6h-1zm-10-3h8v3h-2v-2h-1v2h-2v-2h-1v2h-2v-3z"></path></g>
<g id="settings-input-svideo"><path d="M8 11.5c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5.67 1.5 1.5 1.5 1.5-.67 1.5-1.5zm7-5c0-.83-.67-1.5-1.5-1.5h-3c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5h3c.83 0 1.5-.67 1.5-1.5zm-6.5 8.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm3.5-14c-6.07 0-11 4.93-11 11s4.93 11 11 11 11-4.93 11-11-4.93-11-11-11zm0 20c-4.96 0-9-4.04-9-9s4.04-9 9-9 9 4.04 9 9-4.04 9-9 9zm5.5-11c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm-2 5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z"></path></g>
<g id="settings-overscan"><path d="M12.01 5.5l-2.01 2.5h4l-1.99-2.5zm5.99 4.5v4l2.5-1.99-2.5-2.01zm-12 0l-2.5 2.01 2.5 1.99v-4zm8 6h-4l2.01 2.5 1.99-2.5zm7-13h-18c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2v-14c0-1.1-.9-2-2-2zm0 16.01h-18v-14.02h18v14.02z"></path></g>
<g id="settings"><path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65c-.03-.24-.24-.42-.49-.42h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zm-7.43 2.52c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"></path></g>
<g id="settings-phone"><path d="M13 9h-2v2h2v-2zm4 0h-2v2h2v-2zm3 6.5c-1.25 0-2.45-.2-3.57-.57-.35-.11-.74-.03-1.02.24l-2.2 2.2c-2.83-1.44-5.15-3.75-6.59-6.58l2.2-2.21c.28-.27.36-.66.25-1.01-.37-1.12-.57-2.32-.57-3.57 0-.55-.45-1-1-1h-3.5c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.5c0-.55-.45-1-1-1zm-1-6.5v2h2v-2h-2z"></path></g>
<g id="settings-power"><path d="M7 24h2v-2h-2v2zm4 0h2v-2h-2v2zm2-22h-2v10h2v-10zm3.56 2.44l-1.45 1.45c1.73 1.05 2.89 2.94 2.89 5.11 0 3.31-2.69 6-6 6s-6-2.69-6-6c0-2.17 1.16-4.06 2.88-5.12l-1.44-1.44c-2.08 1.44-3.44 3.84-3.44 6.56 0 4.42 3.58 8 8 8s8-3.58 8-8c0-2.72-1.36-5.12-3.44-6.56zm-1.56 19.56h2v-2h-2v2z"></path></g>
<g id="settings-remote"><path d="M15 9h-6c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h6c.55 0 1-.45 1-1v-12c0-.55-.45-1-1-1zm-3 6c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm-4.95-8.95l1.41 1.41c.91-.9 2.16-1.46 3.54-1.46s2.63.56 3.54 1.46l1.41-1.41c-1.27-1.27-3.02-2.05-4.95-2.05s-3.68.78-4.95 2.05zm4.95-6.05c-3.04 0-5.79 1.23-7.78 3.22l1.41 1.41c1.63-1.62 3.88-2.63 6.37-2.63s4.74 1.01 6.36 2.64l1.41-1.41c-1.98-2-4.73-3.23-7.77-3.23z"></path></g>
<g id="settings-voice"><path d="M7 24h2v-2h-2v2zm5-11c1.66 0 2.99-1.34 2.99-3l.01-6c0-1.66-1.34-3-3-3s-3 1.34-3 3v6c0 1.66 1.34 3 3 3zm-1 11h2v-2h-2v2zm4 0h2v-2h-2v2zm4-14h-1.7c0 3-2.54 5.1-5.3 5.1s-5.3-2.1-5.3-5.1h-1.7c0 3.41 2.72 6.23 6 6.72v3.28h2v-3.28c3.28-.49 6-3.31 6-6.72z"></path></g>
<g id="shop"><path d="M16 6v-2c0-1.11-.89-2-2-2h-4c-1.11 0-2 .89-2 2v2h-6v13c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2v-13h-6zm-6-2h4v2h-4v-2zm-1 14v-9l7.5 4-7.5 5z"></path></g>
<g id="shopping-basket"><path d="M17.21 9l-4.38-6.56c-.19-.28-.51-.42-.83-.42-.32 0-.64.14-.83.43l-4.38 6.55h-4.79c-.55 0-1 .45-1 1 0 .09.01.18.04.27l2.54 9.27c.23.84 1 1.46 1.92 1.46h13c.92 0 1.69-.62 1.93-1.46l2.54-9.27.03-.27c0-.55-.45-1-1-1h-4.79zm-8.21 0l3-4.4 3 4.4h-6zm3 8c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"></path></g>
<g id="shopping-cart"><path d="M7 18c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2 2-.9 2-2-.9-2-2-2zm-6-16v2h2l3.6 7.59-1.35 2.45c-.16.28-.25.61-.25.96 0 1.1.9 2 2 2h12v-2h-11.58c-.14 0-.25-.11-.25-.25l.03-.12.9-1.63h7.45c.75 0 1.41-.41 1.75-1.03l3.58-6.49c.08-.14.12-.31.12-.48 0-.55-.45-1-1-1h-14.79l-.94-2h-3.27zm16 16c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2 2-.9 2-2-.9-2-2-2z"></path></g>
<g id="shop-two"><path d="M3 9h-2v11c0 1.11.89 2 2 2h14c1.11 0 2-.89 2-2h-16v-11zm15-4v-2c0-1.11-.89-2-2-2h-4c-1.11 0-2 .89-2 2v2h-5v11c0 1.11.89 2 2 2h14c1.11 0 2-.89 2-2v-11h-5zm-6-2h4v2h-4v-2zm0 12v-7l5.5 3-5.5 4z"></path></g>
<g id="sort"><path d="M3 18h6v-2h-6v2zm0-12v2h18v-2h-18zm0 7h12v-2h-12v2z"></path></g>
<g id="speaker-notes"><path d="M20 2h-16c-1.1 0-1.99.9-1.99 2l-.01 18 4-4h14c1.1 0 2-.9 2-2v-12c0-1.1-.9-2-2-2zm-12 12h-2v-2h2v2zm0-3h-2v-2h2v2zm0-3h-2v-2h2v2zm7 6h-5v-2h5v2zm3-3h-8v-2h8v2zm0-3h-8v-2h8v2z"></path></g>
<g id="spellcheck"><path d="M12.45 16h2.09l-5.11-13h-1.86l-5.11 13h2.09l1.12-3h5.64l1.14 3zm-6.02-5l2.07-5.52 2.07 5.52h-4.14zm15.16.59l-8.09 8.09-3.67-3.68-1.41 1.41 5.09 5.09 9.49-9.5-1.41-1.41z"></path></g>
<g id="star-half"><path d="M22 9.74l-7.19-.62L12 2.5 9.19 9.13 2 9.74l5.46 4.73-1.64 7.03L12 17.77l6.18 3.73-1.63-7.03L22 9.74zM12 15.9V6.6l1.71 4.04 4.38.38-3.32 2.88 1 4.28L12 15.9z"></path></g>
<g id="star-outline"><path d="M22 9.24l-7.19-.62L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21 12 17.27 18.18 21l-1.63-7.03L22 9.24zM12 15.4l-3.76 2.27 1-4.28-3.32-2.88 4.38-.38L12 6.1l1.71 4.04 4.38.38-3.32 2.88 1 4.28L12 15.4z"></path></g>
<g id="star"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"></path></g>
<g id="star-rate"><path d="M12 14.3l3.71 2.7-1.42-4.36 3.71-2.64h-4.55l-1.45-4.5-1.45 4.5h-4.55l3.71 2.64-1.42 4.36z"></path></g>
<g id="stars"><path d="M11.99 2c-5.52 0-9.99 4.48-9.99 10s4.47 10 9.99 10c5.53 0 10.01-4.48 10.01-10s-4.48-10-10.01-10zm4.24 16l-4.23-2.55-4.23 2.55 1.12-4.81-3.73-3.23 4.92-.42 1.92-4.54 1.92 4.53 4.92.42-3.73 3.23 1.12 4.82z"></path></g>
<g id="store"><path d="M20 4h-16v2h16v-2zm1 10v-2l-1-5h-16l-1 5v2h1v6h10v-6h4v6h2v-6h1zm-9 4h-6v-4h6v4z"></path></g>
<g id="subject"><path d="M14 17h-10v2h10v-2zm6-8h-16v2h16v-2zm-16 6h16v-2h-16v2zm0-10v2h16v-2h-16z"></path></g>
<g id="supervisor-account"><circle cx="12" cy="13.49" r="1.5"></circle><path d="M12 2c-5.52 0-10 4.48-10 10s4.48 10 10 10 10-4.48 10-10-4.48-10-10-10zm0 2.5c1.24 0 2.25 1.01 2.25 2.25s-1.01 2.25-2.25 2.25-2.25-1.01-2.25-2.25 1.01-2.25 2.25-2.25zm5 10.56v2.5c-.45.41-.96.77-1.5 1.05v-.68c0-.34-.17-.65-.46-.92-.65-.62-1.89-1.02-3.04-1.02-.96 0-1.96.28-2.65.73l-.17.12-.21.17c.78.47 1.63.72 2.54.82l1.33.15c.37.04.66.36.66.75 0 .29-.16.53-.4.66-.28.15-.64.09-.95.09-.35 0-.69-.01-1.03-.05-.5-.06-.99-.17-1.46-.33-.49-.16-.97-.38-1.42-.64-.22-.13-.44-.27-.65-.43l-.31-.24c-.04-.02-.28-.18-.28-.23v-4.28c0-1.58 2.63-2.78 5-2.78s5 1.2 5 2.78v1.78z"></path></g>
<g id="swap-horiz"><path d="M6.99 11l-3.99 4 3.99 4v-3h7.01v-2h-7.01v-3zm14.01-2l-3.99-4v3h-7.01v2h7.01v3l3.99-4z"></path></g>
<g id="swap-vert-circle"><path d="M12 2c-5.52 0-10 4.48-10 10s4.48 10 10 10 10-4.48 10-10-4.48-10-10-10zm-5.5 7l3.5-3.5 3.5 3.5h-2.5v4h-2v-4h-2.5zm11 6l-3.5 3.5-3.5-3.5h2.5v-4h2v4h2.5z"></path></g>
<g id="swap-vert"><path d="M16 17.01v-7.01h-2v7.01h-3l4 3.99 4-3.99h-3zm-7-14.01l-4 3.99h3v7.01h2v-7.01h3l-4-3.99z"></path></g>
<g id="system-update-tv"><path d="M12 16.5l4-4h-3v-9h-2v9h-3l4 4zm9-13h-6v1.99h6v14.03h-18v-14.03h6v-1.99h-6c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2v-14c0-1.1-.9-2-2-2z"></path></g>
<g id="tab"><path d="M21 3h-18c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2v-14c0-1.1-.9-2-2-2zm0 16h-18v-14h10v4h8v10z"></path></g>
<g id="tab-unselected"><path d="M1 9h2v-2h-2v2zm0 4h2v-2h-2v2zm0-8h2v-2c-1.1 0-2 .9-2 2zm8 16h2v-2h-2v2zm-8-4h2v-2h-2v2zm2 4v-2h-2c0 1.1.9 2 2 2zm18-18h-8v6h10v-4c0-1.1-.9-2-2-2zm0 14h2v-2h-2v2zm-12-12h2v-2h-2v2zm-4 16h2v-2h-2v2zm0-16h2v-2h-2v2zm16 16c1.1 0 2-.9 2-2h-2v2zm0-8h2v-2h-2v2zm-8 8h2v-2h-2v2zm4 0h2v-2h-2v2z"></path></g>
<g id="text-format"><path d="M5 17v2h14v-2h-14zm4.5-4.2h5l.9 2.2h2.1l-4.75-11h-1.5l-4.75 11h2.1l.9-2.2zm2.5-6.82l1.87 5.02h-3.74l1.87-5.02z"></path></g>
<g id="theaters"><path d="M18 3v2h-2v-2h-8v2h-2v-2h-2v18h2v-2h2v2h8v-2h2v2h2v-18h-2zm-10 14h-2v-2h2v2zm0-4h-2v-2h2v2zm0-4h-2v-2h2v2zm10 8h-2v-2h2v2zm0-4h-2v-2h2v2zm0-4h-2v-2h2v2z"></path></g>
<g id="thumb-down"><path d="M15 3h-9c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v1.91l.01.01-.01.08c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06l1.06 1.05 6.59-6.59c.36-.36.58-.86.58-1.41v-10c0-1.1-.9-2-2-2zm4 0v12h4v-12h-4z"></path></g>
<g id="thumbs-up-down"><path d="M12 6c0-.55-.45-1-1-1h-5.18l.66-3.18.02-.23c0-.31-.13-.59-.33-.8l-.79-.79-4.94 4.94c-.27.27-.44.65-.44 1.06v6.5c0 .83.67 1.5 1.5 1.5h6.75c.62 0 1.15-.38 1.38-.91l2.26-5.29c.07-.17.11-.36.11-.55v-1.25zm10.5 4h-6.75c-.62 0-1.15.38-1.38.91l-2.26 5.29c-.07.17-.11.36-.11.55v1.25c0 .55.45 1 1 1h5.18l-.66 3.18-.02.24c0 .31.13.59.33.8l.79.78 4.94-4.94c.27-.27.44-.65.44-1.06v-6.5c0-.83-.67-1.5-1.5-1.5z"></path></g>
<g id="thumb-up"><path d="M1 21h4v-12h-4v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06l-1.06-1.05-6.58 6.59c-.37.36-.59.86-.59 1.41v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-1.91l-.01-.01.01-.08z"></path></g>
<g id="toc"><path d="M3 9h14v-2h-14v2zm0 4h14v-2h-14v2zm0 4h14v-2h-14v2zm16 0h2v-2h-2v2zm0-10v2h2v-2h-2zm0 6h2v-2h-2v2z"></path></g>
<g id="today"><path d="M19 3h-1v-2h-2v2h-8v-2h-2v2h-1c-1.11 0-1.99.9-1.99 2l-.01 14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-14c0-1.1-.9-2-2-2zm0 16h-14v-11h14v11zm-12-9h5v5h-5z"></path></g>
<g id="track-changes"><path d="M19.07 4.93l-1.41 1.41c1.44 1.45 2.34 3.45 2.34 5.66 0 4.42-3.58 8-8 8s-8-3.58-8-8c0-4.08 3.05-7.44 7-7.93v2.02c-2.84.48-5 2.94-5 5.91 0 3.31 2.69 6 6 6s6-2.69 6-6c0-1.66-.67-3.16-1.76-4.24l-1.41 1.41c.72.73 1.17 1.73 1.17 2.83 0 2.21-1.79 4-4 4s-4-1.79-4-4c0-1.86 1.28-3.41 3-3.86v2.14c-.6.35-1 .98-1 1.72 0 1.1.9 2 2 2s2-.9 2-2c0-.74-.4-1.38-1-1.72v-8.28h-1c-5.52 0-10 4.48-10 10s4.48 10 10 10 10-4.48 10-10c0-2.76-1.12-5.26-2.93-7.07z"></path></g>
<g id="translate"><path d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53h2.93v-2h-7v-2h-2v2h-7v1.99h11.17c-.67 1.93-1.73 3.76-3.17 5.36-.93-1.03-1.7-2.16-2.31-3.35h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02 1.42 1.42 5-5 3.11 3.11.76-2.04zm5.63-5.07h-2l-4.5 12h2l1.12-3h4.75l1.13 3h2l-4.5-12zm-2.62 7l1.62-4.33 1.62 4.33h-3.24z"></path></g>
<g id="trending-down"><path d="M16 18l2.29-2.29-4.88-4.88-4 4-7.41-7.42 1.41-1.41 6 6 4-4 6.3 6.29 2.29-2.29v6z"></path></g>
<g id="trending-neutral"><path d="M22 12l-4-4v3h-15v2h15v3z"></path></g>
<g id="trending-up"><path d="M16 6l2.29 2.29-4.88 4.88-4-4-7.41 7.42 1.41 1.41 6-6 4 4 6.3-6.29 2.29 2.29v-6z"></path></g>
<g id="turned-in-not"><path d="M17 3h-10c-1.1 0-1.99.9-1.99 2l-.01 16 7-3 7 3v-16c0-1.1-.9-2-2-2zm0 15l-5-2.18-5 2.18v-13h10v13z"></path></g>
<g id="turned-in"><path d="M17 3h-10c-1.1 0-1.99.9-1.99 2l-.01 16 7-3 7 3v-16c0-1.1-.9-2-2-2z"></path></g>
<g id="undo"><path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6l-3.6-3.6v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78c-1.39-4.19-5.32-7.22-9.97-7.22z"></path></g>
<g id="unfold-less"><path d="M7.41 18.59l1.42 1.41 3.17-3.17 3.17 3.17 1.41-1.41-4.58-4.59-4.59 4.59zm9.18-13.18l-1.42-1.41-3.17 3.17-3.17-3.17-1.42 1.41 4.59 4.59 4.59-4.59z"></path></g>
<g id="unfold-more"><path d="M12 5.83l3.17 3.17 1.41-1.41-4.58-4.59-4.59 4.59 1.42 1.41 3.17-3.17zm0 12.34l-3.17-3.17-1.41 1.41 4.58 4.59 4.59-4.59-1.42-1.41-3.17 3.17z"></path></g>
<g id="verified-user"><path d="M12 1l-9 4v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12v-6l-9-4zm-2 16l-4-4 1.41-1.41 2.59 2.58 6.59-6.59 1.41 1.42-8 8z"></path></g>
<g id="view-agenda"><path d="M20 13h-17c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h17c.55 0 1-.45 1-1v-6c0-.55-.45-1-1-1zm0-10h-17c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h17c.55 0 1-.45 1-1v-6c0-.55-.45-1-1-1z"></path></g>
<g id="view-array"><path d="M4 18h3v-13h-3v13zm14-13v13h3v-13h-3zm-10 13h9v-13h-9v13z"></path></g>
<g id="view-carousel"><path d="M7 19h10v-15h-10v15zm-5-2h4v-11h-4v11zm16-11v11h4v-11h-4z"></path></g>
<g id="view-column"><path d="M10 18h5v-13h-5v13zm-6 0h5v-13h-5v13zm12-13v13h5v-13h-5z"></path></g>
<g id="view-day"><path d="M2 21h19v-3h-19v3zm18-13h-17c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h17c.55 0 1-.45 1-1v-6c0-.55-.45-1-1-1zm-18-5v3h19v-3h-19z"></path></g>
<g id="view-headline"><path d="M4 15h17v-2h-17v2zm0 4h17v-2h-17v2zm0-8h17v-2h-17v2zm0-6v2h17v-2h-17z"></path></g>
<g id="view-list"><path d="M4 14h4v-4h-4v4zm0 5h4v-4h-4v4zm0-10h4v-4h-4v4zm5 5h12v-4h-12v4zm0 5h12v-4h-12v4zm0-14v4h12v-4h-12z"></path></g>
<g id="view-module"><path d="M4 11h5v-6h-5v6zm0 7h5v-6h-5v6zm6 0h5v-6h-5v6zm6 0h5v-6h-5v6zm-6-7h5v-6h-5v6zm6-6v6h5v-6h-5z"></path></g>
<g id="view-quilt"><path d="M10 18h5v-6h-5v6zm-6 0h5v-13h-5v13zm12 0h5v-6h-5v6zm-6-13v6h11v-6h-11z"></path></g>
<g id="view-stream"><path d="M4 18h17v-6h-17v6zm0-13v6h17v-6h-17z"></path></g>
<g id="view-week"><path d="M6 5h-3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-12c0-.55-.45-1-1-1zm14 0h-3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-12c0-.55-.45-1-1-1zm-7 0h-3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-12c0-.55-.45-1-1-1z"></path></g>
<g id="visibility-off"><path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16c.57-.23 1.18-.36 1.83-.36zm-10-2.73l2.28 2.28.46.46c-1.66 1.29-2.96 3.01-3.74 4.99 1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42 2.93 2.92 1.27-1.27-17.73-17.73-1.27 1.27zm5.53 5.53l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"></path></g>
<g id="visibility"><path d="M12 4.5c-5 0-9.27 3.11-11 7.5 1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zm0 12.5c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"></path></g>
<g id="wallet-giftcard"><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68c-.54-.8-1.45-1.34-2.5-1.34-1.66 0-3 1.34-3 3 0 .35.07.69.18 1h-2.18c-1.11 0-1.99.89-1.99 2l-.01 11c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2v-11c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm-6 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15h-16v-2h16v2zm0-5h-16v-6h5.08l-2.08 2.83 1.62 1.17 2.38-3.24 1-1.36 1 1.36 2.38 3.24 1.62-1.17-2.08-2.83h5.08v6z"></path></g>
<g id="wallet-membership"><path d="M20 2h-16c-1.11 0-2 .89-2 2v11c0 1.11.89 2 2 2h4v5l4-2 4 2v-5h4c1.11 0 2-.89 2-2v-11c0-1.11-.89-2-2-2zm0 13h-16v-2h16v2zm0-5h-16v-6h16v6z"></path></g>
<g id="wallet-travel"><path d="M20 6h-3v-2c0-1.11-.89-2-2-2h-6c-1.11 0-2 .89-2 2v2h-3c-1.11 0-2 .89-2 2v11c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2v-11c0-1.11-.89-2-2-2zm-11-2h6v2h-6v-2zm11 15h-16v-2h16v2zm0-5h-16v-6h3v2h2v-2h6v2h2v-2h3v6z"></path></g>
<g id="warning"><path d="M1 21h22l-11-19-11 19zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"></path></g>
<g id="work"><path d="M24 0v24h-24v-24h24m1-1h-26v26h26v-26z"></path><path d="M20 6h-4v-2c0-1.11-.89-2-2-2h-4c-1.11 0-2 .89-2 2v2h-4c-1.11 0-1.99.89-1.99 2l-.01 11c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2v-11c0-1.11-.89-2-2-2zm-6 0h-4v-2h4v2z"></path></g>
</defs></svg>
</core-iconset-svg>
<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->



<core-iconset-svg id="social" iconsize="24">
<svg><defs>
<g id="cake"><path d="M12 7c1.1 0 2-.9 2-2 0-.38-.1-.73-.29-1.03l-1.71-2.97-1.71 2.97c-.19.3-.29.65-.29 1.03 0 1.1.9 2 2 2zm9 14v-4c0-1.1-.9-2-2-2h-1v-3c0-1.1-.9-2-2-2h-3v-2h-2v2h-3c-1.1 0-2 .9-2 2v3h-1c-1.1 0-2 .9-2 2v4h-2v2h22v-2h-2z"></path></g>
<g id="circles"><path d="M16.66 14.98c-.82 2.34-3.04 4.02-5.66 4.02-3.31 0-6-2.69-6-6 0-2.62 1.68-4.84 4.02-5.66l-.02-.34c0-1.01.2-1.98.54-2.87-4.27.7-7.54 4.4-7.54 8.87 0 4.97 4.03 9 9 9 4.47 0 8.17-3.27 8.87-7.54-.89.34-1.86.54-2.87.54l-.34-.02zm.34-13.98c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm0 9c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z"></path></g>
<g id="circles-add"><path d="M12 2c-5.52 0-10 4.48-10 10s4.48 10 10 10 10-4.48 10-10-4.48-10-10-10zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"></path><path d="M13 11v-3h-2v3h-3v2h3v3h2v-3h3v-2h-3z"></path></g>
<g id="circles-extended"><path d="M12 10c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0-6c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm-6 9c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 6c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm6-7.9c-1.05 0-1.9.85-1.9 1.9s.85 1.9 1.9 1.9c1.05 0 1.9-.85 1.9-1.9s-.85-1.9-1.9-1.9zm6 1.9c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 6c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"></path></g>
<g id="communities"><path d="M9 12c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm5-3c0-1.1-.9-2-2-2s-2 .9-2 2 .9 2 2 2 2-.9 2-2zm-2-7c-5.52 0-10 4.48-10 10s4.48 10 10 10 10-4.48 10-10-4.48-10-10-10zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm3-8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></g>
<g id="domain"><path d="M12 7v-4h-10v18h20v-14h-10zm-6 12h-2v-2h2v2zm0-4h-2v-2h2v2zm0-4h-2v-2h2v2zm0-4h-2v-2h2v2zm4 12h-2v-2h2v2zm0-4h-2v-2h2v2zm0-4h-2v-2h2v2zm0-4h-2v-2h2v2zm10 12h-8v-2h2v-2h-2v-2h2v-2h-2v-2h8v10zm-2-8h-2v2h2v-2zm0 4h-2v2h2v-2z"></path></g>
<g id="group"><path d="M16 11c1.66 0 2.99-1.34 2.99-3s-1.33-3-2.99-3c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3s-1.33-3-2.99-3c-1.66 0-3 1.34-3 3s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5v2.5h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45v2.5h6v-2.5c0-2.33-4.67-3.5-7-3.5z"></path></g>
<g id="group-add"><path d="M8 10h-3v-3h-2v3h-3v2h3v3h2v-3h3v-2zm10 1c1.66 0 2.99-1.34 2.99-3s-1.33-3-2.99-3c-.32 0-.63.05-.91.14.57.81.9 1.79.9 2.86s-.34 2.04-.9 2.86c.28.09.59.14.91.14zm-5 0c1.66 0 2.99-1.34 2.99-3s-1.33-3-2.99-3c-1.66 0-3 1.34-3 3s1.34 3 3 3zm6.62 2.16c.83.73 1.38 1.66 1.38 2.84v2h3v-2c0-1.54-2.37-2.49-4.38-2.84zm-6.62-.16c-2 0-6 1-6 3v2h12v-2c0-2-4-3-6-3z"></path></g>
<g id="location-city"><path d="M15 11v-6l-3-3-3 3v2h-6v14h18v-10h-6zm-8 8h-2v-2h2v2zm0-4h-2v-2h2v2zm0-4h-2v-2h2v2zm6 8h-2v-2h2v2zm0-4h-2v-2h2v2zm0-4h-2v-2h2v2zm0-4h-2v-2h2v2zm6 12h-2v-2h2v2zm0-4h-2v-2h2v2z"></path></g>
<g id="mood"><path d="M11.99 2c-5.52 0-9.99 4.48-9.99 10s4.47 10 9.99 10c5.53 0 10.01-4.48 10.01-10s-4.48-10-10.01-10zm.01 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5s-.67-1.5-1.5-1.5-1.5.67-1.5 1.5.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5s-.67-1.5-1.5-1.5-1.5.67-1.5 1.5.67 1.5 1.5 1.5zm3.5 6.5c2.33 0 4.31-1.46 5.11-3.5h-10.22c.8 2.04 2.78 3.5 5.11 3.5z"></path></g>
<g id="notifications"><path d="M11.5 22c1.1 0 2-.9 2-2h-4c0 1.1.9 2 2 2zm6.5-6v-5.5c0-3.07-2.13-5.64-5-6.32v-.68c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68c-2.87.68-5 3.25-5 6.32v5.5l-2 2v1h17v-1l-2-2z"></path></g>
<g id="notifications-none"><path d="M11.5 22c1.1 0 2-.9 2-2h-4c0 1.1.9 2 2 2zm6.5-6v-5.5c0-3.07-2.13-5.64-5-6.32v-.68c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68c-2.87.68-5 3.25-5 6.32v5.5l-2 2v1h17v-1l-2-2zm-2 1h-9v-6.5c0-2.49 2.01-4.5 4.5-4.5s4.5 2.01 4.5 4.5v6.5z"></path></g>
<g id="notifications-off"><path d="M11.5 22c1.1 0 2-.9 2-2h-4c0 1.1.9 2 2 2zm6.5-11.5c0-3.07-2.13-5.64-5-6.32v-.68c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68c-.51.12-.99.32-1.45.56l9.45 9.44v-3.68zm-.27 8.5l2 2 1.27-1.27-16.73-16.73-1.27 1.27 2.92 2.92c-.58.97-.92 2.1-.92 3.31v5.5l-2 2v1h14.73z"></path></g>
<g id="notifications-on"><path d="M6.58 3.58l-1.43-1.43c-2.39 1.82-3.97 4.65-4.12 7.85h2c.15-2.65 1.51-4.97 3.55-6.42zm13.39 6.42h2c-.15-3.2-1.73-6.03-4.13-7.85l-1.43 1.43c2.05 1.45 3.41 3.77 3.56 6.42zm-1.97.5c0-3.07-2.13-5.64-5-6.32v-.68c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68c-2.87.68-5 3.25-5 6.32v5.5l-2 2v1h17v-1l-2-2v-5.5zm-6.5 11.5c.14 0 .27-.01.4-.04.65-.13 1.19-.58 1.44-1.18.1-.24.16-.5.16-.78h-4c0 1.1.9 2 2 2z"></path></g>
<g id="notifications-paused"><path d="M11.5 22c1.1 0 2-.9 2-2h-4c0 1.1.9 2 2 2zm6.5-6v-5.5c0-3.07-2.13-5.64-5-6.32v-.68c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68c-2.87.68-5 3.25-5 6.32v5.5l-2 2v1h17v-1l-2-2zm-4-6.2l-2.8 3.4h2.8v1.8h-5v-1.8l2.8-3.4h-2.8v-1.8h5v1.8z"></path></g>
<g id="pages"><path d="M3 5v6h5l-1-4 4 1v-5h-6c-1.1 0-2 .9-2 2zm5 8h-5v6c0 1.1.9 2 2 2h6v-5l-4 1 1-4zm9 4l-4-1v5h6c1.1 0 2-.9 2-2v-6h-5l1 4zm2-14h-6v5l4-1-1 4h5v-6c0-1.1-.9-2-2-2z"></path></g>
<g id="party-mode"><path d="M20 4h-3.17l-1.83-2h-6l-1.83 2h-3.17c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2v-12c0-1.1-.9-2-2-2zm-8 3c1.63 0 3.06.79 3.98 2h-3.98c-1.66 0-3 1.34-3 3 0 .35.07.69.18 1h-2.08c-.06-.32-.1-.66-.1-1 0-2.76 2.24-5 5-5zm0 10c-1.63 0-3.06-.79-3.98-2h3.98c1.66 0 3-1.34 3-3 0-.35-.07-.69-.18-1h2.08c.07.32.1.66.1 1 0 2.76-2.24 5-5 5z"></path></g>
<g id="people"><path d="M16 11c1.66 0 2.99-1.34 2.99-3s-1.33-3-2.99-3c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3s-1.33-3-2.99-3c-1.66 0-3 1.34-3 3s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5v2.5h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45v2.5h6v-2.5c0-2.33-4.67-3.5-7-3.5z"></path></g>
<g id="people-outline"><path d="M16.5 13c-1.2 0-3.07.34-4.5 1-1.43-.67-3.3-1-4.5-1-2.17 0-6.5 1.08-6.5 3.25v2.75h22v-2.75c0-2.17-4.33-3.25-6.5-3.25zm-4 4.5h-10v-1.25c0-.54 2.56-1.75 5-1.75s5 1.21 5 1.75v1.25zm9 0h-7.5v-1.25c0-.46-.2-.86-.52-1.22.88-.3 1.96-.53 3.02-.53 2.44 0 5 1.21 5 1.75v1.25zm-14-5.5c1.93 0 3.5-1.57 3.5-3.5s-1.57-3.5-3.5-3.5-3.5 1.57-3.5 3.5 1.57 3.5 3.5 3.5zm0-5.5c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm9 5.5c1.93 0 3.5-1.57 3.5-3.5s-1.57-3.5-3.5-3.5-3.5 1.57-3.5 3.5 1.57 3.5 3.5 3.5zm0-5.5c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2z"></path></g>
<g id="person"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"></path></g>
<g id="person-add"><path d="M15 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm-9-2v-3h-2v3h-3v2h3v3h2v-3h3v-2h-3zm9 4c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"></path></g>
<g id="person-outline"><path d="M12 5.9c1.16 0 2.1.94 2.1 2.1s-.94 2.1-2.1 2.1-2.1-.94-2.1-2.1.94-2.1 2.1-2.1m0 9c2.97 0 6.1 1.46 6.1 2.1v1.1h-12.2v-1.1c0-.64 3.13-2.1 6.1-2.1m0-10.9c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 9c-2.67 0-8 1.34-8 4v3h16v-3c0-2.66-5.33-4-8-4z"></path></g>
<g id="plus-one"><path d="M10 8h-2v4h-4v2h4v4h2v-4h4v-2h-4zm4.5-1.92v1.82l2.5-.5v10.6h2v-13z"></path></g>
<g id="poll"><path d="M19 3h-14c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-14c0-1.1-.9-2-2-2zm-10 14h-2v-7h2v7zm4 0h-2v-10h2v10zm4 0h-2v-4h2v4z"></path></g>
<g id="post-blogger"><path d="M20 2h-16c-1.1 0-1.99.9-1.99 2l-.01 16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2v-16c0-1.1-.9-2-2-2zm-4 7v1c0 .55.45 1 1 1s1 .45 1 1v3c0 1.66-1.34 3-3 3h-6c-1.66 0-3-1.34-3-3v-7c0-1.66 1.34-3 3-3h4c1.66 0 3 1.34 3 3v1zm-6.05 1h2.6c.55 0 1-.45 1-1s-.45-1-1-1h-2.6c-.55 0-1 .45-1 1s.45 1 1 1zm4.05 3h-4.05c-.55 0-1 .45-1 1s.45 1 1 1h4.05c.55 0 1-.45 1-1s-.45-1-1-1z"></path></g>
<g id="post-facebook"><path d="M20 2h-16c-1.1 0-1.99.9-1.99 2l-.01 16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2v-16c0-1.1-.9-2-2-2zm-1 2v3h-2c-.55 0-1 .45-1 1v2h3v3h-3v7h-3v-7h-2v-3h2v-2.5c0-1.93 1.57-3.5 3.5-3.5h2.5z"></path></g>
+<g id="post-github"><path d="M7.2 6.6h-.1c-.5 1.4-.2 2.3-.1 2.6-.6.7-1 1.6-1 2.6 0 3.8 2.4 4.6 4.6 4.9-.2 0-.6.2-.8.8-.4.2-1.8.7-2.6-.7 0 0-.5-.8-1.3-.9 0 0-.8 0-.1.5 0 0 .6.3.9 1.3 0 0 .5 1.7 3 1.1v3.1h5v-3.5c0-1-.4-1.5-.8-1.8 2.2-.2 4.6-1 4.6-4.8 0-1.1-.4-2-1-2.6.1-.3.4-1.2-.1-2.6 0 0-.8-.3-2.7 1-.8-.2-1.6-.3-2.5-.3-.8 0-1.7.1-2.5.3-1.4-1-2.2-1-2.6-1zm12.8 15.4h-16c-1.1 0-2-.9-2-2v-16c0-1.1.9-2 2-2h16c1.1 0 2 .9 2 2v16c0 1.1-.9 2-2 2z"></path></g>
<g id="post-gplus"><path d="M11.2 8.87c0-1.02-.63-3.02-2.08-3.02-.64 0-1.32.44-1.32 1.67 0 1.18.63 2.93 1.97 2.93.06.01 1.43-.01 1.43-1.58zm-.63 4.94l-.31-.01h-.02c-.26 0-1.15.05-1.82.27-.65.24-1.42.72-1.42 1.7 0 1.08 1.04 2.23 2.96 2.23 1.52 0 2.44-1 2.44-1.97 0-.77-.46-1.24-1.83-2.22zm9.43-11.81h-16c-1.1 0-1.99.9-1.99 2l-.01 16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2v-16c0-1.1-.9-2-2-2zm-10.93 17.2c-2.8 0-4.07-1.56-4.07-3.01 0-.45.14-1.59 1.48-2.39.77-.47 1.85-.78 3.14-.91-.19-.25-.34-.55-.34-.99 0-.16.02-.31.05-.46h-.38c-1.97 0-3.15-1.55-3.15-3.04 0-1.73 1.29-3.6 4.11-3.6h4.21l-.34.34-.71.71-.06.06h-.71c.41.42.9 1.12.9 2.16 0 1.4-.74 2.09-1.56 2.73-.16.12-.42.38-.42.72 0 .3.24.5.39.62.13.11.3.22.47.34.81.57 1.92 1.34 1.92 2.88 0 1.77-1.29 3.84-4.93 3.84zm9.93-7.2h-2v2h-1v-2h-2v-1h2v-2h1v2h2v1z"></path></g>
<g id="post-instagram"><path d="M20 2h-16c-1.1 0-1.99.9-1.99 2l-.01 16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2v-16c0-1.1-.9-2-2-2zm-8 6c2.21 0 4 1.79 4 4s-1.79 4-4 4-4-1.79-4-4 1.79-4 4-4zm-7.5 12c-.28 0-.5-.22-.5-.5v-8.5h2.09c-.05.33-.09.66-.09 1 0 3.31 2.69 6 6 6s6-2.69 6-6c0-.34-.04-.67-.09-1h2.09v8.5c0 .28-.22.5-.5.5h-15zm15.5-13.5c0 .28-.22.5-.5.5h-2c-.28 0-.5-.22-.5-.5v-2c0-.28.22-.5.5-.5h2c.28 0 .5.22.5.5v2z"></path></g>
<g id="post-linkedin"><path d="M20 2h-16c-1.1 0-1.99.9-1.99 2l-.01 16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2v-16c0-1.1-.9-2-2-2zm-12 17h-3v-9h3v9zm-1.5-10.69c-1 0-1.81-.81-1.81-1.81s.81-1.81 1.81-1.81 1.81.81 1.81 1.81-.81 1.81-1.81 1.81zm12.5 10.69h-3v-5.3c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v5.3h-3v-9h3v1.2c.52-.84 1.59-1.4 2.5-1.4 1.93 0 3.5 1.57 3.5 3.5v5.7z"></path></g>
<g id="post-pinterest"><path d="M20 2h-16c-1.1 0-1.99.9-1.99 2l-.01 16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2v-16c0-1.1-.9-2-2-2zm-7 14.2c-.8 0-1.57-.34-2.12-.92l-.95 3.2-.07.21-.03-.01c-.19.32-.54.52-.93.52-.61 0-1.1-.49-1.1-1.1l.01-.15h-.01l.05-.18 1.85-5.56s-.2-.61-.2-1.47c0-1.72.92-2.23 1.66-2.23.74 0 1.42.27 1.42 1.31 0 1.34-.89 2.03-.89 3 0 .74.6 1.34 1.34 1.34 2.33 0 3.16-1.76 3.16-3.41 0-2.18-1.88-3.95-4.2-3.95-2.32 0-4.2 1.77-4.2 3.95 0 .67.19 1.34.54 1.94.09.16.14.33.14.51 0 .55-.45 1-1 1-.36 0-.69-.19-.87-.5-.53-.9-.82-1.92-.82-2.96.02-3.27 2.8-5.94 6.22-5.94s6.2 2.67 6.2 5.95c0 2.63-1.63 5.45-5.2 5.45z"></path></g>
<g id="post-tumblr"><path d="M20 2h-16c-1.1 0-1.99.9-1.99 2l-.01 16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2v-16c0-1.1-.9-2-2-2zm-4 9h-3v3.9c0 .73.14 1.1 1.1 1.1h1.9v3s-1.03.1-2.1.1c-2.65 0-3.9-1.62-3.9-3.4v-4.7h-2v-2.8c2.41-.2 2.62-2.04 2.8-3.2h2.2v3h3v3z"></path></g>
<g id="post-twitter"><path d="M20 2h-16c-1.1 0-1.99.9-1.99 2l-.01 16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2v-16c0-1.1-.9-2-2-2zm-2.29 7.33c-.06 4.62-3.02 7.78-7.42 7.98-1.82.08-3.14-.5-4.28-1.23 1.34.21 3.01-.32 3.9-1.09-1.32-.13-2.1-.8-2.46-1.88.38.07.78.05 1.14-.03-1.19-.4-2.04-1.13-2.08-2.67.33.15.68.29 1.14.32-.9-.5-1.55-2.35-.8-3.57 1.32 1.45 2.91 2.63 5.52 2.79-.65-2.8 3.06-4.32 4.61-2.44.66-.13 1.19-.38 1.7-.65-.21.65-.62 1.1-1.12 1.47.54-.07 1.03-.21 1.44-.41-.25.53-.81 1.01-1.29 1.41z"></path></g>
<g id="post-youtube"><path d="M20 2h-16c-1.1 0-1.99.9-1.99 2l-.01 16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2v-16c0-1.1-.9-2-2-2zm-1.49 15.5c-.45.15-3.73.5-6.51.5-2.77 0-6.05-.35-6.5-.5-1.17-.39-1.5-2.8-1.5-5.5s.33-5.11 1.5-5.5c.45-.15 3.73-.5 6.5-.5 2.78 0 6.06.36 6.51.51 1.17.39 1.49 2.79 1.49 5.49s-.32 5.11-1.49 5.5zm-8.51-2l5.5-3.5-5.5-3.5v7z"></path></g>
<g id="public"><path d="M12 2c-5.52 0-10 4.48-10 10s4.48 10 10 10 10-4.48 10-10-4.48-10-10-10zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79l4.79 4.79v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1h-6v-2h2c.55 0 1-.45 1-1v-2h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"></path></g>
<g id="school"><path d="M5 13.18v4l7 3.82 7-3.82v-4l-7 3.82-7-3.82zm7-10.18l-11 6 11 6 9-4.91v6.91h2v-8l-11-6z"></path></g>
<g id="share"><path d="M18 16.08c-.76 0-1.44.3-1.96.77l-7.13-4.15c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7l-7.05 4.11c-.54-.5-1.25-.81-2.04-.81-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z"></path></g>
<g id="whatshot"><path d="M13.5.67s.74 2.65.74 4.8c0 2.06-1.35 3.73-3.41 3.73-2.07 0-3.63-1.67-3.63-3.73l.03-.36c-2.02 2.4-3.23 5.51-3.23 8.89 0 4.42 3.58 8 8 8s8-3.58 8-8c0-5.39-2.59-10.2-6.5-13.33zm-1.79 18.33c-1.78 0-3.22-1.4-3.22-3.14 0-1.62 1.05-2.76 2.81-3.12 1.77-.36 3.6-1.21 4.62-2.58.39 1.29.59 2.65.59 4.04 0 2.65-2.15 4.8-4.8 4.8z"></path></g>
</defs></svg>
</core-iconset-svg>
<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<!--
`core-icon-button` is an icon with button behaviors.

    <core-icon-button src="star.png"></core-icon-button>

`core-icon-button` includes a default icon set.  Use `icon` to specify 
which icon from the icon set to use.

    <core-icon-button icon="menu"></core-icon-button>

See [`core-iconset`](#core-iconset) for more information about 
how to use a custom icon set.

@group Polymer Core Elements
@element core-icon-button
@homepage github.io
-->




<polymer-element name="core-icon-button" attributes="src icon active">

  <template>
    <style>/*
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE
The complete set of authors may be found at http://polymer.github.io/AUTHORS
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS
*/


:host {
  display: inline-block;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  user-select: none;
  -moz-user-select: none;
  -webkit-user-select: none;
  border-radius: 2px;
  padding: 7px;
  margin: 2px;
  vertical-align: middle;
  font-size: 1rem;
  cursor: pointer;
}

:host([disabled]) {
  opacity: 0.6;
  pointer-events: none;
}

:host(.outline) {
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.1);
}

:host(:hover:not([disabled])) {
  box-shadow: 0 1px 0 0 rgba(0, 0, 0, 0.12), 0 0 0 1px rgba(0, 0, 0, 0.1);
}

:host(.selected:not([disabled])) {
  background-color: rgba(0, 0, 0, 0.05);
  box-shadow: inset 0 1px 0 0 rgba(0, 0, 0, 0.05), 0 0 0 1px rgba(0, 0, 0, 0.12);
}

:host(:active:not([disabled]), .selected:active:not([disabled])) {
  background-color: rgba(0, 0, 0, 0.05);
  box-shadow: inset 0 1px 0 0 rgba(0, 0, 0, 0.1), 0 0 0 1px rgba(0, 0, 0, 0.12);
}

:host(.core-dark-theme.outline) {
  background-color: rgba(200, 200, 200, 0.05);
  box-shadow: 0 0 0 1px rgba(200, 200, 200, 0.1);
}

:host(.core-dark-theme:hover) {
  background-color: rgba(200, 200, 200, 0.05);
  box-shadow: 0 1px 0 0 rgba(200, 200, 200, 0.12), 0 0 0 1px rgba(200, 200, 200, 0.1);
}

:host(.core-dark-theme.selected) {
  background-color: rgba(220, 220, 220, 0.05);
  box-shadow: inset 0 1px 0 0 rgba(200, 200, 200, 0.05), 0 0 0 1px rgba(200, 200, 200, 0.12);
}

:host(.core-dark-theme:active, .core-dark-theme.selected:active) {
  background-color: rgba(200, 200, 200, 0.05);
  box-shadow: inset 0 1px 0 0 rgba(200, 200, 200, 0.1), 0 0 0 1px rgba(200, 200, 200, 0.12);
}

core-icon {
  pointer-events: none;
}

/* note: this is a polyfill aware selector */
:host ::content > :not(core-icon) {
  margin-left: 4px;
}
</style>
    <core-icon src="{{src}}" icon="{{icon}}"/><content></content>
  </template>

  <script>

    Polymer('core-icon-button', {

      /**
       * The URL of an image for the icon.  Should not use `icon` property
       * if you are using this property.
       *
       * @attribute src
       * @type string
       * @default ''
       */
      src: '',

      /**
       * If true, border is placed around the button to indicate it's
       * active state.
       *
       * @attribute active
       * @type boolean
       * @default false
       */
      active: false,

      /**
       * Specifies the icon name or index in the set of icons available in
       * the icon set.  Should not use `src` property if you are using this
       * property.
       *
       * @attribute icon
       * @type string
       * @default ''
       */
      icon: '',

      activeChanged: function() {
        this.classList.toggle('selected', this.active);
      }

    });

  </script>

</polymer-element>
<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<!--
`core-item` is a simple line-item object: a label and/or an icon that can also 
act as a link.

Example:

    <core-item icon="settings" label="Settings"></core-item>
    
To use as a link, put &lt;a&gt; element in the item.

Example:

    <core-item icon="settings" label="Settings">
      <a href="#settings" target="_self"></a>
    </core-item>

@group Polymer Core Elements
@element core-item
@homepage github.io
-->



<polymer-element name="core-item" attributes="label icon src" horizontal="" center="" layout="">
<template>
  <style>/*
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/


:host {
  display: block;
  position: relative;
  min-height: 40px;
  white-space: nowrap;
}

:host(.font-scalable) {
  min-height: 2.5em;
}

:host(.core-selected) {
  font-weight: bold;
}

#icon {
  margin: 0 16px 0 4px;
}

:host(.font-scalable) #icon {
  margin: 0 1em 0 0.25em;
  height: 1.5em;
  width: 1.5em;
}

polyfill-next-selector { content: ':host > a'; }
::content > a {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  /* IE10 styling to ensure link is clickable. Cannot be completely
  transparent or minifiers change it to `transparent` which does not work. */
  background-color: rgba(0, 0, 0, 0.000001);
}
</style>
  <template if="{{icon || src}}">
    <core-icon src="{{src}}" id="icon" icon="{{icon}}" hidden?="{{!src &amp;&amp; !icon}}"/>
  </template>
  <div id="label">{{label}}</div>
  <content></content>
</template>
<script>

  Polymer('core-item', {
    
    /**
     * The URL of an image for the icon.
     *
     * @attribute src
     * @type string
     * @default ''
     */

    /**
     * Specifies the icon from the Polymer icon set.
     *
     * @attribute icon
     * @type string
     * @default ''
     */

    /**
     * Specifies the label for the menu item.
     *
     * @attribute label
     * @type string
     * @default ''
     */

  });

</script>
</polymer-element>
<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<!--
@group Polymer Core Elements

The `<core-selection>` element is used to manage selection state. It has no
visual appearance and is typically used in conjunction with another element.
For example, [core-selector](#core-selector)
use a `<core-selection>` to manage selection.

To mark an item as selected, call the `select(item)` method on 
`<core-selection>`. The item itself is an argument to this method.

The `<core-selection>`element manages selection state for any given set of
items. When an item is selected, the `core-select` event is fired.

The attribute `multi` indicates if multiple items can be selected at once.
  
Example:
 
    <polymer-element name="selection-example">
       <template>
         <style>
           polyfill-next-selector { content: ':host > .selected'; }
           ::content > .selected {
             font-weight: bold;
             font-style: italic;
           }
         </style>
         <ul on-tap="{{itemTapAction}}">
           <content></content>
         </ul>
         <core-selection id="selection" multi
                         on-core-select="{{selectAction}}"></core-selection>
       </template>
       <script>
         Polymer('selection-example', {
           itemTapAction: function(e, detail, sender) {
             this.$.selection.select(e.target);
           },
           selectAction: function(e, detail, sender) {
             detail.item.classList.toggle('selected', detail.isSelected);
           }
         });
       </script>
    </polymer-element>

    <selection-example>
      <li>Red</li>
      <li>Green</li>
      <li>Blue</li>
    </selection-example>
 
@element core-selection
-->

<!--
Fired when an item's selection state is changed. This event is fired both
when an item is selected or deselected. The `isSelected` detail property
contains the selection state.

@event core-select
@param {Object} detail
  @param {boolean} detail.isSelected true for selection and false for de-selection
  @param {Object} detail.item the item element
-->


<polymer-element name="core-selection" attributes="multi" hidden="">
  <script>
    Polymer('core-selection', {
      /**
       * If true, multiple selections are allowed.
       *
       * @attribute multi
       * @type boolean
       * @default false
       */
      multi: false,
      ready: function() {
        this.clear();
      },
      clear: function() {
        this.selection = [];
      },
      /**
       * Retrieves the selected item(s).
       * @method getSelection
       * @returns Returns the selected item(s). If the multi property is true,
       * getSelection will return an array, otherwise it will return 
       * the selected item or undefined if there is no selection.
      */
      getSelection: function() {
        return this.multi ? this.selection : this.selection[0];
      },
      /**
       * Indicates if a given item is selected.
       * @method isSelected
       * @param {any} item The item whose selection state should be checked.
       * @returns Returns true if `item` is selected.
      */
      isSelected: function(item) {
        return this.selection.indexOf(item) >= 0;
      },
      setItemSelected: function(item, isSelected) {
        if (item !== undefined && item !== null) {
          if (isSelected) {
            this.selection.push(item);
          } else {
            var i = this.selection.indexOf(item);
            if (i >= 0) {
              this.selection.splice(i, 1);
            }
          }
          this.fire("core-select", {isSelected: isSelected, item: item});
        }
      },
      /**
       * Set the selection state for a given `item`. If the multi property
       * is true, then the selected state of `item` will be toggled; otherwise
       * the `item` will be selected.
       * @method select
       * @param {any} item: The item to select.
      */
      select: function(item) {
        if (this.multi) {
          this.toggle(item);
        } else if (this.getSelection() !== item) {
          this.setItemSelected(this.getSelection(), false);
          this.setItemSelected(item, true);
        }
      },
      /**
       * Toggles the selection state for `item`.
       * @method toggle
       * @param {any} item: The item to toggle.
      */
      toggle: function(item) {
        this.setItemSelected(item, !this.isSelected(item));
      }
    });
  </script>
</polymer-element>
<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<!--
@group Polymer Core Elements

`<core-selector>` is used to manage a list of elements that can be selected.

The attribute `selected` indicates which item element is being selected.
The attribute `multi` indicates if multiple items can be selected at once.
Tapping on the item element would fire `core-activate` event. Use
`core-select` event to listen for selection changes.

Example:

    <core-selector selected="0">
      <div>Item 1</div>
      <div>Item 2</div>
      <div>Item 3</div>
    </core-selector>

`<core-selector>` is not styled. Use the `core-selected` CSS class to style the selected element.

    <style>
      .item.core-selected {
        background: #eee;
      }
    </style>
    ...
    <core-selector>
      <div class="item">Item 1</div>
      <div class="item">Item 2</div>
      <div class="item">Item 3</div>
    </core-selector>

@element core-selector
@status stable
@homepage github.io
-->

<!--
Fired when an item's selection state is changed. This event is fired both
when an item is selected or deselected. The `isSelected` detail property
contains the selection state.

@event core-select
@param {Object} detail
  @param {boolean} detail.isSelected true for selection and false for deselection
  @param {Object} detail.item the item element
-->
<!--
Fired when an item element is tapped.

@event core-activate
@param {Object} detail
  @param {Object} detail.item the item element
-->




<polymer-element name="core-selector" attributes="selected multi valueattr selectedClass selectedProperty selectedAttribute selectedItem selectedModel selectedIndex notap excludedLocalNames target itemsSelector activateEvent">

  <template>
    <core-selection id="selection" multi="{{multi}}" on-core-select="{{selectionSelect}}"></core-selection>
    <content id="items" select="*"></content>
  </template>

  <script>

    Polymer('core-selector', {

      /**
       * Gets or sets the selected element.  Default to use the index
       * of the item element.
       *
       * If you want a specific attribute value of the element to be
       * used instead of index, set "valueattr" to that attribute name.
       *
       * Example:
       *
       *     <core-selector valueattr="label" selected="foo">
       *       <div label="foo"></div>
       *       <div label="bar"></div>
       *       <div label="zot"></div>
       *     </core-selector>
       *
       * In multi-selection this should be an array of values.
       *
       * Example:
       *
       *     <core-selector id="selector" valueattr="label" multi>
       *       <div label="foo"></div>
       *       <div label="bar"></div>
       *       <div label="zot"></div>
       *     </core-selector>
       *
       *     this.$.selector.selected = ['foo', 'zot'];
       *
       * @attribute selected
       * @type Object
       * @default null
       */
      selected: null,

      /**
       * If true, multiple selections are allowed.
       *
       * @attribute multi
       * @type boolean
       * @default false
       */
      multi: false,

      /**
       * Specifies the attribute to be used for "selected" attribute.
       *
       * @attribute valueattr
       * @type string
       * @default 'name'
       */
      valueattr: 'name',

      /**
       * Specifies the CSS class to be used to add to the selected element.
       * 
       * @attribute selectedClass
       * @type string
       * @default 'core-selected'
       */
      selectedClass: 'core-selected',

      /**
       * Specifies the property to be used to set on the selected element
       * to indicate its active state.
       *
       * @attribute selectedProperty
       * @type string
       * @default ''
       */
      selectedProperty: '',

      /**
       * Specifies the attribute to set on the selected element to indicate
       * its active state.
       *
       * @attribute selectedAttribute
       * @type string
       * @default 'active'
       */
      selectedAttribute: 'active',

      /**
       * Returns the currently selected element. In multi-selection this returns
       * an array of selected elements.
       * Note that you should not use this to set the selection. Instead use
       * `selected`.
       * 
       * @attribute selectedItem
       * @type Object
       * @default null
       */
      selectedItem: null,

      /**
       * In single selection, this returns the model associated with the
       * selected element.
       * Note that you should not use this to set the selection. Instead use 
       * `selected`.
       * 
       * @attribute selectedModel
       * @type Object
       * @default null
       */
      selectedModel: null,

      /**
       * In single selection, this returns the selected index.
       * Note that you should not use this to set the selection. Instead use
       * `selected`.
       *
       * @attribute selectedIndex
       * @type number
       * @default -1
       */
      selectedIndex: -1,

      /**
       * Nodes with local name that are in the list will not be included 
       * in the selection items.  In the following example, `items` returns four
       * `core-item`'s and doesn't include `h3` and `hr`.
       *
       *     <core-selector excludedLocalNames="h3 hr">
       *       <h3>Header</h3>
       *       <core-item>Item1</core-item>
       *       <core-item>Item2</core-item>
       *       <hr>
       *       <core-item>Item3</core-item>
       *       <core-item>Item4</core-item>
       *     </core-selector>
       *
       * @attribute excludedLocalNames
       * @type string
       * @default ''
       */
      excludedLocalNames: '',

      /**
       * The target element that contains items.  If this is not set 
       * core-selector is the container.
       * 
       * @attribute target
       * @type Object
       * @default null
       */
      target: null,

      /**
       * This can be used to query nodes from the target node to be used for 
       * selection items.  Note this only works if `target` is set
       * and is not `core-selector` itself.
       *
       * Example:
       *
       *     <core-selector target="{{$.myForm}}" itemsSelector="input[type=radio]"></core-selector>
       *     <form id="myForm">
       *       <label><input type="radio" name="color" value="red"> Red</label> <br>
       *       <label><input type="radio" name="color" value="green"> Green</label> <br>
       *       <label><input type="radio" name="color" value="blue"> Blue</label> <br>
       *       <p>color = {{color}}</p>
       *     </form>
       * 
       * @attribute itemsSelector
       * @type string
       * @default ''
       */
      itemsSelector: '',

      /**
       * The event that would be fired from the item element to indicate
       * it is being selected.
       *
       * @attribute activateEvent
       * @type string
       * @default 'tap'
       */
      activateEvent: 'tap',

      /**
       * Set this to true to disallow changing the selection via the
       * `activateEvent`.
       *
       * @attribute notap
       * @type boolean
       * @default false
       */
      notap: false,

      defaultExcludedLocalNames: 'template',
      
      observe: {
        'selected multi': 'selectedChanged'
      },

      ready: function() {
        this.activateListener = this.activateHandler.bind(this);
        this.itemFilter = this.filterItem.bind(this);
        this.excludedLocalNamesChanged();
        this.observer = new MutationObserver(this.updateSelected.bind(this));
        if (!this.target) {
          this.target = this;
        }
      },

      /**
       * Returns an array of all items.
       *
       * @property items
       */
      get items() {
        if (!this.target) {
          return [];
        }
        var nodes = this.target !== this ? (this.itemsSelector ? 
            this.target.querySelectorAll(this.itemsSelector) : 
                this.target.children) : this.$.items.getDistributedNodes();
        return Array.prototype.filter.call(nodes, this.itemFilter);
      },

      filterItem: function(node) {
        return !this._excludedNames[node.localName];
      },

      excludedLocalNamesChanged: function() {
        this._excludedNames = {};
        var s = this.defaultExcludedLocalNames;
        if (this.excludedLocalNames) {
          s += ' ' + this.excludedLocalNames;
        }
        s.split(/\s+/g).forEach(function(n) {
          this._excludedNames[n] = 1;
        }, this);
      },

      targetChanged: function(old) {
        if (old) {
          this.removeListener(old);
          this.observer.disconnect();
          this.clearSelection();
        }
        if (this.target) {
          this.addListener(this.target);
          this.observer.observe(this.target, {childList: true});
          this.updateSelected();
        }
      },

      addListener: function(node) {
        Polymer.addEventListener(node, this.activateEvent, this.activateListener);
      },

      removeListener: function(node) {
        Polymer.removeEventListener(node, this.activateEvent, this.activateListener);
      },

      /**
       * Returns the selected item(s). If the `multi` property is true,
       * this will return an array, otherwise it will return 
       * the selected item or undefined if there is no selection.
       */
      get selection() {
        return this.$.selection.getSelection();
      },

      selectedChanged: function() {
        // TODO(ffu): Right now this is the only way to know that the `selected`
        // is an array and was mutated, as opposed to newly assigned.
        if (arguments.length === 1) {
          this.processSplices(arguments[0]);
        } else {
          this.updateSelected();
        }
      },
      
      updateSelected: function() {
        this.validateSelected();
        if (this.multi) {
          this.clearSelection(this.selected)
          this.selected && this.selected.forEach(function(s) {
            this.setValueSelected(s, true)
          }, this);
        } else {
          this.valueToSelection(this.selected);
        }
      },

      validateSelected: function() {
        // convert to an array for multi-selection
        if (this.multi && !Array.isArray(this.selected) && 
            this.selected != null) {
          this.selected = [this.selected];
        // use the first selected in the array for single-selection
        } else if (!this.multi && Array.isArray(this.selected)) {
          var s = this.selected[0];
          this.clearSelection([s]);
          this.selected = s;
        }
      },
      
      processSplices: function(splices) {
        for (var i = 0, splice; splice = splices[i]; i++) {
          for (var j = 0; j < splice.removed.length; j++) {
            this.setValueSelected(splice.removed[j], false);
          }
          for (var j = 0; j < splice.addedCount; j++) {
            this.setValueSelected(this.selected[splice.index + j], true);
          }
        }
      },

      clearSelection: function(excludes) {
        this.$.selection.selection.slice().forEach(function(item) {
          var v = this.valueForNode(item) || this.items.indexOf(item);
          if (!excludes || excludes.indexOf(v) < 0) {
            this.$.selection.setItemSelected(item, false);
          }
        }, this);
      },

      valueToSelection: function(value) {
        var item = this.valueToItem(value);
        this.$.selection.select(item);
      },
      
      setValueSelected: function(value, isSelected) {
        var item = this.valueToItem(value);
        if (isSelected ^ this.$.selection.isSelected(item)) {
          this.$.selection.setItemSelected(item, isSelected);
        }
      },

      updateSelectedItem: function() {
        this.selectedItem = this.selection;
      },

      selectedItemChanged: function() {
        if (this.selectedItem) {
          var t = this.selectedItem.templateInstance;
          this.selectedModel = t ? t.model : undefined;
        } else {
          this.selectedModel = null;
        }
        this.selectedIndex = this.selectedItem ? 
            parseInt(this.valueToIndex(this.selected)) : -1;
      },
      
      valueToItem: function(value) {
        return (value === null || value === undefined) ? 
            null : this.items[this.valueToIndex(value)];
      },

      valueToIndex: function(value) {
        // find an item with value == value and return it's index
        for (var i=0, items=this.items, c; (c=items[i]); i++) {
          if (this.valueForNode(c) == value) {
            return i;
          }
        }
        // if no item found, the value itself is probably the index
        return value;
      },

      valueForNode: function(node) {
        return node[this.valueattr] || node.getAttribute(this.valueattr);
      },

      // events fired from <core-selection> object
      selectionSelect: function(e, detail) {
        this.updateSelectedItem();
        if (detail.item) {
          this.applySelection(detail.item, detail.isSelected);
        }
      },

      applySelection: function(item, isSelected) {
        if (this.selectedClass) {
          item.classList.toggle(this.selectedClass, isSelected);
        }
        if (this.selectedProperty) {
          item[this.selectedProperty] = isSelected;
        }
        if (this.selectedAttribute && item.setAttribute) {
          if (isSelected) {
            item.setAttribute(this.selectedAttribute, '');
          } else {
            item.removeAttribute(this.selectedAttribute);
          }
        }
      },

      // event fired from host
      activateHandler: function(e) {
        if (!this.notap) {
          var i = this.findDistributedTarget(e.target, this.items);
          if (i >= 0) {
            var item = this.items[i];
            var s = this.valueForNode(item) || i;
            if (this.multi) {
              if (this.selected) {
                this.addRemoveSelected(s);
              } else {
                this.selected = [s];
              }
            } else {
              this.selected = s;
            }
            this.asyncFire('core-activate', {item: item});
          }
        }
      },

      addRemoveSelected: function(value) {
        var i = this.selected.indexOf(value);
        if (i >= 0) {
          this.selected.splice(i, 1);
        } else {
          this.selected.push(value);
        }
      },

      findDistributedTarget: function(target, nodes) {
        // find first ancestor of target (including itself) that
        // is in nodes, if any
        while (target && target != this) {
          var i = Array.prototype.indexOf.call(nodes, target);
          if (i >= 0) {
            return i;
          }
          target = target.parentNode;
        }
      },
      
      selectIndex: function(index) {
        var item = this.items[index];
        if (item) {
          this.selected = this.valueForNode(item) || index;
          return item;
        }
      },
      
      /**
       * Selects the previous item. This should be used in single selection only.
       *
       * @method selectPrevious
       * @param {boolean} wrapped if true and it is already at the first item,
       *                  wrap to the end
       * @returns the previous item or undefined if there is none
       */
      selectPrevious: function(wrapped) {
        var i = wrapped && !this.selectedIndex ? 
            this.items.length - 1 : this.selectedIndex - 1;
        return this.selectIndex(i);
      },
      
      /**
       * Selects the next item.  This should be used in single selection only.
       *
       * @method selectNext
       * @param {boolean} wrapped if true and it is already at the last item,
       *                  wrap to the front
       * @returns the next item or undefined if there is none
       */
      selectNext: function(wrapped) {
        var i = wrapped && this.selectedIndex >= this.items.length - 1 ? 
            0 : this.selectedIndex + 1;
        return this.selectIndex(i);
      }
      
    });
  </script>
</polymer-element>
<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<!--
`core-menu` is a selector which styles to looks like a menu.

    <core-menu selected="0">
      <core-item icon="settings" label="Settings"></core-item>
      <core-item icon="dialog" label="Dialog"></core-item>
      <core-item icon="search" label="Search"></core-item>
    </core-menu>
    
When an item is selected the `core-selected` class is added to it.  The user can
use the class to add more stylings to the selected item.

    core-item.core-selected {
      color: red;
    }

The `selectedItem` property references the selected item.

    <core-menu selected="0" selectedItem="{{item}}">
      <core-item icon="settings" label="Settings"></core-item>
      <core-item icon="dialog" label="Dialog"></core-item>
      <core-item icon="search" label="Search"></core-item>
    </core-menu>

    <div>selected label: {{item.label}}</div>

The `core-select` event signals selection change.

    <core-menu selected="0" on-core-select="{{selectAction}}">
      <core-item icon="settings" label="Settings"></core-item>
      <core-item icon="dialog" label="Dialog"></core-item>
      <core-item icon="search" label="Search"></core-item>
    </core-menu>

    ...

    selectAction: function(e, detail) {
      if (detail.isSelected) {
        var selectedItem = detail.item;
        ...
      }
    }

@group Polymer Core Elements
@element core-menu
@extends core-selector
-->



<polymer-element name="core-menu" extends="core-selector" noscript="">
<template>

  <style>/*
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/


:host {
  display: block;
  margin: 12px;
}

polyfill-next-selector { content: ':host > core-item'; }
::content > core-item {
  cursor: default;
}
</style>
  
  <shadow></shadow>
  
</template>
</polymer-element>
<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<!--

`<core-transition>` is an abstraction of an animation. It is used to implement pluggable
transitions, for example in `<core-overlay>`. You can extend this class to create a custom
animation, instantiate it, and import it where you need the animation.

All instances of `<core-transition>` are stored in a single database with `type=transition`.
For more about the database, please see the documentation for `<core-meta>`.

Each instance of `<core-transition>` objects are shared across all the clients, so you should
not store state information specific to the animated element in the transition. Rather, store
it on the element.

Example:

my-transition.html:

    <polymer-element name="my-transition" extends="core-transition">
        <script>
            go: function(node) {
                node.style.transition = 'opacity 1s ease-out';
                node.style.opacity = 0;
            }
        </script>
    </polymer-element>

    <my-transition id="my-fade-out"></my-transition>

my-transition-demo.html:

    <link href="components/core-meta/core-meta.html" rel="import">
    <link href="my-transition.html" rel="import">

    <div id="animate-me"></div>

    <script>
        // Get the core-transition
        var meta = document.createElement('core-meta');
        meta.type = 'transition';
        var transition = meta.byId('my-fade-out');

        // Run the animation
        var animated = document.getElementById('animate-me');
        transition.go(animated);
    </script>

@group Polymer Core Elements
@element core-transition
@extends core-meta
@status beta
@homepage github.io
-->
<!--
Fired when the animation finishes.

@event core-transitionend
@param {Object} detail
@param {Object} detail.node The animated node
-->



<polymer-element name="core-transition" extends="core-meta">
  
  <script>
    Polymer('core-transition', {
      
      type: 'transition',

      /**
       * Run the animation.
       *
       * @method go
       * @param {Node} node The node to apply the animation on
       * @param {Object} state State info
       */
      go: function(node, state) {
        this.complete(node);
      },

      /**
       * Set up the animation. This may include injecting a stylesheet,
       * applying styles, creating a web animations object, etc.. This
       *
       * @method setup
       * @param {Node} node The animated node
       */
      setup: function(node) {
      },

      /**
       * Tear down the animation.
       *
       * @method teardown
       * @param {Node} node The animated node
       */
      teardown: function(node) {
      },

      /**
       * Called when the animation completes. This function also fires the
       * `core-transitionend` event.
       *
       * @method complete
       * @param {Node} node The animated node
       */
      complete: function(node) {
        this.fire('core-transitionend', null, node);
      },

      /**
       * Utility function to listen to an event on a node once.
       *
       * @method listenOnce
       * @param {Node} node The animated node
       * @param {string} event Name of an event
       * @param {Function} fn Event handler
       * @param {Array} args Additional arguments to pass to `fn`
       */
      listenOnce: function(node, event, fn, args) {
        var self = this;
        var listener = function() {
          fn.apply(self, args);
          node.removeEventListener(event, listener, false);
        }
        node.addEventListener(event, listener, false);
      }

    });
  </script>
</polymer-element>
<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->



<polymer-element name="core-key-helper">
  <script>
    Polymer('core-key-helper', {
      ENTER_KEY: 13,
      ESCAPE_KEY: 27
    });
  </script>
</polymer-element>
<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->


<polymer-element name="core-overlay-layer">
<template>
  <style>
    :host {
      position: fixed;
      top: 0;
      left: 0;
      z-index: 1000;
      display: none;
    }

    :host(.core-opened) {
      display: block;
    }
  </style>
  <content></content>
</template>
<script>
(function() {

  Polymer('core-overlay-layer', {
    publish: {
      opened: false
    },
    openedChanged: function() {
      this.classList.toggle('core-opened', this.opened);
    },
    /**
     * Adds an element to the overlay layer
     */
    addElement: function(element) {
      if (!this.parentNode) {
        document.querySelector('body').appendChild(this);
      }
      if (element.parentNode !== this) {
        element.__contents = [];
        var ip$ = element.querySelectorAll('content');
        for (var i=0, l=ip$.length, n; (i<l) && (n = ip$[i]); i++) {
          this.moveInsertedElements(n);
          this.cacheDomLocation(n);
          n.parentNode.removeChild(n);
          element.__contents.push(n);
        }
        this.cacheDomLocation(element);
        this.updateEventController(element);
        var h = this.makeHost();
        h.shadowRoot.appendChild(element);
        element.__host = h;
      }
    },
    makeHost: function() {
      var h = document.createElement('overlay-host');
      h.createShadowRoot();
      this.appendChild(h);
      return h;
    },
    moveInsertedElements: function(insertionPoint) {
      var n$ = insertionPoint.getDistributedNodes();
      var parent = insertionPoint.parentNode;
      insertionPoint.__contents = [];
      for (var i=0, l=n$.length, n; (i<l) && (n=n$[i]); i++) {
        this.cacheDomLocation(n);
        this.updateEventController(n);
        insertionPoint.__contents.push(n);
        parent.appendChild(n);  
      }
    },
    updateEventController: function(element) {
      element.eventController = this.element.findController(element);
    },
    /**
     * Removes an element from the overlay layer
     */
    removeElement: function(element) {
      element.eventController = null;
      this.replaceElement(element);
      var h = element.__host;
      if (h) {
        h.parentNode.removeChild(h);
      }
    },
    replaceElement: function(element) {
      if (element.__contents) {
        for (var i=0, c$=element.__contents, c; (c=c$[i]); i++) {
          this.replaceElement(c);
        }
        element.__contents = null;
      }
      if (element.__parentNode) {
        var n = element.__nextElementSibling && element.__nextElementSibling 
            === element.__parentNode ? element.__nextElementSibling : null;
        element.__parentNode.insertBefore(element, n);
      }
    },
    cacheDomLocation: function(element) {
      element.__nextElementSibling = element.nextElementSibling;
      element.__parentNode = element.parentNode;
    }
  });
  
})();
</script>
</polymer-element>
<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->






<!--
The `core-overlay` element displays overlayed on top of other content. It starts
out hidden and is displayed by setting its `opened` property to true.
A `core-overlay's` opened state can be toggled by calling the `toggle`
method.

The `core-overlay` will, by default, show/hide itself when it's opened. The 
`target` property may be set to another element to cause that element to 
be shown when the overlay is opened.

It's common to want a `core-overlay` to animate to its opened
position. The `core-overlay` element uses a `core-transition` to handle
animation. The default transition is `core-transition-fade` which 
causes the overlay to fade in when displayed. See 
<a href="../core-transition/">`core-transition`</a> for more
information about customizing a `core-overlay's` opening animation. The
`backdrop` property can be set to true to show a backdrop behind the overlay
that will darken the rest of the window.

An element that should close the `core-overlay` will automatically
do so if it's given the `core-overlay-toggle` attribute. This attribute
can be customized with the `closeAttribute` property. You can also use
`closeSelector` if more general matching is needed.

By default  `core-overlay` will close whenever the user taps outside it or
presses the escape key. This behavior can be turned off via the
`autoCloseDisabled` property.

    <core-overlay>
      <h2>Dialog</h2>
      <input placeholder="say something..." autofocus>
      <div>I agree with this wholeheartedly.</div>
      <button core-overlay-toggle>OK</button>
    </core-overlay>

`core-overlay` will automatically size and position itself according to the 
following rules. The overlay's size is constrained such that it does not
overflow the screen. This is done by setting maxHeight/maxWidth on the 
`sizingTarget`. If the `sizingTarget` already has a setting for one of these
properties, it will not be overridden. The overlay should
be positioned via css or imperatively using the `core-overlay-position` event.
If the overlay is not positioned vertically via setting `top` or `bottom`, it
will be centered vertically. The same is true horizontally via a setting to 
`left` or `right`. In addition, css `margin` can be used to provide some space
around the overlay. This can be used to ensure
that, for example, a drop shadow is always visible around the overlay.

@group Core Elements
@element core-overlay
@homepage github.io
-->
<!--
Fired when the `core-overlay`'s `opened` property changes.

@event core-overlay-open
@param {Object} detail
@param {Object} detail.opened the opened state
-->
<!--
Fired when the `core-overlay` has completely opened.

@event core-overlay-open-completed
-->
<!--
Fired when the `core-overlay` has completely closed.

@event core-overlay-close-completed
-->
<!--
Fired when the `core-overlay` needs to position itself. Optionally, implement
in order to position an overlay via code. If the overlay was not otherwise
positioned, it's important to indicate how the overlay has been positioned by
setting the `dimensions.position` object. For example, if the overlay has been
positioned via setting `right` and `top`, set dimensions.position to an
object like this: `{v: 'top', h: 'right'}`.

@event core-overlay-position
@param {Object} detail
@param {Object} detail.target the overlay target
@param {Object} detail.sizingTarget the overlay sizing target
@param {Object} detail.opened the opened state
-->
<style>
  .core-overlay-backdrop {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: black;
    opacity: 0;
    transition: opacity 0.2s;
  }

  .core-overlay-backdrop.core-opened {
    opacity: 0.6;
  }
</style>

<polymer-element name="core-overlay">
<script>
(function() {

  Polymer('core-overlay', {

    publish: {
      /**
       * The target element that will be shown when the overlay is 
       * opened. If unspecified, the core-overlay itself is the target.
       *
       * @attribute target
       * @type Object
       * @default the overlay element
       */
      target: null,


      /**
       * A `core-overlay`'s size is guaranteed to be 
       * constrained to the window size. To achieve this, the sizingElement
       * is sized with a max-height/width. By default this element is the 
       * target element, but it can be specifically set to a specific element
       * inside the target if that is more appropriate. This is useful, for 
       * example, when a region inside the overlay should scroll if needed.
       *
       * @attribute sizingTarget
       * @type Object
       * @default the target element
       */
      sizingTarget: null,
    
      /**
       * Set opened to true to show an overlay and to false to hide it.
       * A `core-overlay` may be made initially opened by setting its
       * `opened` attribute.
       * @attribute opened
       * @type boolean
       * @default false
       */
      opened: false,

      /**
       * If true, the overlay has a backdrop darkening the rest of the screen.
       * The backdrop element is attached to the document body and may be styled
       * with the class `core-overlay-backdrop`. When opened the `core-opened`
       * class is applied.
       *
       * @attribute backdrop
       * @type boolean
       * @default false
       */    
      backdrop: false,

      /**
       * If true, the overlay is guaranteed to display above page content.
       *
       * @attribute layered
       * @type boolean
       * @default false
      */
      layered: false,
    
      /**
       * By default an overlay will close automatically if the user
       * taps outside it or presses the escape key. Disable this
       * behavior by setting the `autoCloseDisabled` property to true.
       * @attribute autoCloseDisabled
       * @type boolean
       * @default false
       */
      autoCloseDisabled: false,

      /**
       * By default an overlay will focus its target or an element inside
       * it with the `autoFocus` attribute. Disable this
       * behavior by setting the `autoFocusDisabled` property to true.
       * @attribute autoFocusDisabled
       * @type boolean
       * @default false
       */
      autoFocusDisabled: false,

      /**
       * This property specifies an attribute on elements that should
       * close the overlay on tap. Should not set `closeSelector` if this
       * is set.
       *
       * @attribute closeAttribute
       * @type string
       * @default "core-overlay-toggle"
       */
      closeAttribute: 'core-overlay-toggle',

      /**
       * This property specifies a selector matching elements that should
       * close the overlay on tap. Should not set `closeAttribute` if this
       * is set.
       *
       * @attribute closeSelector
       * @type string
       * @default ""
       */
      closeSelector: '',

      /**
       * The transition property specifies a string which identifies a 
       * <a href="../core-transition/">`core-transition`</a> element that 
       * will be used to help the overlay open and close. The default
       * `core-transition-fade` will cause the overlay to fade in and out.
       *
       * @attribute transition
       * @type string
       * @default 'core-transition-fade'
       */
      transition: 'core-transition-fade'

    },

    captureEventName: 'tap',
    targetListeners: {
      'tap': 'tapHandler',
      'keydown': 'keydownHandler',
      'core-transitionend': 'transitionend'
    },
    
    registerCallback: function(element) {
      this.layer = document.createElement('core-overlay-layer');
      this.keyHelper = document.createElement('core-key-helper');
      this.meta = document.createElement('core-transition');
      this.scrim = document.createElement('div');
      this.scrim.className = 'core-overlay-backdrop';
    },

    ready: function() {
      this.target = this.target || this;
      // flush to ensure styles are installed before paint
      Polymer.flush();
    },

    /** 
     * Toggle the opened state of the overlay.
     * @method toggle
     */
    toggle: function() {
      this.opened = !this.opened;
    },

    /** 
     * Open the overlay. This is equivalent to setting the `opened`
     * property to true.
     * @method open
     */
    open: function() {
      this.opened = true;
    },

    /** 
     * Close the overlay. This is equivalent to setting the `opened` 
     * property to false.
     * @method close
     */
    close: function() {
      this.opened = false;
    },

    domReady: function() {
      this.ensureTargetSetup();
    },

    targetChanged: function(old) {
      if (this.target) {
        // really make sure tabIndex is set
        if (this.target.tabIndex < 0) {
          this.target.tabIndex = -1;
        }
        this.addElementListenerList(this.target, this.targetListeners);
        this.target.style.display = 'none';
        this.target.__overlaySetup = false;
      }
      if (old) {
        this.removeElementListenerList(old, this.targetListeners);
        var transition = this.getTransition();
        if (transition) {
          transition.teardown(old);
        } else {
          old.style.position = '';
          old.style.outline = '';
        }
        old.style.display = '';
      }
    },

    transitionChanged: function(old) {
      if (!this.target) {
        return;
      }
      if (old) {
        this.getTransition(old).teardown(this.target);
      }
      this.target.__overlaySetup = false;
    },

    // NOTE: wait to call this until we're as sure as possible that target
    // is styled.
    ensureTargetSetup: function() {
      if (!this.target || this.target.__overlaySetup) {
        return;
      }
      if (!this.sizingTarget) {
        this.sizingTarget = this.target;
      }
      this.target.__overlaySetup = true;
      this.target.style.display = '';
      var transition = this.getTransition();
      if (transition) {
        transition.setup(this.target);
      }
      var style = this.target.style;
      var computed = getComputedStyle(this.target);
      if (computed.position === 'static') {
        style.position = 'fixed';
      }
      style.outline = 'none';
      style.display = 'none';
    },

    openedChanged: function() {
      this.transitioning = true;
      this.ensureTargetSetup();
      this.prepareRenderOpened();
      // async here to allow overlay layer to become visible.
      this.async(function() {
        this.target.style.display = '';
        // force layout to ensure transitions will go
        this.target.offsetWidth;
        this.renderOpened();
      });
      this.fire('core-overlay-open', this.opened);
    },

    // tasks which must occur before opening; e.g. making the element visible
    prepareRenderOpened: function() {
      if (this.opened) {
        addOverlay(this);
      }
      this.prepareBackdrop();
      // async so we don't auto-close immediately via a click.
      this.async(function() {
        if (!this.autoCloseDisabled) {
          this.enableElementListener(this.opened, document,
              this.captureEventName, 'captureHandler', true);
        }
      });
      this.enableElementListener(this.opened, window, 'resize',
          'resizeHandler');

      if (this.opened) {
        // force layout so SD Polyfill renders
        this.target.offsetHeight;
        this.discoverDimensions();
        // if we are showing, then take care when positioning
        this.preparePositioning();
        this.positionTarget();
        this.updateTargetDimensions();
        this.finishPositioning();
        if (this.layered) {
          this.layer.addElement(this.target);
          this.layer.opened = this.opened;
        }
      }
    },

    // tasks which cause the overlay to actually open; typically play an
    // animation
    renderOpened: function() {
      var transition = this.getTransition();
      if (transition) {
        transition.go(this.target, {opened: this.opened});
      } else {
        this.transitionend();
      }
      this.renderBackdropOpened();
    },

    // finishing tasks; typically called via a transition
    transitionend: function(e) {
      // make sure this is our transition event.
      if (e && e.target !== this.target) {
        return;
      }
      this.transitioning = false;
      if (!this.opened) {
        this.resetTargetDimensions();
        this.target.style.display = 'none';
        this.completeBackdrop();
        removeOverlay(this);
        if (this.layered) {
          if (!currentOverlay()) {
            this.layer.opened = this.opened;
          }
          this.layer.removeElement(this.target);
        }
      }
      this.fire('core-overlay-' + (this.opened ? 'open' : 'close') + 
          '-completed');
      this.applyFocus();
    },

    prepareBackdrop: function() {
      if (this.backdrop && this.opened) {
        if (!this.scrim.parentNode) {
          document.body.appendChild(this.scrim);
          this.scrim.style.zIndex = currentOverlayZ() - 1;
        }
        trackBackdrop(this);
      }
    },

    renderBackdropOpened: function() {
      if (this.backdrop && getBackdrops().length < 2) {
        this.scrim.classList.toggle('core-opened', this.opened);
      }
    },

    completeBackdrop: function() {
      if (this.backdrop) {
        trackBackdrop(this);
        if (getBackdrops().length === 0) {
          this.scrim.parentNode.removeChild(this.scrim);
        }
      }
    },

    preparePositioning: function() {
      this.target.style.transition = this.target.style.webkitTransition = 'none';
      this.target.style.transform = this.target.style.webkitTransform = 'none';
      this.target.style.display = '';
    },

    discoverDimensions: function() {
      if (this.dimensions) {
        return;
      }
      var target = getComputedStyle(this.target);
      var sizer = getComputedStyle(this.sizingTarget);
      this.dimensions = {
        position: {
          v: target.top !== 'auto' ? 'top' : (target.bottom !== 'auto' ?
            'bottom' : null),
          h: target.left !== 'auto' ? 'left' : (target.right !== 'auto' ?
            'right' : null),
          css: target.position
        },
        size: {
          v: sizer.maxHeight !== 'none',
          h: sizer.maxWidth !== 'none'
        },
        margin: {
          top: parseInt(target.marginTop) || 0,
          right: parseInt(target.marginRight) || 0,
          bottom: parseInt(target.marginBottom) || 0,
          left: parseInt(target.marginLeft) || 0
        }
      };
    },

    finishPositioning: function(target) {
      this.target.style.display = 'none';
      this.target.style.transform = this.target.style.webkitTransform = '';
      // force layout to avoid application of transform
      this.target.offsetWidth;
      this.target.style.transition = this.target.style.webkitTransition = '';
    },

    getTransition: function(name) {
      return this.meta.byId(name || this.transition);
    },

    getFocusNode: function() {
      return this.target.querySelector('[autofocus]') || this.target;
    },

    applyFocus: function() {
      var focusNode = this.getFocusNode();
      if (this.opened) {
        if (!this.autoFocusDisabled) {
          focusNode.focus();
        }
      } else {
        focusNode.blur();
        if (currentOverlay() == this) {
          console.warn('Current core-overlay is attempting to focus itself as next! (bug)');
        } else {
          focusOverlay();
        }
      }
    },

    positionTarget: function() {
      // fire positioning event
      this.fire('core-overlay-position', {target: this.target,
          sizingTarget: this.sizingTarget, opened: this.opened});
      if (!this.dimensions.position.v) {
        this.target.style.top = '0px';
      }
      if (!this.dimensions.position.h) {
        this.target.style.left = '0px';
      }
    },

    updateTargetDimensions: function() {
      this.sizeTarget();
      this.repositionTarget();
    },

    sizeTarget: function() {
      this.sizingTarget.style.boxSizing = 'border-box';
      var dims = this.dimensions;
      var rect = this.target.getBoundingClientRect();
      if (!dims.size.v) {
        this.sizeDimension(rect, dims.position.v, 'top', 'bottom', 'Height');
      }
      if (!dims.size.h) {
        this.sizeDimension(rect, dims.position.h, 'left', 'right', 'Width');
      }
    },

    sizeDimension: function(rect, positionedBy, start, end, extent) {
      var dims = this.dimensions;
      var flip = (positionedBy === end);
      var m = flip ? start : end;
      var ws = window['inner' + extent];
      var o = dims.margin[m] + (flip ? ws - rect[end] : 
          rect[start]);
      var offset = 'offset' + extent;
      var o2 = this.target[offset] - this.sizingTarget[offset];
      this.sizingTarget.style['max' + extent] = (ws - o - o2) + 'px';
    },

    // vertically and horizontally center if not positioned
    repositionTarget: function() {
      // only center if position fixed.      
      if (this.dimensions.position.css !== 'fixed') {
        return; 
      }
      if (!this.dimensions.position.v) {
        var t = (window.innerHeight - this.target.offsetHeight) / 2;
        t -= this.dimensions.margin.top;
        this.target.style.top = t + 'px';
      }

      if (!this.dimensions.position.h) {
        var l = (window.innerWidth - this.target.offsetWidth) / 2;
        l -= this.dimensions.margin.left;
        this.target.style.left = l + 'px';
      }
    },

    resetTargetDimensions: function() {
      if (!this.dimensions || !this.dimensions.size.v) {
        this.sizingTarget.style.maxHeight = '';  
        this.target.style.top = '';
      }
      if (!this.dimensions || !this.dimensions.size.h) {
        this.sizingTarget.style.maxWidth = '';  
        this.target.style.left = '';
      }
      this.dimensions = null;
    },

    tapHandler: function(e) {
      // closeSelector takes precedence since closeAttribute has a default non-null value.
      if (e.target &&
          (this.closeSelector && e.target.matches(this.closeSelector)) ||
          (this.closeAttribute && e.target.hasAttribute(this.closeAttribute))) {
        this.toggle();
      } else {
        if (this.autoCloseJob) {
          this.autoCloseJob.stop();
          this.autoCloseJob = null;
        }
      }
    },
    
    // We use the traditional approach of capturing events on document
    // to to determine if the overlay needs to close. However, due to 
    // ShadowDOM event retargeting, the event target is not useful. Instead
    // of using it, we attempt to close asynchronously and prevent the close
    // if a tap event is immediately heard on the target.
    // TODO(sorvell): This approach will not work with modal. For
    // this we need a scrim.
    captureHandler: function(e) {
      if (!this.autoCloseDisabled && (currentOverlay() == this)) {
        this.autoCloseJob = this.job(this.autoCloseJob, function() {
          this.close();
        });
      }
    },

    keydownHandler: function(e) {
      if (!this.autoCloseDisabled && (e.keyCode == this.keyHelper.ESCAPE_KEY)) {
        this.close();
        e.stopPropagation();
      }
    },

    /**
     * Extensions of core-overlay should implement the `resizeHandler`
     * method to adjust the size and position of the overlay when the 
     * browser window resizes.
     * @method resizeHandler
     */
    resizeHandler: function() {
      this.updateTargetDimensions();
    },

    // TODO(sorvell): these utility methods should not be here.
    addElementListenerList: function(node, events) {
      for (var i in events) {
        this.addElementListener(node, i, events[i]);
      }
    },

    removeElementListenerList: function(node, events) {
      for (var i in events) {
        this.removeElementListener(node, i, events[i]);
      }
    },

    enableElementListener: function(enable, node, event, methodName, capture) {
      if (enable) {
        this.addElementListener(node, event, methodName, capture);
      } else {
        this.removeElementListener(node, event, methodName, capture);
      }
    },

    addElementListener: function(node, event, methodName, capture) {
      var fn = this._makeBoundListener(methodName);
      if (node && fn) {
        Polymer.addEventListener(node, event, fn, capture);
      }
    },

    removeElementListener: function(node, event, methodName, capture) {
      var fn = this._makeBoundListener(methodName);
      if (node && fn) {
        Polymer.removeEventListener(node, event, fn, capture);
      }
    },

    _makeBoundListener: function(methodName) {
      var self = this, method = this[methodName];
      if (!method) {
        return;
      }
      var bound = '_bound' + methodName;
      if (!this[bound]) {
        this[bound] = function(e) {
          method.call(self, e);
        };
      }
      return this[bound];
    },
  });

  // TODO(sorvell): This should be an element with private state so it can
  // be independent of overlay.
  // track overlays for z-index and focus managemant
  var overlays = [];
  function addOverlay(overlay) {
    var z0 = currentOverlayZ();
    overlays.push(overlay);
    var z1 = currentOverlayZ();
    if (z1 <= z0) {
      applyOverlayZ(overlay, z0);
    }
  }

  function removeOverlay(overlay) {
    var i = overlays.indexOf(overlay);
    if (i >= 0) {
      overlays.splice(i, 1);
      setZ(overlay, '');
    }
  }
  
  function applyOverlayZ(overlay, aboveZ) {
    setZ(overlay.target, aboveZ + 2);
  }
  
  function setZ(element, z) {
    element.style.zIndex = z;
  }

  function currentOverlay() {
    return overlays[overlays.length-1];
  }
  
  var DEFAULT_Z = 10;
  
  function currentOverlayZ() {
    var z;
    var current = currentOverlay();
    if (current) {
      var z1 = window.getComputedStyle(current.target).zIndex;
      if (!isNaN(z1)) {
        z = Number(z1);
      }
    }
    return z || DEFAULT_Z;
  }
  
  function focusOverlay() {
    var current = currentOverlay();
    // We have to be careful to focus the next overlay _after_ any current
    // transitions are complete (due to the state being toggled prior to the
    // transition). Otherwise, we risk infinite recursion when a transitioning
    // (closed) overlay becomes the current overlay.
    //
    // NOTE: We make the assumption that any overlay that completes a transition
    // will call into focusOverlay to kick the process back off. Currently:
    // transitionend -> applyFocus -> focusOverlay.
    if (current && !current.transitioning) {
      current.applyFocus();
    }
  }

  var backdrops = [];
  function trackBackdrop(element) {
    if (element.opened) {
      backdrops.push(element);
    } else {
      var i = backdrops.indexOf(element);
      if (i >= 0) {
        backdrops.splice(i, 1);
      }
    }
  }

  function getBackdrops() {
    return backdrops;
  }
})();
</script>
</polymer-element>
<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->




<!--

`core-popup-overlay` is a helper class to position an overlay relative to another
element.

@group Polymer Core Elements
@element core-popup-overlay
@extends core-overlay
@homepage github.io
-->

<polymer-element name="core-popup-overlay" extends="core-overlay">
<script>
    Polymer({

      publish: {

        /**
         * The `relatedTarget` is an element used to position the overlay, for example a
         * button the user taps to show a menu.
         *
         * @attribute relatedTarget
         * @type Element
         */
        relatedTarget: null,

        /**
         * The horizontal alignment of the overlay relative to the `relatedTarget`.
         *
         * @attribute halign
         * @type 'left'|'right'|'auto'
         * @default 'auto'
         */
        halign: 'auto',

        /**
         * The vertical alignment of the overlay relative to the `relatedTarget`.
         *
         * @attribute valign
         * @type 'top'|'bottom'|'auto'
         * @default 'bottom'
         */
        valign: 'auto',

        margin: 12

      },

      positionTarget: function() {
        if (!this.relatedTarget) {
          this.super();
          return;
        }

        var top, left, bottom, right;
        var ref = this.relatedTarget.getBoundingClientRect();

        if (this.halign === 'left') {
          left = ref.left;
        } else if (this.halign === 'right') {
          right = window.innerWidth - ref.right;
        } else if (this.halign === 'auto') {
          if (ref.left + this.target.offsetWidth > window.innerWidth) {
            right = window.innerWidth - ref.right;
          } else {
            left = ref.left;
          }
        }

        if (this.valign === 'top') {
          bottom = window.innerHeight - ref.bottom;
        } else if (this.valign === 'bottom') {
          top = ref.top;
        } else if (this.valign === 'auto') {
          if (ref.top + this.target.offsetHeight > window.innerHeight && this.target.offsetHeight < window.innerHeight) {
            bottom = window.innerHeight - ref.bottom;
          } else {
            top = ref.top;
          }
        }

        (top !== undefined) && (this.target.style.top = top + 'px');
        (left !== undefined) && (this.target.style.left = left + 'px');
        (bottom !== undefined) && (this.target.style.bottom = bottom + 'px');
        (right !== undefined) && (this.target.style.right = right + 'px');
      },

      sizeTarget: function() {
        var rect = this.relatedTarget.getBoundingClientRect();
        var sizer = this.sizingTarget || this.target;

        sizer.style.minWidth = rect.width + 'px';

        this.super();
      }

    });
  </script>
</polymer-element>
<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<!--

`core-popup-menu` is a popup menu that can be positioned relative to another
element, usually the element that opens or closes the menu. It can be used
to implement drop-downs, menu buttons, etc..

Example:

    <template is="auto-binding">
        <div id="control">Your favorite pastry:</div>
        <core-popup-menu relatedTarget="{{$.control}}" on-core-select="{{selectAction}}">
          <core-item label="Churro"></core-item>
          <core-item label="Donut"></core-item>
          <core-item label="Macaron"></core-item>
        </core-popup-menu>
    </template>

@group Polymer Core Elements
@element core-popup-menu
@homepage github.io
-->

<!--
Fired when an item's selection state is changed. This event is fired both
when an item is selected or deselected. The `isSelected` detail property
contains the selection state.

@event core-select
@param {Object} detail
  @param {boolean} detail.isSelected true for selection and false for de-selection
  @param {Object} detail.item the item element
-->





<polymer-element name="core-popup-menu">
<template>

  <style>/*
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/


:host {
	display: block;
	border-radius: 3px;
	background-color: #fff;
	color: #000;
	max-height: inherit;
}

#menu {
	max-height: inherit;
	overflow: scroll;
	-webkit-overflow-scrolling: touch;
	margin: 0;
}

polyfill-next-selector { content: ':host > .core-selected'; }
::content .core-selected {
	background-color: #eee;
}
</style>

  <core-popup-overlay id="overlay" target="{{}}" sizingtarget="{{$.menu}}" relatedtarget="{{relatedTarget}}" opened="{{opened}}" halign="{{halign}}" valign="{{valign}}" transition="{{transition}}"></core-popup-overlay>

  <core-menu id="menu" selected="{{selected}}" valueattr="{{valueattr}}" selectedclass="{{selectedClass}}" selectedproperty="{{selectedProperty}}" selectedattribute="{{selectedAttribute}}" selecteditem="{{selectedItem}}" selectedmodel="{{selectedModel}}" selectedindex="{{selectedIndex}}" on-core-select="{{selectAction}}">
    <content/>
  </core-menu>

</template>
<script>

  Polymer({

    publish: {

      /**
       * The element associated with this menu, usually the element that
       * causes the menu the open.
       *
       * @attribute relatedTarget
       * @type Node
       */
      relatedTarget: null,

      /**
       * If true, the menu is currently visible.
       *
       * @attribute opened
       * @type boolean
       * @default false
       */
      opened: false,

      /**
       * The horizontal alignment of the pulldown menu relative to the button.
       *
       * @attribute halign
       * @type 'left' | 'right' | 'auto'
       * @default 'auto'
       */
      halign: { value: 'auto', reflect: true },

      /**
       * The vertical alignment of the pulldown menu relative to the button.
       *
       * @attribute valign
       * @type 'bottom' | 'top' | 'auto'
       * @default 'auto'
       */
      valign: { value: 'auto', reflect: true },

      /**
       * The transition property specifies a string which identifies a 
       * <a href="../core-transition/">`core-transition`</a> element that 
       * will be used to help the overlay open and close. The default
       * `core-transition-fade` will cause the overlay to fade in and out.
       *
       * @attribute transition
       * @type string
       * @default 'core-transition-fade'
       */
      transition: null,

      /**
       * Gets or sets the selected element.  Default to use the index
       * of the item element.
       *
       * @attribute selected
       * @type Object
       * @default null
       */
      selected: null,

      /**
       * Specifies the attribute to be used for "selected" attribute.
       *
       * @attribute valueattr
       * @type string
       * @default 'name'
       */
      valueattr: 'name',

      /**
       * Specifies the CSS class to be used to add to the selected element.
       * 
       * @attribute selectedClass
       * @type string
       * @default 'core-selected'
       */
      selectedClass: 'core-selected',

      /**
       * Specifies the property to be used to set on the selected element
       * to indicate its active state.
       *
       * @attribute selectedProperty
       * @type string
       * @default ''
       */
      selectedProperty: '',

      /**
       * Specifies the attribute to set on the selected element to indicate
       * its active state.
       *
       * @attribute selectedAttribute
       * @type string
       * @default 'active'
       */
      selectedAttribute: 'active',

      /**
       * Returns the currently selected element.
       * 
       * @attribute selectedItem
       * @type Object
       * @default null
       */
      selectedItem: null,

      /**
       * In single selection, this returns the model associated with the
       * selected element.
       * 
       * @attribute selectedModel
       * @type Object
       * @default null
       */
      selectedModel: null,

      /**
       * In single selection, this returns the selected index.
       *
       * @attribute selectedIndex
       * @type number
       * @default -1
       */
      selectedIndex: -1

    },

    selectAction: function() {
      this.opened = false;
    }

  });

</script>
</polymer-element>

<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->



  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

  <title>core-popup-menu</title>

  <script>{"version":3,"file":"platform.js","sources":["build/boot.js","../WeakMap/weakmap.js","build/if-poly.js","../observe-js/src/observe.js","../ShadowDOM/src/wrappers.js","../ShadowDOM/src/microtask.js","../ShadowDOM/src/MutationObserver.js","../ShadowDOM/src/TreeScope.js","../ShadowDOM/src/wrappers/events.js","../ShadowDOM/src/wrappers/TouchEvent.js","../ShadowDOM/src/wrappers/NodeList.js","../ShadowDOM/src/wrappers/HTMLCollection.js","../ShadowDOM/src/wrappers/Node.js","../ShadowDOM/src/querySelector.js","../ShadowDOM/src/wrappers/node-interfaces.js","../ShadowDOM/src/wrappers/CharacterData.js","../ShadowDOM/src/wrappers/Text.js","../ShadowDOM/src/wrappers/DOMTokenList.js","../ShadowDOM/src/wrappers/Element.js","../ShadowDOM/src/wrappers/HTMLElement.js","../ShadowDOM/src/wrappers/HTMLCanvasElement.js","../ShadowDOM/src/wrappers/HTMLContentElement.js","../ShadowDOM/src/wrappers/HTMLFormElement.js","../ShadowDOM/src/wrappers/HTMLImageElement.js","../ShadowDOM/src/wrappers/HTMLShadowElement.js","../ShadowDOM/src/wrappers/HTMLTemplateElement.js","../ShadowDOM/src/wrappers/HTMLMediaElement.js","../ShadowDOM/src/wrappers/HTMLAudioElement.js","../ShadowDOM/src/wrappers/HTMLOptionElement.js","../ShadowDOM/src/wrappers/HTMLSelectElement.js","../ShadowDOM/src/wrappers/HTMLTableElement.js","../ShadowDOM/src/wrappers/HTMLTableSectionElement.js","../ShadowDOM/src/wrappers/HTMLTableRowElement.js","../ShadowDOM/src/wrappers/HTMLUnknownElement.js","../ShadowDOM/src/wrappers/SVGElement.js","../ShadowDOM/src/wrappers/SVGUseElement.js","../ShadowDOM/src/wrappers/SVGElementInstance.js","../ShadowDOM/src/wrappers/CanvasRenderingContext2D.js","../ShadowDOM/src/wrappers/WebGLRenderingContext.js","../ShadowDOM/src/wrappers/Range.js","../ShadowDOM/src/wrappers/generic.js","../ShadowDOM/src/wrappers/ShadowRoot.js","../ShadowDOM/src/ShadowRenderer.js","../ShadowDOM/src/wrappers/elements-with-form-property.js","../ShadowDOM/src/wrappers/Selection.js","../ShadowDOM/src/wrappers/Document.js","../ShadowDOM/src/wrappers/Window.js","../ShadowDOM/src/wrappers/DataTransfer.js","../ShadowDOM/src/wrappers/FormData.js","../ShadowDOM/src/wrappers/override-constructors.js","src/patches-shadowdom-polyfill.js","src/ShadowCSS.js","src/patches-shadowdom-native.js","../URL/url.js","src/lang.js","src/dom.js","../MutationObservers/MutationObserver.js","../HTMLImports/src/scope.js","../HTMLImports/src/base.js","../HTMLImports/src/Loader.js","../HTMLImports/src/Parser.js","../HTMLImports/src/HTMLImports.js","../HTMLImports/src/Observer.js","../HTMLImports/src/boot.js","../CustomElements/src/scope.js","../CustomElements/src/Observer.js","../CustomElements/src/CustomElements.js","../CustomElements/src/Parser.js","../CustomElements/src/boot.js","src/patches-custom-elements.js","src/unresolved.js","src/module.js"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nwindow.Platform = window.Platform || {};\n// prepopulate window.logFlags if necessary\nwindow.logFlags = window.logFlags || {};\n// process flags\n(function(scope){\n  // import\n  var flags = scope.flags || {};\n  // populate flags from location\n  location.search.slice(1).split('&').forEach(function(o) {\n    o = o.split('=');\n    o[0] && (flags[o[0]] = o[1] || true);\n  });\n  var entryPoint = document.currentScript ||\n      document.querySelector('script[src*=\"platform.js\"]');\n  if (entryPoint) {\n    var a = entryPoint.attributes;\n    for (var i = 0, n; i < a.length; i++) {\n      n = a[i];\n      if (n.name !== 'src') {\n        flags[n.name] = n.value || true;\n      }\n    }\n  }\n  if (flags.log) {\n    flags.log.split(',').forEach(function(f) {\n      window.logFlags[f] = true;\n    });\n  }\n  // If any of these flags match 'native', then force native ShadowDOM; any\n  // other truthy value, or failure to detect native\n  // ShadowDOM, results in polyfill\n  flags.shadow = flags.shadow || flags.shadowdom || flags.polyfill;\n  if (flags.shadow === 'native') {\n    flags.shadow = false;\n  } else {\n    flags.shadow = flags.shadow || !HTMLElement.prototype.createShadowRoot;\n  }\n\n  if (flags.shadow && document.querySelectorAll('script').length > 1) {\n    console.warn('platform.js is not the first script on the page. ' +\n        'See http://www.polymer-project.org/docs/start/platform.html#setup ' +\n        'for details.');\n  }\n\n  // CustomElements polyfill flag\n  if (flags.register) {\n    window.CustomElements = window.CustomElements || {flags: {}};\n    window.CustomElements.flags.register = flags.register;\n  }\n\n  if (flags.imports) {\n    window.HTMLImports = window.HTMLImports || {flags: {}};\n    window.HTMLImports.flags.imports = flags.imports;\n  }\n\n  // export\n  scope.flags = flags;\n})(Platform);\n","/*\n * Copyright 2012 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\nif (typeof WeakMap === 'undefined') {\n  (function() {\n    var defineProperty = Object.defineProperty;\n    var counter = Date.now() % 1e9;\n\n    var WeakMap = function() {\n      this.name = '__st' + (Math.random() * 1e9 >>> 0) + (counter++ + '__');\n    };\n\n    WeakMap.prototype = {\n      set: function(key, value) {\n        var entry = key[this.name];\n        if (entry && entry[0] === key)\n          entry[1] = value;\n        else\n          defineProperty(key, this.name, {value: [key, value], writable: true});\n      },\n      get: function(key) {\n        var entry;\n        return (entry = key[this.name]) && entry[0] === key ?\n            entry[1] : undefined;\n      },\n      delete: function(key) {\n        var entry = key[this.name];\n        if (!entry) return false;\n        var hasValue = entry[0] === key;\n        entry[0] = entry[1] = undefined;\n        return hasValue;\n      },\n      has: function(key) {\n        var entry = key[this.name];\n        if (!entry) return false;\n        return entry[0] === key;\n      }\n    };\n\n    window.WeakMap = WeakMap;\n  })();\n}\n","// select ShadowDOM impl\r\nif (Platform.flags.shadow) {\r\n","// Copyright 2012 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n(function(global) {\n  'use strict';\n\n  var testingExposeCycleCount = global.testingExposeCycleCount;\n\n  // Detect and do basic sanity checking on Object/Array.observe.\n  function detectObjectObserve() {\n    if (typeof Object.observe !== 'function' ||\n        typeof Array.observe !== 'function') {\n      return false;\n    }\n\n    var records = [];\n\n    function callback(recs) {\n      records = recs;\n    }\n\n    var test = {};\n    var arr = [];\n    Object.observe(test, callback);\n    Array.observe(arr, callback);\n    test.id = 1;\n    test.id = 2;\n    delete test.id;\n    arr.push(1, 2);\n    arr.length = 0;\n\n    Object.deliverChangeRecords(callback);\n    if (records.length !== 5)\n      return false;\n\n    if (records[0].type != 'add' ||\n        records[1].type != 'update' ||\n        records[2].type != 'delete' ||\n        records[3].type != 'splice' ||\n        records[4].type != 'splice') {\n      return false;\n    }\n\n    Object.unobserve(test, callback);\n    Array.unobserve(arr, callback);\n\n    return true;\n  }\n\n  var hasObserve = detectObjectObserve();\n\n  function detectEval() {\n    // Don't test for eval if we're running in a Chrome App environment.\n    // We check for APIs set that only exist in a Chrome App context.\n    if (typeof chrome !== 'undefined' && chrome.app && chrome.app.runtime) {\n      return false;\n    }\n\n    // Firefox OS Apps do not allow eval. This feature detection is very hacky\n    // but even if some other platform adds support for this function this code\n    // will continue to work.\n    if (navigator.getDeviceStorage) {\n      return false;\n    }\n\n    try {\n      var f = new Function('', 'return true;');\n      return f();\n    } catch (ex) {\n      return false;\n    }\n  }\n\n  var hasEval = detectEval();\n\n  function isIndex(s) {\n    return +s === s >>> 0;\n  }\n\n  function toNumber(s) {\n    return +s;\n  }\n\n  function isObject(obj) {\n    return obj === Object(obj);\n  }\n\n  var numberIsNaN = global.Number.isNaN || function(value) {\n    return typeof value === 'number' && global.isNaN(value);\n  }\n\n  function areSameValue(left, right) {\n    if (left === right)\n      return left !== 0 || 1 / left === 1 / right;\n    if (numberIsNaN(left) && numberIsNaN(right))\n      return true;\n\n    return left !== left && right !== right;\n  }\n\n  var createObject = ('__proto__' in {}) ?\n    function(obj) { return obj; } :\n    function(obj) {\n      var proto = obj.__proto__;\n      if (!proto)\n        return obj;\n      var newObject = Object.create(proto);\n      Object.getOwnPropertyNames(obj).forEach(function(name) {\n        Object.defineProperty(newObject, name,\n                             Object.getOwnPropertyDescriptor(obj, name));\n      });\n      return newObject;\n    };\n\n  var identStart = '[\\$_a-zA-Z]';\n  var identPart = '[\\$_a-zA-Z0-9]';\n  var identRegExp = new RegExp('^' + identStart + '+' + identPart + '*' + '$');\n\n  function getPathCharType(char) {\n    if (char === undefined)\n      return 'eof';\n\n    var code = char.charCodeAt(0);\n\n    switch(code) {\n      case 0x5B: // [\n      case 0x5D: // ]\n      case 0x2E: // .\n      case 0x22: // \"\n      case 0x27: // '\n      case 0x30: // 0\n        return char;\n\n      case 0x5F: // _\n      case 0x24: // $\n        return 'ident';\n\n      case 0x20: // Space\n      case 0x09: // Tab\n      case 0x0A: // Newline\n      case 0x0D: // Return\n      case 0xA0:  // No-break space\n      case 0xFEFF:  // Byte Order Mark\n      case 0x2028:  // Line Separator\n      case 0x2029:  // Paragraph Separator\n        return 'ws';\n    }\n\n    // a-z, A-Z\n    if ((0x61 <= code && code <= 0x7A) || (0x41 <= code && code <= 0x5A))\n      return 'ident';\n\n    // 1-9\n    if (0x31 <= code && code <= 0x39)\n      return 'number';\n\n    return 'else';\n  }\n\n  var pathStateMachine = {\n    'beforePath': {\n      'ws': ['beforePath'],\n      'ident': ['inIdent', 'append'],\n      '[': ['beforeElement'],\n      'eof': ['afterPath']\n    },\n\n    'inPath': {\n      'ws': ['inPath'],\n      '.': ['beforeIdent'],\n      '[': ['beforeElement'],\n      'eof': ['afterPath']\n    },\n\n    'beforeIdent': {\n      'ws': ['beforeIdent'],\n      'ident': ['inIdent', 'append']\n    },\n\n    'inIdent': {\n      'ident': ['inIdent', 'append'],\n      '0': ['inIdent', 'append'],\n      'number': ['inIdent', 'append'],\n      'ws': ['inPath', 'push'],\n      '.': ['beforeIdent', 'push'],\n      '[': ['beforeElement', 'push'],\n      'eof': ['afterPath', 'push']\n    },\n\n    'beforeElement': {\n      'ws': ['beforeElement'],\n      '0': ['afterZero', 'append'],\n      'number': ['inIndex', 'append'],\n      \"'\": ['inSingleQuote', 'append', ''],\n      '\"': ['inDoubleQuote', 'append', '']\n    },\n\n    'afterZero': {\n      'ws': ['afterElement', 'push'],\n      ']': ['inPath', 'push']\n    },\n\n    'inIndex': {\n      '0': ['inIndex', 'append'],\n      'number': ['inIndex', 'append'],\n      'ws': ['afterElement'],\n      ']': ['inPath', 'push']\n    },\n\n    'inSingleQuote': {\n      \"'\": ['afterElement'],\n      'eof': ['error'],\n      'else': ['inSingleQuote', 'append']\n    },\n\n    'inDoubleQuote': {\n      '\"': ['afterElement'],\n      'eof': ['error'],\n      'else': ['inDoubleQuote', 'append']\n    },\n\n    'afterElement': {\n      'ws': ['afterElement'],\n      ']': ['inPath', 'push']\n    }\n  }\n\n  function noop() {}\n\n  function parsePath(path) {\n    var keys = [];\n    var index = -1;\n    var c, newChar, key, type, transition, action, typeMap, mode = 'beforePath';\n\n    var actions = {\n      push: function() {\n        if (key === undefined)\n          return;\n\n        keys.push(key);\n        key = undefined;\n      },\n\n      append: function() {\n        if (key === undefined)\n          key = newChar\n        else\n          key += newChar;\n      }\n    };\n\n    function maybeUnescapeQuote() {\n      if (index >= path.length)\n        return;\n\n      var nextChar = path[index + 1];\n      if ((mode == 'inSingleQuote' && nextChar == \"'\") ||\n          (mode == 'inDoubleQuote' && nextChar == '\"')) {\n        index++;\n        newChar = nextChar;\n        actions.append();\n        return true;\n      }\n    }\n\n    while (mode) {\n      index++;\n      c = path[index];\n\n      if (c == '\\\\' && maybeUnescapeQuote(mode))\n        continue;\n\n      type = getPathCharType(c);\n      typeMap = pathStateMachine[mode];\n      transition = typeMap[type] || typeMap['else'] || 'error';\n\n      if (transition == 'error')\n        return; // parse error;\n\n      mode = transition[0];\n      action = actions[transition[1]] || noop;\n      newChar = transition[2] === undefined ? c : transition[2];\n      action();\n\n      if (mode === 'afterPath') {\n        return keys;\n      }\n    }\n\n    return; // parse error\n  }\n\n  function isIdent(s) {\n    return identRegExp.test(s);\n  }\n\n  var constructorIsPrivate = {};\n\n  function Path(parts, privateToken) {\n    if (privateToken !== constructorIsPrivate)\n      throw Error('Use Path.get to retrieve path objects');\n\n    for (var i = 0; i < parts.length; i++) {\n      this.push(String(parts[i]));\n    }\n\n    if (hasEval && this.length) {\n      this.getValueFrom = this.compiledGetValueFromFn();\n    }\n  }\n\n  // TODO(rafaelw): Make simple LRU cache\n  var pathCache = {};\n\n  function getPath(pathString) {\n    if (pathString instanceof Path)\n      return pathString;\n\n    if (pathString == null || pathString.length == 0)\n      pathString = '';\n\n    if (typeof pathString != 'string') {\n      if (isIndex(pathString.length)) {\n        // Constructed with array-like (pre-parsed) keys\n        return new Path(pathString, constructorIsPrivate);\n      }\n\n      pathString = String(pathString);\n    }\n\n    var path = pathCache[pathString];\n    if (path)\n      return path;\n\n    var parts = parsePath(pathString);\n    if (!parts)\n      return invalidPath;\n\n    var path = new Path(parts, constructorIsPrivate);\n    pathCache[pathString] = path;\n    return path;\n  }\n\n  Path.get = getPath;\n\n  function formatAccessor(key) {\n    if (isIndex(key)) {\n      return '[' + key + ']';\n    } else {\n      return '[\"' + key.replace(/\"/g, '\\\\\"') + '\"]';\n    }\n  }\n\n  Path.prototype = createObject({\n    __proto__: [],\n    valid: true,\n\n    toString: function() {\n      var pathString = '';\n      for (var i = 0; i < this.length; i++) {\n        var key = this[i];\n        if (isIdent(key)) {\n          pathString += i ? '.' + key : key;\n        } else {\n          pathString += formatAccessor(key);\n        }\n      }\n\n      return pathString;\n    },\n\n    getValueFrom: function(obj, directObserver) {\n      for (var i = 0; i < this.length; i++) {\n        if (obj == null)\n          return;\n        obj = obj[this[i]];\n      }\n      return obj;\n    },\n\n    iterateObjects: function(obj, observe) {\n      for (var i = 0; i < this.length; i++) {\n        if (i)\n          obj = obj[this[i - 1]];\n        if (!isObject(obj))\n          return;\n        observe(obj, this[0]);\n      }\n    },\n\n    compiledGetValueFromFn: function() {\n      var str = '';\n      var pathString = 'obj';\n      str += 'if (obj != null';\n      var i = 0;\n      var key;\n      for (; i < (this.length - 1); i++) {\n        key = this[i];\n        pathString += isIdent(key) ? '.' + key : formatAccessor(key);\n        str += ' &&\\n     ' + pathString + ' != null';\n      }\n      str += ')\\n';\n\n      var key = this[i];\n      pathString += isIdent(key) ? '.' + key : formatAccessor(key);\n\n      str += '  return ' + pathString + ';\\nelse\\n  return undefined;';\n      return new Function('obj', str);\n    },\n\n    setValueFrom: function(obj, value) {\n      if (!this.length)\n        return false;\n\n      for (var i = 0; i < this.length - 1; i++) {\n        if (!isObject(obj))\n          return false;\n        obj = obj[this[i]];\n      }\n\n      if (!isObject(obj))\n        return false;\n\n      obj[this[i]] = value;\n      return true;\n    }\n  });\n\n  var invalidPath = new Path('', constructorIsPrivate);\n  invalidPath.valid = false;\n  invalidPath.getValueFrom = invalidPath.setValueFrom = function() {};\n\n  var MAX_DIRTY_CHECK_CYCLES = 1000;\n\n  function dirtyCheck(observer) {\n    var cycles = 0;\n    while (cycles < MAX_DIRTY_CHECK_CYCLES && observer.check_()) {\n      cycles++;\n    }\n    if (testingExposeCycleCount)\n      global.dirtyCheckCycleCount = cycles;\n\n    return cycles > 0;\n  }\n\n  function objectIsEmpty(object) {\n    for (var prop in object)\n      return false;\n    return true;\n  }\n\n  function diffIsEmpty(diff) {\n    return objectIsEmpty(diff.added) &&\n           objectIsEmpty(diff.removed) &&\n           objectIsEmpty(diff.changed);\n  }\n\n  function diffObjectFromOldObject(object, oldObject) {\n    var added = {};\n    var removed = {};\n    var changed = {};\n\n    for (var prop in oldObject) {\n      var newValue = object[prop];\n\n      if (newValue !== undefined && newValue === oldObject[prop])\n        continue;\n\n      if (!(prop in object)) {\n        removed[prop] = undefined;\n        continue;\n      }\n\n      if (newValue !== oldObject[prop])\n        changed[prop] = newValue;\n    }\n\n    for (var prop in object) {\n      if (prop in oldObject)\n        continue;\n\n      added[prop] = object[prop];\n    }\n\n    if (Array.isArray(object) && object.length !== oldObject.length)\n      changed.length = object.length;\n\n    return {\n      added: added,\n      removed: removed,\n      changed: changed\n    };\n  }\n\n  var eomTasks = [];\n  function runEOMTasks() {\n    if (!eomTasks.length)\n      return false;\n\n    for (var i = 0; i < eomTasks.length; i++) {\n      eomTasks[i]();\n    }\n    eomTasks.length = 0;\n    return true;\n  }\n\n  var runEOM = hasObserve ? (function(){\n    var eomObj = { pingPong: true };\n    var eomRunScheduled = false;\n\n    Object.observe(eomObj, function() {\n      runEOMTasks();\n      eomRunScheduled = false;\n    });\n\n    return function(fn) {\n      eomTasks.push(fn);\n      if (!eomRunScheduled) {\n        eomRunScheduled = true;\n        eomObj.pingPong = !eomObj.pingPong;\n      }\n    };\n  })() :\n  (function() {\n    return function(fn) {\n      eomTasks.push(fn);\n    };\n  })();\n\n  var observedObjectCache = [];\n\n  function newObservedObject() {\n    var observer;\n    var object;\n    var discardRecords = false;\n    var first = true;\n\n    function callback(records) {\n      if (observer && observer.state_ === OPENED && !discardRecords)\n        observer.check_(records);\n    }\n\n    return {\n      open: function(obs) {\n        if (observer)\n          throw Error('ObservedObject in use');\n\n        if (!first)\n          Object.deliverChangeRecords(callback);\n\n        observer = obs;\n        first = false;\n      },\n      observe: function(obj, arrayObserve) {\n        object = obj;\n        if (arrayObserve)\n          Array.observe(object, callback);\n        else\n          Object.observe(object, callback);\n      },\n      deliver: function(discard) {\n        discardRecords = discard;\n        Object.deliverChangeRecords(callback);\n        discardRecords = false;\n      },\n      close: function() {\n        observer = undefined;\n        Object.unobserve(object, callback);\n        observedObjectCache.push(this);\n      }\n    };\n  }\n\n  /*\n   * The observedSet abstraction is a perf optimization which reduces the total\n   * number of Object.observe observations of a set of objects. The idea is that\n   * groups of Observers will have some object dependencies in common and this\n   * observed set ensures that each object in the transitive closure of\n   * dependencies is only observed once. The observedSet acts as a write barrier\n   * such that whenever any change comes through, all Observers are checked for\n   * changed values.\n   *\n   * Note that this optimization is explicitly moving work from setup-time to\n   * change-time.\n   *\n   * TODO(rafaelw): Implement \"garbage collection\". In order to move work off\n   * the critical path, when Observers are closed, their observed objects are\n   * not Object.unobserve(d). As a result, it's possible that if the observedSet\n   * is kept open, but some Observers have been closed, it could cause \"leaks\"\n   * (prevent otherwise collectable objects from being collected). At some\n   * point, we should implement incremental \"gc\" which keeps a list of\n   * observedSets which may need clean-up and does small amounts of cleanup on a\n   * timeout until all is clean.\n   */\n\n  function getObservedObject(observer, object, arrayObserve) {\n    var dir = observedObjectCache.pop() || newObservedObject();\n    dir.open(observer);\n    dir.observe(object, arrayObserve);\n    return dir;\n  }\n\n  var observedSetCache = [];\n\n  function newObservedSet() {\n    var observerCount = 0;\n    var observers = [];\n    var objects = [];\n    var rootObj;\n    var rootObjProps;\n\n    function observe(obj, prop) {\n      if (!obj)\n        return;\n\n      if (obj === rootObj)\n        rootObjProps[prop] = true;\n\n      if (objects.indexOf(obj) < 0) {\n        objects.push(obj);\n        Object.observe(obj, callback);\n      }\n\n      observe(Object.getPrototypeOf(obj), prop);\n    }\n\n    function allRootObjNonObservedProps(recs) {\n      for (var i = 0; i < recs.length; i++) {\n        var rec = recs[i];\n        if (rec.object !== rootObj ||\n            rootObjProps[rec.name] ||\n            rec.type === 'setPrototype') {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    function callback(recs) {\n      if (allRootObjNonObservedProps(recs))\n        return;\n\n      var observer;\n      for (var i = 0; i < observers.length; i++) {\n        observer = observers[i];\n        if (observer.state_ == OPENED) {\n          observer.iterateObjects_(observe);\n        }\n      }\n\n      for (var i = 0; i < observers.length; i++) {\n        observer = observers[i];\n        if (observer.state_ == OPENED) {\n          observer.check_();\n        }\n      }\n    }\n\n    var record = {\n      object: undefined,\n      objects: objects,\n      open: function(obs, object) {\n        if (!rootObj) {\n          rootObj = object;\n          rootObjProps = {};\n        }\n\n        observers.push(obs);\n        observerCount++;\n        obs.iterateObjects_(observe);\n      },\n      close: function(obs) {\n        observerCount--;\n        if (observerCount > 0) {\n          return;\n        }\n\n        for (var i = 0; i < objects.length; i++) {\n          Object.unobserve(objects[i], callback);\n          Observer.unobservedCount++;\n        }\n\n        observers.length = 0;\n        objects.length = 0;\n        rootObj = undefined;\n        rootObjProps = undefined;\n        observedSetCache.push(this);\n      }\n    };\n\n    return record;\n  }\n\n  var lastObservedSet;\n\n  function getObservedSet(observer, obj) {\n    if (!lastObservedSet || lastObservedSet.object !== obj) {\n      lastObservedSet = observedSetCache.pop() || newObservedSet();\n      lastObservedSet.object = obj;\n    }\n    lastObservedSet.open(observer, obj);\n    return lastObservedSet;\n  }\n\n  var UNOPENED = 0;\n  var OPENED = 1;\n  var CLOSED = 2;\n  var RESETTING = 3;\n\n  var nextObserverId = 1;\n\n  function Observer() {\n    this.state_ = UNOPENED;\n    this.callback_ = undefined;\n    this.target_ = undefined; // TODO(rafaelw): Should be WeakRef\n    this.directObserver_ = undefined;\n    this.value_ = undefined;\n    this.id_ = nextObserverId++;\n  }\n\n  Observer.prototype = {\n    open: function(callback, target) {\n      if (this.state_ != UNOPENED)\n        throw Error('Observer has already been opened.');\n\n      addToAll(this);\n      this.callback_ = callback;\n      this.target_ = target;\n      this.connect_();\n      this.state_ = OPENED;\n      return this.value_;\n    },\n\n    close: function() {\n      if (this.state_ != OPENED)\n        return;\n\n      removeFromAll(this);\n      this.disconnect_();\n      this.value_ = undefined;\n      this.callback_ = undefined;\n      this.target_ = undefined;\n      this.state_ = CLOSED;\n    },\n\n    deliver: function() {\n      if (this.state_ != OPENED)\n        return;\n\n      dirtyCheck(this);\n    },\n\n    report_: function(changes) {\n      try {\n        this.callback_.apply(this.target_, changes);\n      } catch (ex) {\n        Observer._errorThrownDuringCallback = true;\n        console.error('Exception caught during observer callback: ' +\n                       (ex.stack || ex));\n      }\n    },\n\n    discardChanges: function() {\n      this.check_(undefined, true);\n      return this.value_;\n    }\n  }\n\n  var collectObservers = !hasObserve;\n  var allObservers;\n  Observer._allObserversCount = 0;\n\n  if (collectObservers) {\n    allObservers = [];\n  }\n\n  function addToAll(observer) {\n    Observer._allObserversCount++;\n    if (!collectObservers)\n      return;\n\n    allObservers.push(observer);\n  }\n\n  function removeFromAll(observer) {\n    Observer._allObserversCount--;\n  }\n\n  var runningMicrotaskCheckpoint = false;\n\n  var hasDebugForceFullDelivery = hasObserve && hasEval && (function() {\n    try {\n      eval('%RunMicrotasks()');\n      return true;\n    } catch (ex) {\n      return false;\n    }\n  })();\n\n  global.Platform = global.Platform || {};\n\n  global.Platform.performMicrotaskCheckpoint = function() {\n    if (runningMicrotaskCheckpoint)\n      return;\n\n    if (hasDebugForceFullDelivery) {\n      eval('%RunMicrotasks()');\n      return;\n    }\n\n    if (!collectObservers)\n      return;\n\n    runningMicrotaskCheckpoint = true;\n\n    var cycles = 0;\n    var anyChanged, toCheck;\n\n    do {\n      cycles++;\n      toCheck = allObservers;\n      allObservers = [];\n      anyChanged = false;\n\n      for (var i = 0; i < toCheck.length; i++) {\n        var observer = toCheck[i];\n        if (observer.state_ != OPENED)\n          continue;\n\n        if (observer.check_())\n          anyChanged = true;\n\n        allObservers.push(observer);\n      }\n      if (runEOMTasks())\n        anyChanged = true;\n    } while (cycles < MAX_DIRTY_CHECK_CYCLES && anyChanged);\n\n    if (testingExposeCycleCount)\n      global.dirtyCheckCycleCount = cycles;\n\n    runningMicrotaskCheckpoint = false;\n  };\n\n  if (collectObservers) {\n    global.Platform.clearObservers = function() {\n      allObservers = [];\n    };\n  }\n\n  function ObjectObserver(object) {\n    Observer.call(this);\n    this.value_ = object;\n    this.oldObject_ = undefined;\n  }\n\n  ObjectObserver.prototype = createObject({\n    __proto__: Observer.prototype,\n\n    arrayObserve: false,\n\n    connect_: function(callback, target) {\n      if (hasObserve) {\n        this.directObserver_ = getObservedObject(this, this.value_,\n                                                 this.arrayObserve);\n      } else {\n        this.oldObject_ = this.copyObject(this.value_);\n      }\n\n    },\n\n    copyObject: function(object) {\n      var copy = Array.isArray(object) ? [] : {};\n      for (var prop in object) {\n        copy[prop] = object[prop];\n      };\n      if (Array.isArray(object))\n        copy.length = object.length;\n      return copy;\n    },\n\n    check_: function(changeRecords, skipChanges) {\n      var diff;\n      var oldValues;\n      if (hasObserve) {\n        if (!changeRecords)\n          return false;\n\n        oldValues = {};\n        diff = diffObjectFromChangeRecords(this.value_, changeRecords,\n                                           oldValues);\n      } else {\n        oldValues = this.oldObject_;\n        diff = diffObjectFromOldObject(this.value_, this.oldObject_);\n      }\n\n      if (diffIsEmpty(diff))\n        return false;\n\n      if (!hasObserve)\n        this.oldObject_ = this.copyObject(this.value_);\n\n      this.report_([\n        diff.added || {},\n        diff.removed || {},\n        diff.changed || {},\n        function(property) {\n          return oldValues[property];\n        }\n      ]);\n\n      return true;\n    },\n\n    disconnect_: function() {\n      if (hasObserve) {\n        this.directObserver_.close();\n        this.directObserver_ = undefined;\n      } else {\n        this.oldObject_ = undefined;\n      }\n    },\n\n    deliver: function() {\n      if (this.state_ != OPENED)\n        return;\n\n      if (hasObserve)\n        this.directObserver_.deliver(false);\n      else\n        dirtyCheck(this);\n    },\n\n    discardChanges: function() {\n      if (this.directObserver_)\n        this.directObserver_.deliver(true);\n      else\n        this.oldObject_ = this.copyObject(this.value_);\n\n      return this.value_;\n    }\n  });\n\n  function ArrayObserver(array) {\n    if (!Array.isArray(array))\n      throw Error('Provided object is not an Array');\n    ObjectObserver.call(this, array);\n  }\n\n  ArrayObserver.prototype = createObject({\n\n    __proto__: ObjectObserver.prototype,\n\n    arrayObserve: true,\n\n    copyObject: function(arr) {\n      return arr.slice();\n    },\n\n    check_: function(changeRecords) {\n      var splices;\n      if (hasObserve) {\n        if (!changeRecords)\n          return false;\n        splices = projectArraySplices(this.value_, changeRecords);\n      } else {\n        splices = calcSplices(this.value_, 0, this.value_.length,\n                              this.oldObject_, 0, this.oldObject_.length);\n      }\n\n      if (!splices || !splices.length)\n        return false;\n\n      if (!hasObserve)\n        this.oldObject_ = this.copyObject(this.value_);\n\n      this.report_([splices]);\n      return true;\n    }\n  });\n\n  ArrayObserver.applySplices = function(previous, current, splices) {\n    splices.forEach(function(splice) {\n      var spliceArgs = [splice.index, splice.removed.length];\n      var addIndex = splice.index;\n      while (addIndex < splice.index + splice.addedCount) {\n        spliceArgs.push(current[addIndex]);\n        addIndex++;\n      }\n\n      Array.prototype.splice.apply(previous, spliceArgs);\n    });\n  };\n\n  function PathObserver(object, path) {\n    Observer.call(this);\n\n    this.object_ = object;\n    this.path_ = getPath(path);\n    this.directObserver_ = undefined;\n  }\n\n  PathObserver.prototype = createObject({\n    __proto__: Observer.prototype,\n\n    get path() {\n      return this.path_;\n    },\n\n    connect_: function() {\n      if (hasObserve)\n        this.directObserver_ = getObservedSet(this, this.object_);\n\n      this.check_(undefined, true);\n    },\n\n    disconnect_: function() {\n      this.value_ = undefined;\n\n      if (this.directObserver_) {\n        this.directObserver_.close(this);\n        this.directObserver_ = undefined;\n      }\n    },\n\n    iterateObjects_: function(observe) {\n      this.path_.iterateObjects(this.object_, observe);\n    },\n\n    check_: function(changeRecords, skipChanges) {\n      var oldValue = this.value_;\n      this.value_ = this.path_.getValueFrom(this.object_);\n      if (skipChanges || areSameValue(this.value_, oldValue))\n        return false;\n\n      this.report_([this.value_, oldValue, this]);\n      return true;\n    },\n\n    setValue: function(newValue) {\n      if (this.path_)\n        this.path_.setValueFrom(this.object_, newValue);\n    }\n  });\n\n  function CompoundObserver(reportChangesOnOpen) {\n    Observer.call(this);\n\n    this.reportChangesOnOpen_ = reportChangesOnOpen;\n    this.value_ = [];\n    this.directObserver_ = undefined;\n    this.observed_ = [];\n  }\n\n  var observerSentinel = {};\n\n  CompoundObserver.prototype = createObject({\n    __proto__: Observer.prototype,\n\n    connect_: function() {\n      if (hasObserve) {\n        var object;\n        var needsDirectObserver = false;\n        for (var i = 0; i < this.observed_.length; i += 2) {\n          object = this.observed_[i]\n          if (object !== observerSentinel) {\n            needsDirectObserver = true;\n            break;\n          }\n        }\n\n        if (needsDirectObserver)\n          this.directObserver_ = getObservedSet(this, object);\n      }\n\n      this.check_(undefined, !this.reportChangesOnOpen_);\n    },\n\n    disconnect_: function() {\n      for (var i = 0; i < this.observed_.length; i += 2) {\n        if (this.observed_[i] === observerSentinel)\n          this.observed_[i + 1].close();\n      }\n      this.observed_.length = 0;\n      this.value_.length = 0;\n\n      if (this.directObserver_) {\n        this.directObserver_.close(this);\n        this.directObserver_ = undefined;\n      }\n    },\n\n    addPath: function(object, path) {\n      if (this.state_ != UNOPENED && this.state_ != RESETTING)\n        throw Error('Cannot add paths once started.');\n\n      var path = getPath(path);\n      this.observed_.push(object, path);\n      if (!this.reportChangesOnOpen_)\n        return;\n      var index = this.observed_.length / 2 - 1;\n      this.value_[index] = path.getValueFrom(object);\n    },\n\n    addObserver: function(observer) {\n      if (this.state_ != UNOPENED && this.state_ != RESETTING)\n        throw Error('Cannot add observers once started.');\n\n      this.observed_.push(observerSentinel, observer);\n      if (!this.reportChangesOnOpen_)\n        return;\n      var index = this.observed_.length / 2 - 1;\n      this.value_[index] = observer.open(this.deliver, this);\n    },\n\n    startReset: function() {\n      if (this.state_ != OPENED)\n        throw Error('Can only reset while open');\n\n      this.state_ = RESETTING;\n      this.disconnect_();\n    },\n\n    finishReset: function() {\n      if (this.state_ != RESETTING)\n        throw Error('Can only finishReset after startReset');\n      this.state_ = OPENED;\n      this.connect_();\n\n      return this.value_;\n    },\n\n    iterateObjects_: function(observe) {\n      var object;\n      for (var i = 0; i < this.observed_.length; i += 2) {\n        object = this.observed_[i]\n        if (object !== observerSentinel)\n          this.observed_[i + 1].iterateObjects(object, observe)\n      }\n    },\n\n    check_: function(changeRecords, skipChanges) {\n      var oldValues;\n      for (var i = 0; i < this.observed_.length; i += 2) {\n        var object = this.observed_[i];\n        var path = this.observed_[i+1];\n        var value;\n        if (object === observerSentinel) {\n          var observable = path;\n          value = this.state_ === UNOPENED ?\n              observable.open(this.deliver, this) :\n              observable.discardChanges();\n        } else {\n          value = path.getValueFrom(object);\n        }\n\n        if (skipChanges) {\n          this.value_[i / 2] = value;\n          continue;\n        }\n\n        if (areSameValue(value, this.value_[i / 2]))\n          continue;\n\n        oldValues = oldValues || [];\n        oldValues[i / 2] = this.value_[i / 2];\n        this.value_[i / 2] = value;\n      }\n\n      if (!oldValues)\n        return false;\n\n      // TODO(rafaelw): Having observed_ as the third callback arg here is\n      // pretty lame API. Fix.\n      this.report_([this.value_, oldValues, this.observed_]);\n      return true;\n    }\n  });\n\n  function identFn(value) { return value; }\n\n  function ObserverTransform(observable, getValueFn, setValueFn,\n                             dontPassThroughSet) {\n    this.callback_ = undefined;\n    this.target_ = undefined;\n    this.value_ = undefined;\n    this.observable_ = observable;\n    this.getValueFn_ = getValueFn || identFn;\n    this.setValueFn_ = setValueFn || identFn;\n    // TODO(rafaelw): This is a temporary hack. PolymerExpressions needs this\n    // at the moment because of a bug in it's dependency tracking.\n    this.dontPassThroughSet_ = dontPassThroughSet;\n  }\n\n  ObserverTransform.prototype = {\n    open: function(callback, target) {\n      this.callback_ = callback;\n      this.target_ = target;\n      this.value_ =\n          this.getValueFn_(this.observable_.open(this.observedCallback_, this));\n      return this.value_;\n    },\n\n    observedCallback_: function(value) {\n      value = this.getValueFn_(value);\n      if (areSameValue(value, this.value_))\n        return;\n      var oldValue = this.value_;\n      this.value_ = value;\n      this.callback_.call(this.target_, this.value_, oldValue);\n    },\n\n    discardChanges: function() {\n      this.value_ = this.getValueFn_(this.observable_.discardChanges());\n      return this.value_;\n    },\n\n    deliver: function() {\n      return this.observable_.deliver();\n    },\n\n    setValue: function(value) {\n      value = this.setValueFn_(value);\n      if (!this.dontPassThroughSet_ && this.observable_.setValue)\n        return this.observable_.setValue(value);\n    },\n\n    close: function() {\n      if (this.observable_)\n        this.observable_.close();\n      this.callback_ = undefined;\n      this.target_ = undefined;\n      this.observable_ = undefined;\n      this.value_ = undefined;\n      this.getValueFn_ = undefined;\n      this.setValueFn_ = undefined;\n    }\n  }\n\n  var expectedRecordTypes = {\n    add: true,\n    update: true,\n    delete: true\n  };\n\n  function diffObjectFromChangeRecords(object, changeRecords, oldValues) {\n    var added = {};\n    var removed = {};\n\n    for (var i = 0; i < changeRecords.length; i++) {\n      var record = changeRecords[i];\n      if (!expectedRecordTypes[record.type]) {\n        console.error('Unknown changeRecord type: ' + record.type);\n        console.error(record);\n        continue;\n      }\n\n      if (!(record.name in oldValues))\n        oldValues[record.name] = record.oldValue;\n\n      if (record.type == 'update')\n        continue;\n\n      if (record.type == 'add') {\n        if (record.name in removed)\n          delete removed[record.name];\n        else\n          added[record.name] = true;\n\n        continue;\n      }\n\n      // type = 'delete'\n      if (record.name in added) {\n        delete added[record.name];\n        delete oldValues[record.name];\n      } else {\n        removed[record.name] = true;\n      }\n    }\n\n    for (var prop in added)\n      added[prop] = object[prop];\n\n    for (var prop in removed)\n      removed[prop] = undefined;\n\n    var changed = {};\n    for (var prop in oldValues) {\n      if (prop in added || prop in removed)\n        continue;\n\n      var newValue = object[prop];\n      if (oldValues[prop] !== newValue)\n        changed[prop] = newValue;\n    }\n\n    return {\n      added: added,\n      removed: removed,\n      changed: changed\n    };\n  }\n\n  function newSplice(index, removed, addedCount) {\n    return {\n      index: index,\n      removed: removed,\n      addedCount: addedCount\n    };\n  }\n\n  var EDIT_LEAVE = 0;\n  var EDIT_UPDATE = 1;\n  var EDIT_ADD = 2;\n  var EDIT_DELETE = 3;\n\n  function ArraySplice() {}\n\n  ArraySplice.prototype = {\n\n    // Note: This function is *based* on the computation of the Levenshtein\n    // \"edit\" distance. The one change is that \"updates\" are treated as two\n    // edits - not one. With Array splices, an update is really a delete\n    // followed by an add. By retaining this, we optimize for \"keeping\" the\n    // maximum array items in the original array. For example:\n    //\n    //   'xxxx123' -> '123yyyy'\n    //\n    // With 1-edit updates, the shortest path would be just to update all seven\n    // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n    // leaves the substring '123' intact.\n    calcEditDistances: function(current, currentStart, currentEnd,\n                                old, oldStart, oldEnd) {\n      // \"Deletion\" columns\n      var rowCount = oldEnd - oldStart + 1;\n      var columnCount = currentEnd - currentStart + 1;\n      var distances = new Array(rowCount);\n\n      // \"Addition\" rows. Initialize null column.\n      for (var i = 0; i < rowCount; i++) {\n        distances[i] = new Array(columnCount);\n        distances[i][0] = i;\n      }\n\n      // Initialize null row\n      for (var j = 0; j < columnCount; j++)\n        distances[0][j] = j;\n\n      for (var i = 1; i < rowCount; i++) {\n        for (var j = 1; j < columnCount; j++) {\n          if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))\n            distances[i][j] = distances[i - 1][j - 1];\n          else {\n            var north = distances[i - 1][j] + 1;\n            var west = distances[i][j - 1] + 1;\n            distances[i][j] = north < west ? north : west;\n          }\n        }\n      }\n\n      return distances;\n    },\n\n    // This starts at the final weight, and walks \"backward\" by finding\n    // the minimum previous weight recursively until the origin of the weight\n    // matrix.\n    spliceOperationsFromEditDistances: function(distances) {\n      var i = distances.length - 1;\n      var j = distances[0].length - 1;\n      var current = distances[i][j];\n      var edits = [];\n      while (i > 0 || j > 0) {\n        if (i == 0) {\n          edits.push(EDIT_ADD);\n          j--;\n          continue;\n        }\n        if (j == 0) {\n          edits.push(EDIT_DELETE);\n          i--;\n          continue;\n        }\n        var northWest = distances[i - 1][j - 1];\n        var west = distances[i - 1][j];\n        var north = distances[i][j - 1];\n\n        var min;\n        if (west < north)\n          min = west < northWest ? west : northWest;\n        else\n          min = north < northWest ? north : northWest;\n\n        if (min == northWest) {\n          if (northWest == current) {\n            edits.push(EDIT_LEAVE);\n          } else {\n            edits.push(EDIT_UPDATE);\n            current = northWest;\n          }\n          i--;\n          j--;\n        } else if (min == west) {\n          edits.push(EDIT_DELETE);\n          i--;\n          current = west;\n        } else {\n          edits.push(EDIT_ADD);\n          j--;\n          current = north;\n        }\n      }\n\n      edits.reverse();\n      return edits;\n    },\n\n    /**\n     * Splice Projection functions:\n     *\n     * A splice map is a representation of how a previous array of items\n     * was transformed into a new array of items. Conceptually it is a list of\n     * tuples of\n     *\n     *   <index, removed, addedCount>\n     *\n     * which are kept in ascending index order of. The tuple represents that at\n     * the |index|, |removed| sequence of items were removed, and counting forward\n     * from |index|, |addedCount| items were added.\n     */\n\n    /**\n     * Lacking individual splice mutation information, the minimal set of\n     * splices can be synthesized given the previous state and final state of an\n     * array. The basic approach is to calculate the edit distance matrix and\n     * choose the shortest path through it.\n     *\n     * Complexity: O(l * p)\n     *   l: The length of the current array\n     *   p: The length of the old array\n     */\n    calcSplices: function(current, currentStart, currentEnd,\n                          old, oldStart, oldEnd) {\n      var prefixCount = 0;\n      var suffixCount = 0;\n\n      var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n      if (currentStart == 0 && oldStart == 0)\n        prefixCount = this.sharedPrefix(current, old, minLength);\n\n      if (currentEnd == current.length && oldEnd == old.length)\n        suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);\n\n      currentStart += prefixCount;\n      oldStart += prefixCount;\n      currentEnd -= suffixCount;\n      oldEnd -= suffixCount;\n\n      if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)\n        return [];\n\n      if (currentStart == currentEnd) {\n        var splice = newSplice(currentStart, [], 0);\n        while (oldStart < oldEnd)\n          splice.removed.push(old[oldStart++]);\n\n        return [ splice ];\n      } else if (oldStart == oldEnd)\n        return [ newSplice(currentStart, [], currentEnd - currentStart) ];\n\n      var ops = this.spliceOperationsFromEditDistances(\n          this.calcEditDistances(current, currentStart, currentEnd,\n                                 old, oldStart, oldEnd));\n\n      var splice = undefined;\n      var splices = [];\n      var index = currentStart;\n      var oldIndex = oldStart;\n      for (var i = 0; i < ops.length; i++) {\n        switch(ops[i]) {\n          case EDIT_LEAVE:\n            if (splice) {\n              splices.push(splice);\n              splice = undefined;\n            }\n\n            index++;\n            oldIndex++;\n            break;\n          case EDIT_UPDATE:\n            if (!splice)\n              splice = newSplice(index, [], 0);\n\n            splice.addedCount++;\n            index++;\n\n            splice.removed.push(old[oldIndex]);\n            oldIndex++;\n            break;\n          case EDIT_ADD:\n            if (!splice)\n              splice = newSplice(index, [], 0);\n\n            splice.addedCount++;\n            index++;\n            break;\n          case EDIT_DELETE:\n            if (!splice)\n              splice = newSplice(index, [], 0);\n\n            splice.removed.push(old[oldIndex]);\n            oldIndex++;\n            break;\n        }\n      }\n\n      if (splice) {\n        splices.push(splice);\n      }\n      return splices;\n    },\n\n    sharedPrefix: function(current, old, searchLength) {\n      for (var i = 0; i < searchLength; i++)\n        if (!this.equals(current[i], old[i]))\n          return i;\n      return searchLength;\n    },\n\n    sharedSuffix: function(current, old, searchLength) {\n      var index1 = current.length;\n      var index2 = old.length;\n      var count = 0;\n      while (count < searchLength && this.equals(current[--index1], old[--index2]))\n        count++;\n\n      return count;\n    },\n\n    calculateSplices: function(current, previous) {\n      return this.calcSplices(current, 0, current.length, previous, 0,\n                              previous.length);\n    },\n\n    equals: function(currentValue, previousValue) {\n      return currentValue === previousValue;\n    }\n  };\n\n  var arraySplice = new ArraySplice();\n\n  function calcSplices(current, currentStart, currentEnd,\n                       old, oldStart, oldEnd) {\n    return arraySplice.calcSplices(current, currentStart, currentEnd,\n                                   old, oldStart, oldEnd);\n  }\n\n  function intersect(start1, end1, start2, end2) {\n    // Disjoint\n    if (end1 < start2 || end2 < start1)\n      return -1;\n\n    // Adjacent\n    if (end1 == start2 || end2 == start1)\n      return 0;\n\n    // Non-zero intersect, span1 first\n    if (start1 < start2) {\n      if (end1 < end2)\n        return end1 - start2; // Overlap\n      else\n        return end2 - start2; // Contained\n    } else {\n      // Non-zero intersect, span2 first\n      if (end2 < end1)\n        return end2 - start1; // Overlap\n      else\n        return end1 - start1; // Contained\n    }\n  }\n\n  function mergeSplice(splices, index, removed, addedCount) {\n\n    var splice = newSplice(index, removed, addedCount);\n\n    var inserted = false;\n    var insertionOffset = 0;\n\n    for (var i = 0; i < splices.length; i++) {\n      var current = splices[i];\n      current.index += insertionOffset;\n\n      if (inserted)\n        continue;\n\n      var intersectCount = intersect(splice.index,\n                                     splice.index + splice.removed.length,\n                                     current.index,\n                                     current.index + current.addedCount);\n\n      if (intersectCount >= 0) {\n        // Merge the two splices\n\n        splices.splice(i, 1);\n        i--;\n\n        insertionOffset -= current.addedCount - current.removed.length;\n\n        splice.addedCount += current.addedCount - intersectCount;\n        var deleteCount = splice.removed.length +\n                          current.removed.length - intersectCount;\n\n        if (!splice.addedCount && !deleteCount) {\n          // merged splice is a noop. discard.\n          inserted = true;\n        } else {\n          var removed = current.removed;\n\n          if (splice.index < current.index) {\n            // some prefix of splice.removed is prepended to current.removed.\n            var prepend = splice.removed.slice(0, current.index - splice.index);\n            Array.prototype.push.apply(prepend, removed);\n            removed = prepend;\n          }\n\n          if (splice.index + splice.removed.length > current.index + current.addedCount) {\n            // some suffix of splice.removed is appended to current.removed.\n            var append = splice.removed.slice(current.index + current.addedCount - splice.index);\n            Array.prototype.push.apply(removed, append);\n          }\n\n          splice.removed = removed;\n          if (current.index < splice.index) {\n            splice.index = current.index;\n          }\n        }\n      } else if (splice.index < current.index) {\n        // Insert splice here.\n\n        inserted = true;\n\n        splices.splice(i, 0, splice);\n        i++;\n\n        var offset = splice.addedCount - splice.removed.length\n        current.index += offset;\n        insertionOffset += offset;\n      }\n    }\n\n    if (!inserted)\n      splices.push(splice);\n  }\n\n  function createInitialSplices(array, changeRecords) {\n    var splices = [];\n\n    for (var i = 0; i < changeRecords.length; i++) {\n      var record = changeRecords[i];\n      switch(record.type) {\n        case 'splice':\n          mergeSplice(splices, record.index, record.removed.slice(), record.addedCount);\n          break;\n        case 'add':\n        case 'update':\n        case 'delete':\n          if (!isIndex(record.name))\n            continue;\n          var index = toNumber(record.name);\n          if (index < 0)\n            continue;\n          mergeSplice(splices, index, [record.oldValue], 1);\n          break;\n        default:\n          console.error('Unexpected record type: ' + JSON.stringify(record));\n          break;\n      }\n    }\n\n    return splices;\n  }\n\n  function projectArraySplices(array, changeRecords) {\n    var splices = [];\n\n    createInitialSplices(array, changeRecords).forEach(function(splice) {\n      if (splice.addedCount == 1 && splice.removed.length == 1) {\n        if (splice.removed[0] !== array[splice.index])\n          splices.push(splice);\n\n        return\n      };\n\n      splices = splices.concat(calcSplices(array, splice.index, splice.index + splice.addedCount,\n                                           splice.removed, 0, splice.removed.length));\n    });\n\n    return splices;\n  }\n\n  global.Observer = Observer;\n  global.Observer.runEOM_ = runEOM;\n  global.Observer.observerSentinel_ = observerSentinel; // for testing.\n  global.Observer.hasObjectObserve = hasObserve;\n  global.ArrayObserver = ArrayObserver;\n  global.ArrayObserver.calculateSplices = function(current, previous) {\n    return arraySplice.calculateSplices(current, previous);\n  };\n\n  global.ArraySplice = ArraySplice;\n  global.ObjectObserver = ObjectObserver;\n  global.PathObserver = PathObserver;\n  global.CompoundObserver = CompoundObserver;\n  global.Path = Path;\n  global.ObserverTransform = ObserverTransform;\n})(typeof global !== 'undefined' && global && typeof module !== 'undefined' && module ? global : this || window);\n","// Copyright 2012 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\nwindow.ShadowDOMPolyfill = {};\n\n(function(scope) {\n  'use strict';\n\n  var constructorTable = new WeakMap();\n  var nativePrototypeTable = new WeakMap();\n  var wrappers = Object.create(null);\n\n  function detectEval() {\n    // Don't test for eval if we're running in a Chrome App environment.\n    // We check for APIs set that only exist in a Chrome App context.\n    if (typeof chrome !== 'undefined' && chrome.app && chrome.app.runtime) {\n      return false;\n    }\n\n    // Firefox OS Apps do not allow eval. This feature detection is very hacky\n    // but even if some other platform adds support for this function this code\n    // will continue to work.\n    if (navigator.getDeviceStorage) {\n      return false;\n    }\n\n    try {\n      var f = new Function('return true;');\n      return f();\n    } catch (ex) {\n      return false;\n    }\n  }\n\n  var hasEval = detectEval();\n\n  function assert(b) {\n    if (!b)\n      throw new Error('Assertion failed');\n  };\n\n  var defineProperty = Object.defineProperty;\n  var getOwnPropertyNames = Object.getOwnPropertyNames;\n  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n  function mixin(to, from) {\n    var names = getOwnPropertyNames(from);\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i];\n      defineProperty(to, name, getOwnPropertyDescriptor(from, name));\n    }\n    return to;\n  };\n\n  function mixinStatics(to, from) {\n    var names = getOwnPropertyNames(from);\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i];\n      switch (name) {\n        case 'arguments':\n        case 'caller':\n        case 'length':\n        case 'name':\n        case 'prototype':\n        case 'toString':\n          continue;\n      }\n      defineProperty(to, name, getOwnPropertyDescriptor(from, name));\n    }\n    return to;\n  };\n\n  function oneOf(object, propertyNames) {\n    for (var i = 0; i < propertyNames.length; i++) {\n      if (propertyNames[i] in object)\n        return propertyNames[i];\n    }\n  }\n\n  var nonEnumerableDataDescriptor = {\n    value: undefined,\n    configurable: true,\n    enumerable: false,\n    writable: true\n  };\n\n  function defineNonEnumerableDataProperty(object, name, value) {\n    nonEnumerableDataDescriptor.value = value;\n    defineProperty(object, name, nonEnumerableDataDescriptor);\n  }\n\n  // Mozilla's old DOM bindings are bretty busted:\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=855844\n  // Make sure they are create before we start modifying things.\n  getOwnPropertyNames(window);\n\n  function getWrapperConstructor(node) {\n    var nativePrototype = node.__proto__ || Object.getPrototypeOf(node);\n    var wrapperConstructor = constructorTable.get(nativePrototype);\n    if (wrapperConstructor)\n      return wrapperConstructor;\n\n    var parentWrapperConstructor = getWrapperConstructor(nativePrototype);\n\n    var GeneratedWrapper = createWrapperConstructor(parentWrapperConstructor);\n    registerInternal(nativePrototype, GeneratedWrapper, node);\n\n    return GeneratedWrapper;\n  }\n\n  function addForwardingProperties(nativePrototype, wrapperPrototype) {\n    installProperty(nativePrototype, wrapperPrototype, true);\n  }\n\n  function registerInstanceProperties(wrapperPrototype, instanceObject) {\n    installProperty(instanceObject, wrapperPrototype, false);\n  }\n\n  var isFirefox = /Firefox/.test(navigator.userAgent);\n\n  // This is used as a fallback when getting the descriptor fails in\n  // installProperty.\n  var dummyDescriptor = {\n    get: function() {},\n    set: function(v) {},\n    configurable: true,\n    enumerable: true\n  };\n\n  function isEventHandlerName(name) {\n    return /^on[a-z]+$/.test(name);\n  }\n\n  function isIdentifierName(name) {\n    return /^\\w[a-zA-Z_0-9]*$/.test(name);\n  }\n\n  // The name of the implementation property is intentionally hard to\n  // remember. Unfortunately, browsers are slower doing obj[expr] than\n  // obj.foo so we resort to repeat this ugly name. This ugly name is never\n  // used outside of this file though.\n\n  function getGetter(name) {\n    return hasEval && isIdentifierName(name) ?\n        new Function('return this.__impl4cf1e782hg__.' + name) :\n        function() { return this.__impl4cf1e782hg__[name]; };\n  }\n\n  function getSetter(name) {\n    return hasEval && isIdentifierName(name) ?\n        new Function('v', 'this.__impl4cf1e782hg__.' + name + ' = v') :\n        function(v) { this.__impl4cf1e782hg__[name] = v; };\n  }\n\n  function getMethod(name) {\n    return hasEval && isIdentifierName(name) ?\n        new Function('return this.__impl4cf1e782hg__.' + name +\n                     '.apply(this.__impl4cf1e782hg__, arguments)') :\n        function() {\n          return this.__impl4cf1e782hg__[name].apply(\n              this.__impl4cf1e782hg__, arguments);\n        };\n  }\n\n  function getDescriptor(source, name) {\n    try {\n      return Object.getOwnPropertyDescriptor(source, name);\n    } catch (ex) {\n      // JSC and V8 both use data properties instead of accessors which can\n      // cause getting the property desciptor to throw an exception.\n      // https://bugs.webkit.org/show_bug.cgi?id=49739\n      return dummyDescriptor;\n    }\n  }\n\n  function installProperty(source, target, allowMethod, opt_blacklist) {\n    var names = getOwnPropertyNames(source);\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i];\n      if (name === 'polymerBlackList_')\n        continue;\n\n      if (name in target)\n        continue;\n\n      if (source.polymerBlackList_ && source.polymerBlackList_[name])\n        continue;\n\n      if (isFirefox) {\n        // Tickle Firefox's old bindings.\n        source.__lookupGetter__(name);\n      }\n      var descriptor = getDescriptor(source, name);\n      var getter, setter;\n      if (allowMethod && typeof descriptor.value === 'function') {\n        target[name] = getMethod(name);\n        continue;\n      }\n\n      var isEvent = isEventHandlerName(name);\n      if (isEvent)\n        getter = scope.getEventHandlerGetter(name);\n      else\n        getter = getGetter(name);\n\n      if (descriptor.writable || descriptor.set) {\n        if (isEvent)\n          setter = scope.getEventHandlerSetter(name);\n        else\n          setter = getSetter(name);\n      }\n\n      defineProperty(target, name, {\n        get: getter,\n        set: setter,\n        configurable: descriptor.configurable,\n        enumerable: descriptor.enumerable\n      });\n    }\n  }\n\n  /**\n   * @param {Function} nativeConstructor\n   * @param {Function} wrapperConstructor\n   * @param {Object=} opt_instance If present, this is used to extract\n   *     properties from an instance object.\n   */\n  function register(nativeConstructor, wrapperConstructor, opt_instance) {\n    var nativePrototype = nativeConstructor.prototype;\n    registerInternal(nativePrototype, wrapperConstructor, opt_instance);\n    mixinStatics(wrapperConstructor, nativeConstructor);\n  }\n\n  function registerInternal(nativePrototype, wrapperConstructor, opt_instance) {\n    var wrapperPrototype = wrapperConstructor.prototype;\n    assert(constructorTable.get(nativePrototype) === undefined);\n\n    constructorTable.set(nativePrototype, wrapperConstructor);\n    nativePrototypeTable.set(wrapperPrototype, nativePrototype);\n\n    addForwardingProperties(nativePrototype, wrapperPrototype);\n    if (opt_instance)\n      registerInstanceProperties(wrapperPrototype, opt_instance);\n\n    defineNonEnumerableDataProperty(\n        wrapperPrototype, 'constructor', wrapperConstructor);\n    // Set it again. Some VMs optimizes objects that are used as prototypes.\n    wrapperConstructor.prototype = wrapperPrototype;\n  }\n\n  function isWrapperFor(wrapperConstructor, nativeConstructor) {\n    return constructorTable.get(nativeConstructor.prototype) ===\n        wrapperConstructor;\n  }\n\n  /**\n   * Creates a generic wrapper constructor based on |object| and its\n   * constructor.\n   * @param {Node} object\n   * @return {Function} The generated constructor.\n   */\n  function registerObject(object) {\n    var nativePrototype = Object.getPrototypeOf(object);\n\n    var superWrapperConstructor = getWrapperConstructor(nativePrototype);\n    var GeneratedWrapper = createWrapperConstructor(superWrapperConstructor);\n    registerInternal(nativePrototype, GeneratedWrapper, object);\n\n    return GeneratedWrapper;\n  }\n\n  function createWrapperConstructor(superWrapperConstructor) {\n    function GeneratedWrapper(node) {\n      superWrapperConstructor.call(this, node);\n    }\n    var p = Object.create(superWrapperConstructor.prototype);\n    p.constructor = GeneratedWrapper;\n    GeneratedWrapper.prototype = p;\n\n    return GeneratedWrapper;\n  }\n\n  function isWrapper(object) {\n    return object && object.__impl4cf1e782hg__;\n  }\n\n  function isNative(object) {\n    return !isWrapper(object);\n  }\n\n  /**\n   * Wraps a node in a WrapperNode. If there already exists a wrapper for the\n   * |node| that wrapper is returned instead.\n   * @param {Node} node\n   * @return {WrapperNode}\n   */\n  function wrap(impl) {\n    if (impl === null)\n      return null;\n\n    assert(isNative(impl));\n    return impl.__wrapper8e3dd93a60__ ||\n        (impl.__wrapper8e3dd93a60__ = new (getWrapperConstructor(impl))(impl));\n  }\n\n  /**\n   * Unwraps a wrapper and returns the node it is wrapping.\n   * @param {WrapperNode} wrapper\n   * @return {Node}\n   */\n  function unwrap(wrapper) {\n    if (wrapper === null)\n      return null;\n    assert(isWrapper(wrapper));\n    return wrapper.__impl4cf1e782hg__;\n  }\n\n  function unsafeUnwrap(wrapper) {\n    return wrapper.__impl4cf1e782hg__;\n  }\n\n  function setWrapper(impl, wrapper) {\n    wrapper.__impl4cf1e782hg__ = impl;\n    impl.__wrapper8e3dd93a60__ = wrapper;\n  }\n\n  /**\n   * Unwraps object if it is a wrapper.\n   * @param {Object} object\n   * @return {Object} The native implementation object.\n   */\n  function unwrapIfNeeded(object) {\n    return object && isWrapper(object) ? unwrap(object) : object;\n  }\n\n  /**\n   * Wraps object if it is not a wrapper.\n   * @param {Object} object\n   * @return {Object} The wrapper for object.\n   */\n  function wrapIfNeeded(object) {\n    return object && !isWrapper(object) ? wrap(object) : object;\n  }\n\n  /**\n   * Overrides the current wrapper (if any) for node.\n   * @param {Node} node\n   * @param {WrapperNode=} wrapper If left out the wrapper will be created as\n   *     needed next time someone wraps the node.\n   */\n  function rewrap(node, wrapper) {\n    if (wrapper === null)\n      return;\n    assert(isNative(node));\n    assert(wrapper === undefined || isWrapper(wrapper));\n    node.__wrapper8e3dd93a60__ = wrapper;\n  }\n\n  var getterDescriptor = {\n    get: undefined,\n    configurable: true,\n    enumerable: true\n  };\n\n  function defineGetter(constructor, name, getter) {\n    getterDescriptor.get = getter;\n    defineProperty(constructor.prototype, name, getterDescriptor);\n  }\n\n  function defineWrapGetter(constructor, name) {\n    defineGetter(constructor, name, function() {\n      return wrap(this.__impl4cf1e782hg__[name]);\n    });\n  }\n\n  /**\n   * Forwards existing methods on the native object to the wrapper methods.\n   * This does not wrap any of the arguments or the return value since the\n   * wrapper implementation already takes care of that.\n   * @param {Array.<Function>} constructors\n   * @parem {Array.<string>} names\n   */\n  function forwardMethodsToWrapper(constructors, names) {\n    constructors.forEach(function(constructor) {\n      names.forEach(function(name) {\n        constructor.prototype[name] = function() {\n          var w = wrapIfNeeded(this);\n          return w[name].apply(w, arguments);\n        };\n      });\n    });\n  }\n\n  scope.assert = assert;\n  scope.constructorTable = constructorTable;\n  scope.defineGetter = defineGetter;\n  scope.defineWrapGetter = defineWrapGetter;\n  scope.forwardMethodsToWrapper = forwardMethodsToWrapper;\n  scope.isWrapper = isWrapper;\n  scope.isWrapperFor = isWrapperFor;\n  scope.mixin = mixin;\n  scope.nativePrototypeTable = nativePrototypeTable;\n  scope.oneOf = oneOf;\n  scope.registerObject = registerObject;\n  scope.registerWrapper = register;\n  scope.rewrap = rewrap;\n  scope.setWrapper = setWrapper;\n  scope.unsafeUnwrap = unsafeUnwrap;\n  scope.unwrap = unwrap;\n  scope.unwrapIfNeeded = unwrapIfNeeded;\n  scope.wrap = wrap;\n  scope.wrapIfNeeded = wrapIfNeeded;\n  scope.wrappers = wrappers;\n\n})(window.ShadowDOMPolyfill);\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is goverened by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\n(function(context) {\n  'use strict';\n\n  var OriginalMutationObserver = window.MutationObserver;\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n\n  function handle() {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks = [];\n    for (var i = 0; i < copies.length; i++) {\n      (0, copies[i])();\n    }\n  }\n\n  if (OriginalMutationObserver) {\n    var counter = 1;\n    var observer = new OriginalMutationObserver(handle);\n    var textNode = document.createTextNode(counter);\n    observer.observe(textNode, {characterData: true});\n\n    timerFunc = function() {\n      counter = (counter + 1) % 2;\n      textNode.data = counter;\n    };\n\n  } else {\n    timerFunc = window.setImmediate || window.setTimeout;\n  }\n\n  function setEndOfMicrotask(func) {\n    callbacks.push(func);\n    if (pending)\n      return;\n    pending = true;\n    timerFunc(handle, 0);\n  }\n\n  context.setEndOfMicrotask = setEndOfMicrotask;\n\n})(window.ShadowDOMPolyfill);\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is goverened by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\n(function(scope) {\n  'use strict';\n\n  var setEndOfMicrotask = scope.setEndOfMicrotask\n  var wrapIfNeeded = scope.wrapIfNeeded\n  var wrappers = scope.wrappers;\n\n  var registrationsTable = new WeakMap();\n  var globalMutationObservers = [];\n  var isScheduled = false;\n\n  function scheduleCallback(observer) {\n    if (isScheduled)\n      return;\n    setEndOfMicrotask(notifyObservers);\n    isScheduled = true;\n  }\n\n  // http://dom.spec.whatwg.org/#mutation-observers\n  function notifyObservers() {\n    isScheduled = false;\n\n    do {\n      var notifyList = globalMutationObservers.slice();\n      var anyNonEmpty = false;\n      for (var i = 0; i < notifyList.length; i++) {\n        var mo = notifyList[i];\n        var queue = mo.takeRecords();\n        removeTransientObserversFor(mo);\n        if (queue.length) {\n          mo.callback_(queue, mo);\n          anyNonEmpty = true;\n        }\n      }\n    } while (anyNonEmpty);\n  }\n\n  /**\n   * @param {string} type\n   * @param {Node} target\n   * @constructor\n   */\n  function MutationRecord(type, target) {\n    this.type = type;\n    this.target = target;\n    this.addedNodes = new wrappers.NodeList();\n    this.removedNodes = new wrappers.NodeList();\n    this.previousSibling = null;\n    this.nextSibling = null;\n    this.attributeName = null;\n    this.attributeNamespace = null;\n    this.oldValue = null;\n  }\n\n  /**\n   * Registers transient observers to ancestor and its ancesors for the node\n   * which was removed.\n   * @param {!Node} ancestor\n   * @param {!Node} node\n   */\n  function registerTransientObservers(ancestor, node) {\n    for (; ancestor; ancestor = ancestor.parentNode) {\n      var registrations = registrationsTable.get(ancestor);\n      if (!registrations)\n        continue;\n      for (var i = 0; i < registrations.length; i++) {\n        var registration = registrations[i];\n        if (registration.options.subtree)\n          registration.addTransientObserver(node);\n      }\n    }\n  }\n\n  function removeTransientObserversFor(observer) {\n    for (var i = 0; i < observer.nodes_.length; i++) {\n      var node = observer.nodes_[i];\n      var registrations = registrationsTable.get(node);\n      if (!registrations)\n        return;\n      for (var j = 0; j < registrations.length; j++) {\n        var registration = registrations[j];\n        if (registration.observer === observer)\n          registration.removeTransientObservers();\n      }\n    }\n  }\n\n  // http://dom.spec.whatwg.org/#queue-a-mutation-record\n  function enqueueMutation(target, type, data) {\n    // 1.\n    var interestedObservers = Object.create(null);\n    var associatedStrings = Object.create(null);\n\n    // 2.\n    for (var node = target; node; node = node.parentNode) {\n      // 3.\n      var registrations = registrationsTable.get(node);\n      if (!registrations)\n        continue;\n      for (var j = 0; j < registrations.length; j++) {\n        var registration = registrations[j];\n        var options = registration.options;\n        // 1.\n        if (node !== target && !options.subtree)\n          continue;\n\n        // 2.\n        if (type === 'attributes' && !options.attributes)\n          continue;\n\n        // 3. If type is \"attributes\", options's attributeFilter is present, and\n        // either options's attributeFilter does not contain name or namespace\n        // is non-null, continue.\n        if (type === 'attributes' && options.attributeFilter &&\n            (data.namespace !== null ||\n             options.attributeFilter.indexOf(data.name) === -1)) {\n          continue;\n        }\n\n        // 4.\n        if (type === 'characterData' && !options.characterData)\n          continue;\n\n        // 5.\n        if (type === 'childList' && !options.childList)\n          continue;\n\n        // 6.\n        var observer = registration.observer;\n        interestedObservers[observer.uid_] = observer;\n\n        // 7. If either type is \"attributes\" and options's attributeOldValue is\n        // true, or type is \"characterData\" and options's characterDataOldValue\n        // is true, set the paired string of registered observer's observer in\n        // interested observers to oldValue.\n        if (type === 'attributes' && options.attributeOldValue ||\n            type === 'characterData' && options.characterDataOldValue) {\n          associatedStrings[observer.uid_] = data.oldValue;\n        }\n      }\n    }\n\n    var anyRecordsEnqueued = false;\n\n    // 4.\n    for (var uid in interestedObservers) {\n      var observer = interestedObservers[uid];\n      var record = new MutationRecord(type, target);\n\n      // 2.\n      if ('name' in data && 'namespace' in data) {\n        record.attributeName = data.name;\n        record.attributeNamespace = data.namespace;\n      }\n\n      // 3.\n      if (data.addedNodes)\n        record.addedNodes = data.addedNodes;\n\n      // 4.\n      if (data.removedNodes)\n        record.removedNodes = data.removedNodes;\n\n      // 5.\n      if (data.previousSibling)\n        record.previousSibling = data.previousSibling;\n\n      // 6.\n      if (data.nextSibling)\n        record.nextSibling = data.nextSibling;\n\n      // 7.\n      if (associatedStrings[uid] !== undefined)\n        record.oldValue = associatedStrings[uid];\n\n      // 8.\n      observer.records_.push(record);\n\n      anyRecordsEnqueued = true;\n    }\n\n    if (anyRecordsEnqueued)\n      scheduleCallback();\n  }\n\n  var slice = Array.prototype.slice;\n\n  /**\n   * @param {!Object} options\n   * @constructor\n   */\n  function MutationObserverOptions(options) {\n    this.childList = !!options.childList;\n    this.subtree = !!options.subtree;\n\n    // 1. If either options' attributeOldValue or attributeFilter is present\n    // and options' attributes is omitted, set options' attributes to true.\n    if (!('attributes' in options) &&\n        ('attributeOldValue' in options || 'attributeFilter' in options)) {\n      this.attributes = true;\n    } else {\n      this.attributes = !!options.attributes;\n    }\n\n    // 2. If options' characterDataOldValue is present and options'\n    // characterData is omitted, set options' characterData to true.\n    if ('characterDataOldValue' in options && !('characterData' in options))\n      this.characterData = true;\n    else\n      this.characterData = !!options.characterData;\n\n    // 3. & 4.\n    if (!this.attributes &&\n        (options.attributeOldValue || 'attributeFilter' in options) ||\n        // 5.\n        !this.characterData && options.characterDataOldValue) {\n      throw new TypeError();\n    }\n\n    this.characterData = !!options.characterData;\n    this.attributeOldValue = !!options.attributeOldValue;\n    this.characterDataOldValue = !!options.characterDataOldValue;\n    if ('attributeFilter' in options) {\n      if (options.attributeFilter == null ||\n          typeof options.attributeFilter !== 'object') {\n        throw new TypeError();\n      }\n      this.attributeFilter = slice.call(options.attributeFilter);\n    } else {\n      this.attributeFilter = null;\n    }\n  }\n\n  var uidCounter = 0;\n\n  /**\n   * The class that maps to the DOM MutationObserver interface.\n   * @param {Function} callback.\n   * @constructor\n   */\n  function MutationObserver(callback) {\n    this.callback_ = callback;\n    this.nodes_ = [];\n    this.records_ = [];\n    this.uid_ = ++uidCounter;\n\n    // This will leak. There is no way to implement this without WeakRefs :'(\n    globalMutationObservers.push(this);\n  }\n\n  MutationObserver.prototype = {\n    constructor: MutationObserver,\n\n    // http://dom.spec.whatwg.org/#dom-mutationobserver-observe\n    observe: function(target, options) {\n      target = wrapIfNeeded(target);\n\n      var newOptions = new MutationObserverOptions(options);\n\n      // 6.\n      var registration;\n      var registrations = registrationsTable.get(target);\n      if (!registrations)\n        registrationsTable.set(target, registrations = []);\n\n      for (var i = 0; i < registrations.length; i++) {\n        if (registrations[i].observer === this) {\n          registration = registrations[i];\n          // 6.1.\n          registration.removeTransientObservers();\n          // 6.2.\n          registration.options = newOptions;\n        }\n      }\n\n      // 7.\n      if (!registration) {\n        registration = new Registration(this, target, newOptions);\n        registrations.push(registration);\n        this.nodes_.push(target);\n      }\n    },\n\n    // http://dom.spec.whatwg.org/#dom-mutationobserver-disconnect\n    disconnect: function() {\n      this.nodes_.forEach(function(node) {\n        var registrations = registrationsTable.get(node);\n        for (var i = 0; i < registrations.length; i++) {\n          var registration = registrations[i];\n          if (registration.observer === this) {\n            registrations.splice(i, 1);\n            // Each node can only have one registered observer associated with\n            // this observer.\n            break;\n          }\n        }\n      }, this);\n      this.records_ = [];\n    },\n\n    takeRecords: function() {\n      var copyOfRecords = this.records_;\n      this.records_ = [];\n      return copyOfRecords;\n    }\n  };\n\n  /**\n   * Class used to represent a registered observer.\n   * @param {MutationObserver} observer\n   * @param {Node} target\n   * @param {MutationObserverOptions} options\n   * @constructor\n   */\n  function Registration(observer, target, options) {\n    this.observer = observer;\n    this.target = target;\n    this.options = options;\n    this.transientObservedNodes = [];\n  }\n\n  Registration.prototype = {\n    /**\n     * Adds a transient observer on node. The transient observer gets removed\n     * next time we deliver the change records.\n     * @param {Node} node\n     */\n    addTransientObserver: function(node) {\n      // Don't add transient observers on the target itself. We already have all\n      // the required listeners set up on the target.\n      if (node === this.target)\n        return;\n\n      this.transientObservedNodes.push(node);\n      var registrations = registrationsTable.get(node);\n      if (!registrations)\n        registrationsTable.set(node, registrations = []);\n\n      // We know that registrations does not contain this because we already\n      // checked if node === this.target.\n      registrations.push(this);\n    },\n\n    removeTransientObservers: function() {\n      var transientObservedNodes = this.transientObservedNodes;\n      this.transientObservedNodes = [];\n\n      for (var i = 0; i < transientObservedNodes.length; i++) {\n        var node = transientObservedNodes[i];\n        var registrations = registrationsTable.get(node);\n        for (var j = 0; j < registrations.length; j++) {\n          if (registrations[j] === this) {\n            registrations.splice(j, 1);\n            // Each node can only have one registered observer associated with\n            // this observer.\n            break;\n          }\n        }\n      }\n    }\n  };\n\n  scope.enqueueMutation = enqueueMutation;\n  scope.registerTransientObservers = registerTransientObservers;\n  scope.wrappers.MutationObserver = MutationObserver;\n  scope.wrappers.MutationRecord = MutationRecord;\n\n})(window.ShadowDOMPolyfill);\n","/**\n * Copyright 2014 The Polymer Authors. All rights reserved.\n * Use of this source code is goverened by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\n(function(scope) {\n  'use strict';\n\n  /**\n   * A tree scope represents the root of a tree. All nodes in a tree point to\n   * the same TreeScope object. The tree scope of a node get set the first time\n   * it is accessed or when a node is added or remove to a tree.\n   *\n   * The root is a Node that has no parent.\n   *\n   * The parent is another TreeScope. For ShadowRoots, it is the TreeScope of\n   * the host of the ShadowRoot.\n   *\n   * @param {!Node} root\n   * @param {TreeScope} parent\n   * @constructor\n   */\n  function TreeScope(root, parent) {\n    /** @type {!Node} */\n    this.root = root;\n\n    /** @type {TreeScope} */\n    this.parent = parent;\n  }\n\n  TreeScope.prototype = {\n    get renderer() {\n      if (this.root instanceof scope.wrappers.ShadowRoot) {\n        return scope.getRendererForHost(this.root.host);\n      }\n      return null;\n    },\n\n    contains: function(treeScope) {\n      for (; treeScope; treeScope = treeScope.parent) {\n        if (treeScope === this)\n          return true;\n      }\n      return false;\n    }\n  };\n\n  function setTreeScope(node, treeScope) {\n    if (node.treeScope_ !== treeScope) {\n      node.treeScope_ = treeScope;\n      for (var sr = node.shadowRoot; sr; sr = sr.olderShadowRoot) {\n        sr.treeScope_.parent = treeScope;\n      }\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        setTreeScope(child, treeScope);\n      }\n    }\n  }\n\n  function getTreeScope(node) {\n    if (node instanceof scope.wrappers.Window) {\n      debugger;\n    }\n\n    if (node.treeScope_)\n      return node.treeScope_;\n    var parent = node.parentNode;\n    var treeScope;\n    if (parent)\n      treeScope = getTreeScope(parent);\n    else\n      treeScope = new TreeScope(node, null);\n    return node.treeScope_ = treeScope;\n  }\n\n  scope.TreeScope = TreeScope;\n  scope.getTreeScope = getTreeScope;\n  scope.setTreeScope = setTreeScope;\n\n})(window.ShadowDOMPolyfill);\n","// Copyright 2013 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var forwardMethodsToWrapper = scope.forwardMethodsToWrapper;\n  var getTreeScope = scope.getTreeScope;\n  var mixin = scope.mixin;\n  var registerWrapper = scope.registerWrapper;\n  var setWrapper = scope.setWrapper;\n  var unsafeUnwrap = scope.unsafeUnwrap;\n  var unwrap = scope.unwrap;\n  var wrap = scope.wrap;\n  var wrappers = scope.wrappers;\n\n  var wrappedFuns = new WeakMap();\n  var listenersTable = new WeakMap();\n  var handledEventsTable = new WeakMap();\n  var currentlyDispatchingEvents = new WeakMap();\n  var targetTable = new WeakMap();\n  var currentTargetTable = new WeakMap();\n  var relatedTargetTable = new WeakMap();\n  var eventPhaseTable = new WeakMap();\n  var stopPropagationTable = new WeakMap();\n  var stopImmediatePropagationTable = new WeakMap();\n  var eventHandlersTable = new WeakMap();\n  var eventPathTable = new WeakMap();\n\n  function isShadowRoot(node) {\n    return node instanceof wrappers.ShadowRoot;\n  }\n\n  function rootOfNode(node) {\n    return getTreeScope(node).root;\n  }\n\n  // http://w3c.github.io/webcomponents/spec/shadow/#event-paths\n  function getEventPath(node, event) {\n    var path = [];\n    var current = node;\n    path.push(current);\n    while (current) {\n      // 4.1.\n      var destinationInsertionPoints = getDestinationInsertionPoints(current);\n      if (destinationInsertionPoints && destinationInsertionPoints.length > 0) {\n        // 4.1.1\n        for (var i = 0; i < destinationInsertionPoints.length; i++) {\n          var insertionPoint = destinationInsertionPoints[i];\n          // 4.1.1.1\n          if (isShadowInsertionPoint(insertionPoint)) {\n            var shadowRoot = rootOfNode(insertionPoint);\n            // 4.1.1.1.2\n            var olderShadowRoot = shadowRoot.olderShadowRoot;\n            if (olderShadowRoot)\n              path.push(olderShadowRoot);\n          }\n\n          // 4.1.1.2\n          path.push(insertionPoint);\n        }\n\n        // 4.1.2\n        current = destinationInsertionPoints[\n            destinationInsertionPoints.length - 1];\n\n      // 4.2\n      } else {\n        if (isShadowRoot(current)) {\n          if (inSameTree(node, current) && eventMustBeStopped(event)) {\n            // Stop this algorithm\n            break;\n          }\n          current = current.host;\n          path.push(current);\n\n        // 4.2.2\n        } else {\n          current = current.parentNode;\n          if (current)\n            path.push(current);\n        }\n      }\n    }\n\n    return path;\n  }\n\n  // http://w3c.github.io/webcomponents/spec/shadow/#dfn-events-always-stopped\n  function eventMustBeStopped(event) {\n    if (!event)\n      return false;\n\n    switch (event.type) {\n      case 'abort':\n      case 'error':\n      case 'select':\n      case 'change':\n      case 'load':\n      case 'reset':\n      case 'resize':\n      case 'scroll':\n      case 'selectstart':\n        return true;\n    }\n    return false;\n  }\n\n  // http://w3c.github.io/webcomponents/spec/shadow/#dfn-shadow-insertion-point\n  function isShadowInsertionPoint(node) {\n    return node instanceof HTMLShadowElement;\n    // and make sure that there are no shadow precing this?\n    // and that there is no content ancestor?\n  }\n\n  function getDestinationInsertionPoints(node) {\n    return scope.getDestinationInsertionPoints(node);\n  }\n\n  // http://w3c.github.io/webcomponents/spec/shadow/#event-retargeting\n  function eventRetargetting(path, currentTarget) {\n    if (path.length === 0)\n      return currentTarget;\n\n    // The currentTarget might be the window object. Use its document for the\n    // purpose of finding the retargetted node.\n    if (currentTarget instanceof wrappers.Window)\n      currentTarget = currentTarget.document;\n\n    var currentTargetTree = getTreeScope(currentTarget);\n    var originalTarget = path[0];\n    var originalTargetTree = getTreeScope(originalTarget);\n    var relativeTargetTree =\n        lowestCommonInclusiveAncestor(currentTargetTree, originalTargetTree);\n\n    for (var i = 0; i < path.length; i++) {\n      var node = path[i];\n      if (getTreeScope(node) === relativeTargetTree)\n        return node;\n    }\n\n    return path[path.length - 1];\n  }\n\n  function getTreeScopeAncestors(treeScope) {\n    var ancestors = [];\n    for (;treeScope; treeScope = treeScope.parent) {\n      ancestors.push(treeScope);\n    }\n    return ancestors;\n  }\n\n  function lowestCommonInclusiveAncestor(tsA, tsB) {\n    var ancestorsA = getTreeScopeAncestors(tsA);\n    var ancestorsB = getTreeScopeAncestors(tsB);\n\n    var result = null;\n    while (ancestorsA.length > 0 && ancestorsB.length > 0) {\n      var a = ancestorsA.pop();\n      var b = ancestorsB.pop();\n      if (a === b)\n        result = a;\n      else\n        break;\n    }\n    return result;\n  }\n\n  function getTreeScopeRoot(ts) {\n    if (!ts.parent)\n      return ts;\n    return getTreeScopeRoot(ts.parent);\n  }\n\n  function relatedTargetResolution(event, currentTarget, relatedTarget) {\n    // In case the current target is a window use its document for the purpose\n    // of retargetting the related target.\n    if (currentTarget instanceof wrappers.Window)\n      currentTarget = currentTarget.document;\n\n    var currentTargetTree = getTreeScope(currentTarget);\n    var relatedTargetTree = getTreeScope(relatedTarget);\n\n    var relatedTargetEventPath = getEventPath(relatedTarget, event);\n\n    var lowestCommonAncestorTree;\n\n    // 4\n    var lowestCommonAncestorTree =\n        lowestCommonInclusiveAncestor(currentTargetTree, relatedTargetTree);\n\n    // 5\n    if (!lowestCommonAncestorTree)\n      lowestCommonAncestorTree = relatedTargetTree.root;\n\n    // 6\n    for (var commonAncestorTree = lowestCommonAncestorTree;\n         commonAncestorTree;\n         commonAncestorTree = commonAncestorTree.parent) {\n      // 6.1\n      var adjustedRelatedTarget;\n      for (var i = 0; i < relatedTargetEventPath.length; i++) {\n        var node = relatedTargetEventPath[i];\n        if (getTreeScope(node) === commonAncestorTree)\n          return node;\n      }\n    }\n\n    return null;\n  }\n\n  function inSameTree(a, b) {\n    return getTreeScope(a) === getTreeScope(b);\n  }\n\n  var NONE = 0;\n  var CAPTURING_PHASE = 1;\n  var AT_TARGET = 2;\n  var BUBBLING_PHASE = 3;\n\n  // pendingError is used to rethrow the first error we got during an event\n  // dispatch. The browser actually reports all errors but to do that we would\n  // need to rethrow the error asynchronously.\n  var pendingError;\n\n  function dispatchOriginalEvent(originalEvent) {\n    // Make sure this event is only dispatched once.\n    if (handledEventsTable.get(originalEvent))\n      return;\n    handledEventsTable.set(originalEvent, true);\n    dispatchEvent(wrap(originalEvent), wrap(originalEvent.target));\n    if (pendingError) {\n      var err = pendingError;\n      pendingError = null;\n      throw err;\n    }\n  }\n\n  function dispatchEvent(event, originalWrapperTarget) {\n    if (currentlyDispatchingEvents.get(event))\n      throw new Error('InvalidStateError');\n\n    currentlyDispatchingEvents.set(event, true);\n\n    // Render to ensure that the event path is correct.\n    scope.renderAllPending();\n    var eventPath;\n\n    // http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#events-and-the-window-object\n    // All events dispatched on Nodes with a default view, except load events,\n    // should propagate to the Window.\n\n    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#the-end\n    var overrideTarget;\n    var win;\n    var type = event.type;\n\n    // Should really be not cancelable too but since Firefox has a bug there\n    // we skip that check.\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=999456\n    if (type === 'load' && !event.bubbles) {\n      var doc = originalWrapperTarget;\n      if (doc instanceof wrappers.Document && (win = doc.defaultView)) {\n        overrideTarget = doc;\n        eventPath = [];\n      }\n    }\n\n    if (!eventPath) {\n      if (originalWrapperTarget instanceof wrappers.Window) {\n        win = originalWrapperTarget;\n        eventPath = [];\n      } else {\n        eventPath = getEventPath(originalWrapperTarget, event);\n\n        if (event.type !== 'load') {\n          var doc = eventPath[eventPath.length - 1];\n          if (doc instanceof wrappers.Document)\n            win = doc.defaultView;\n        }\n      }\n    }\n\n    eventPathTable.set(event, eventPath);\n\n    if (dispatchCapturing(event, eventPath, win, overrideTarget)) {\n      if (dispatchAtTarget(event, eventPath, win, overrideTarget)) {\n        dispatchBubbling(event, eventPath, win, overrideTarget);\n      }\n    }\n\n    eventPhaseTable.set(event, NONE);\n    currentTargetTable.delete(event, null);\n    currentlyDispatchingEvents.delete(event);\n\n    return event.defaultPrevented;\n  }\n\n  function dispatchCapturing(event, eventPath, win, overrideTarget) {\n    var phase = CAPTURING_PHASE;\n\n    if (win) {\n      if (!invoke(win, event, phase, eventPath, overrideTarget))\n        return false;\n    }\n\n    for (var i = eventPath.length - 1; i > 0; i--) {\n      if (!invoke(eventPath[i], event, phase, eventPath, overrideTarget))\n        return false;\n    }\n\n    return true;\n  }\n\n  function dispatchAtTarget(event, eventPath, win, overrideTarget) {\n    var phase = AT_TARGET;\n    var currentTarget = eventPath[0] || win;\n    return invoke(currentTarget, event, phase, eventPath, overrideTarget);\n  }\n\n  function dispatchBubbling(event, eventPath, win, overrideTarget) {\n    var phase = BUBBLING_PHASE;\n    for (var i = 1; i < eventPath.length; i++) {\n      if (!invoke(eventPath[i], event, phase, eventPath, overrideTarget))\n        return;\n    }\n\n    if (win && eventPath.length > 0) {\n      invoke(win, event, phase, eventPath, overrideTarget);\n    }\n  }\n\n  function invoke(currentTarget, event, phase, eventPath, overrideTarget) {\n    var listeners = listenersTable.get(currentTarget);\n    if (!listeners)\n      return true;\n\n    var target = overrideTarget || eventRetargetting(eventPath, currentTarget);\n\n    if (target === currentTarget) {\n      if (phase === CAPTURING_PHASE)\n        return true;\n\n      if (phase === BUBBLING_PHASE)\n         phase = AT_TARGET;\n\n    } else if (phase === BUBBLING_PHASE && !event.bubbles) {\n      return true;\n    }\n\n    if ('relatedTarget' in event) {\n      var originalEvent = unwrap(event);\n      var unwrappedRelatedTarget = originalEvent.relatedTarget;\n\n      // X-Tag sets relatedTarget on a CustomEvent. If they do that there is no\n      // way to have relatedTarget return the adjusted target but worse is that\n      // the originalEvent might not have a relatedTarget so we hit an assert\n      // when we try to wrap it.\n      if (unwrappedRelatedTarget) {\n        // In IE we can get objects that are not EventTargets at this point.\n        // Safari does not have an EventTarget interface so revert to checking\n        // for addEventListener as an approximation.\n        if (unwrappedRelatedTarget instanceof Object &&\n            unwrappedRelatedTarget.addEventListener) {\n          var relatedTarget = wrap(unwrappedRelatedTarget);\n\n          var adjusted =\n              relatedTargetResolution(event, currentTarget, relatedTarget);\n          if (adjusted === target)\n            return true;\n        } else {\n          adjusted = null;\n        }\n        relatedTargetTable.set(event, adjusted);\n      }\n    }\n\n    eventPhaseTable.set(event, phase);\n    var type = event.type;\n\n    var anyRemoved = false;\n    // targetTable.set(event, target);\n    targetTable.set(event, target);\n    currentTargetTable.set(event, currentTarget);\n\n    // Keep track of the invoke depth so that we only clean up the removed\n    // listeners if we are in the outermost invoke.\n    listeners.depth++;\n\n    for (var i = 0, len = listeners.length; i < len; i++) {\n      var listener = listeners[i];\n      if (listener.removed) {\n        anyRemoved = true;\n        continue;\n      }\n\n      if (listener.type !== type ||\n          !listener.capture && phase === CAPTURING_PHASE ||\n          listener.capture && phase === BUBBLING_PHASE) {\n        continue;\n      }\n\n      try {\n        if (typeof listener.handler === 'function')\n          listener.handler.call(currentTarget, event);\n        else\n          listener.handler.handleEvent(event);\n\n        if (stopImmediatePropagationTable.get(event))\n          return false;\n\n      } catch (ex) {\n        if (!pendingError)\n          pendingError = ex;\n      }\n    }\n\n    listeners.depth--;\n\n    if (anyRemoved && listeners.depth === 0) {\n      var copy = listeners.slice();\n      listeners.length = 0;\n      for (var i = 0; i < copy.length; i++) {\n        if (!copy[i].removed)\n          listeners.push(copy[i]);\n      }\n    }\n\n    return !stopPropagationTable.get(event);\n  }\n\n  function Listener(type, handler, capture) {\n    this.type = type;\n    this.handler = handler;\n    this.capture = Boolean(capture);\n  }\n  Listener.prototype = {\n    equals: function(that) {\n      return this.handler === that.handler && this.type === that.type &&\n          this.capture === that.capture;\n    },\n    get removed() {\n      return this.handler === null;\n    },\n    remove: function() {\n      this.handler = null;\n    }\n  };\n\n  var OriginalEvent = window.Event;\n  OriginalEvent.prototype.polymerBlackList_ = {\n    returnValue: true,\n    // TODO(arv): keyLocation is part of KeyboardEvent but Firefox does not\n    // support constructable KeyboardEvent so we keep it here for now.\n    keyLocation: true\n  };\n\n  /**\n   * Creates a new Event wrapper or wraps an existin native Event object.\n   * @param {string|Event} type\n   * @param {Object=} options\n   * @constructor\n   */\n  function Event(type, options) {\n    if (type instanceof OriginalEvent) {\n      var impl = type;\n      if (!OriginalBeforeUnloadEvent && impl.type === 'beforeunload') {\n        return new BeforeUnloadEvent(impl);\n      }\n      setWrapper(impl, this);\n    } else {\n      return wrap(constructEvent(OriginalEvent, 'Event', type, options));\n    }\n  }\n  Event.prototype = {\n    get target() {\n      return targetTable.get(this);\n    },\n    get currentTarget() {\n      return currentTargetTable.get(this);\n    },\n    get eventPhase() {\n      return eventPhaseTable.get(this);\n    },\n    get path() {\n      var eventPath = eventPathTable.get(this);\n      if (!eventPath)\n        return [];\n      // TODO(arv): Event path should contain window.\n      return eventPath.slice();\n    },\n    stopPropagation: function() {\n      stopPropagationTable.set(this, true);\n    },\n    stopImmediatePropagation: function() {\n      stopPropagationTable.set(this, true);\n      stopImmediatePropagationTable.set(this, true);\n    }\n  };\n  registerWrapper(OriginalEvent, Event, document.createEvent('Event'));\n\n  function unwrapOptions(options) {\n    if (!options || !options.relatedTarget)\n      return options;\n    return Object.create(options, {\n      relatedTarget: {value: unwrap(options.relatedTarget)}\n    });\n  }\n\n  function registerGenericEvent(name, SuperEvent, prototype) {\n    var OriginalEvent = window[name];\n    var GenericEvent = function(type, options) {\n      if (type instanceof OriginalEvent)\n        setWrapper(type, this);\n      else\n        return wrap(constructEvent(OriginalEvent, name, type, options));\n    };\n    GenericEvent.prototype = Object.create(SuperEvent.prototype);\n    if (prototype)\n      mixin(GenericEvent.prototype, prototype);\n    if (OriginalEvent) {\n      // - Old versions of Safari fails on new FocusEvent (and others?).\n      // - IE does not support event constructors.\n      // - createEvent('FocusEvent') throws in Firefox.\n      // => Try the best practice solution first and fallback to the old way\n      // if needed.\n      try {\n        registerWrapper(OriginalEvent, GenericEvent, new OriginalEvent('temp'));\n      } catch (ex) {\n        registerWrapper(OriginalEvent, GenericEvent,\n                        document.createEvent(name));\n      }\n    }\n    return GenericEvent;\n  }\n\n  var UIEvent = registerGenericEvent('UIEvent', Event);\n  var CustomEvent = registerGenericEvent('CustomEvent', Event);\n\n  var relatedTargetProto = {\n    get relatedTarget() {\n      var relatedTarget = relatedTargetTable.get(this);\n      // relatedTarget can be null.\n      if (relatedTarget !== undefined)\n        return relatedTarget;\n      return wrap(unwrap(this).relatedTarget);\n    }\n  };\n\n  function getInitFunction(name, relatedTargetIndex) {\n    return function() {\n      arguments[relatedTargetIndex] = unwrap(arguments[relatedTargetIndex]);\n      var impl = unwrap(this);\n      impl[name].apply(impl, arguments);\n    };\n  }\n\n  var mouseEventProto = mixin({\n    initMouseEvent: getInitFunction('initMouseEvent', 14)\n  }, relatedTargetProto);\n\n  var focusEventProto = mixin({\n    initFocusEvent: getInitFunction('initFocusEvent', 5)\n  }, relatedTargetProto);\n\n  var MouseEvent = registerGenericEvent('MouseEvent', UIEvent, mouseEventProto);\n  var FocusEvent = registerGenericEvent('FocusEvent', UIEvent, focusEventProto);\n\n  // In case the browser does not support event constructors we polyfill that\n  // by calling `createEvent('Foo')` and `initFooEvent` where the arguments to\n  // `initFooEvent` are derived from the registered default event init dict.\n  var defaultInitDicts = Object.create(null);\n\n  var supportsEventConstructors = (function() {\n    try {\n      new window.FocusEvent('focus');\n    } catch (ex) {\n      return false;\n    }\n    return true;\n  })();\n\n  /**\n   * Constructs a new native event.\n   */\n  function constructEvent(OriginalEvent, name, type, options) {\n    if (supportsEventConstructors)\n      return new OriginalEvent(type, unwrapOptions(options));\n\n    // Create the arguments from the default dictionary.\n    var event = unwrap(document.createEvent(name));\n    var defaultDict = defaultInitDicts[name];\n    var args = [type];\n    Object.keys(defaultDict).forEach(function(key) {\n      var v = options != null && key in options ?\n          options[key] : defaultDict[key];\n      if (key === 'relatedTarget')\n        v = unwrap(v);\n      args.push(v);\n    });\n    event['init' + name].apply(event, args);\n    return event;\n  }\n\n  if (!supportsEventConstructors) {\n    var configureEventConstructor = function(name, initDict, superName) {\n      if (superName) {\n        var superDict = defaultInitDicts[superName];\n        initDict = mixin(mixin({}, superDict), initDict);\n      }\n\n      defaultInitDicts[name] = initDict;\n    };\n\n    // The order of the default event init dictionary keys is important, the\n    // arguments to initFooEvent is derived from that.\n    configureEventConstructor('Event', {bubbles: false, cancelable: false});\n    configureEventConstructor('CustomEvent', {detail: null}, 'Event');\n    configureEventConstructor('UIEvent', {view: null, detail: 0}, 'Event');\n    configureEventConstructor('MouseEvent', {\n      screenX: 0,\n      screenY: 0,\n      clientX: 0,\n      clientY: 0,\n      ctrlKey: false,\n      altKey: false,\n      shiftKey: false,\n      metaKey: false,\n      button: 0,\n      relatedTarget: null\n    }, 'UIEvent');\n    configureEventConstructor('FocusEvent', {relatedTarget: null}, 'UIEvent');\n  }\n\n  // Safari 7 does not yet have BeforeUnloadEvent.\n  // https://bugs.webkit.org/show_bug.cgi?id=120849\n  var OriginalBeforeUnloadEvent = window.BeforeUnloadEvent;\n\n  function BeforeUnloadEvent(impl) {\n    Event.call(this, impl);\n  }\n  BeforeUnloadEvent.prototype = Object.create(Event.prototype);\n  mixin(BeforeUnloadEvent.prototype, {\n    get returnValue() {\n      return unsafeUnwrap(this).returnValue;\n    },\n    set returnValue(v) {\n      unsafeUnwrap(this).returnValue = v;\n    }\n  });\n\n  if (OriginalBeforeUnloadEvent)\n    registerWrapper(OriginalBeforeUnloadEvent, BeforeUnloadEvent);\n\n  function isValidListener(fun) {\n    if (typeof fun === 'function')\n      return true;\n    return fun && fun.handleEvent;\n  }\n\n  function isMutationEvent(type) {\n    switch (type) {\n      case 'DOMAttrModified':\n      case 'DOMAttributeNameChanged':\n      case 'DOMCharacterDataModified':\n      case 'DOMElementNameChanged':\n      case 'DOMNodeInserted':\n      case 'DOMNodeInsertedIntoDocument':\n      case 'DOMNodeRemoved':\n      case 'DOMNodeRemovedFromDocument':\n      case 'DOMSubtreeModified':\n        return true;\n    }\n    return false;\n  }\n\n  var OriginalEventTarget = window.EventTarget;\n\n  /**\n   * This represents a wrapper for an EventTarget.\n   * @param {!EventTarget} impl The original event target.\n   * @constructor\n   */\n  function EventTarget(impl) {\n    setWrapper(impl, this);\n  }\n\n  // Node and Window have different internal type checks in WebKit so we cannot\n  // use the same method as the original function.\n  var methodNames = [\n    'addEventListener',\n    'removeEventListener',\n    'dispatchEvent'\n  ];\n\n  [Node, Window].forEach(function(constructor) {\n    var p = constructor.prototype;\n    methodNames.forEach(function(name) {\n      Object.defineProperty(p, name + '_', {value: p[name]});\n    });\n  });\n\n  function getTargetToListenAt(wrapper) {\n    if (wrapper instanceof wrappers.ShadowRoot)\n      wrapper = wrapper.host;\n    return unwrap(wrapper);\n  }\n\n  EventTarget.prototype = {\n    addEventListener: function(type, fun, capture) {\n      if (!isValidListener(fun) || isMutationEvent(type))\n        return;\n\n      var listener = new Listener(type, fun, capture);\n      var listeners = listenersTable.get(this);\n      if (!listeners) {\n        listeners = [];\n        listeners.depth = 0;\n        listenersTable.set(this, listeners);\n      } else {\n        // Might have a duplicate.\n        for (var i = 0; i < listeners.length; i++) {\n          if (listener.equals(listeners[i]))\n            return;\n        }\n      }\n\n      listeners.push(listener);\n\n      var target = getTargetToListenAt(this);\n      target.addEventListener_(type, dispatchOriginalEvent, true);\n    },\n    removeEventListener: function(type, fun, capture) {\n      capture = Boolean(capture);\n      var listeners = listenersTable.get(this);\n      if (!listeners)\n        return;\n      var count = 0, found = false;\n      for (var i = 0; i < listeners.length; i++) {\n        if (listeners[i].type === type && listeners[i].capture === capture) {\n          count++;\n          if (listeners[i].handler === fun) {\n            found = true;\n            listeners[i].remove();\n          }\n        }\n      }\n\n      if (found && count === 1) {\n        var target = getTargetToListenAt(this);\n        target.removeEventListener_(type, dispatchOriginalEvent, true);\n      }\n    },\n    dispatchEvent: function(event) {\n      // We want to use the native dispatchEvent because it triggers the default\n      // actions (like checking a checkbox). However, if there are no listeners\n      // in the composed tree then there are no events that will trigger and\n      // listeners in the non composed tree that are part of the event path are\n      // not notified.\n      //\n      // If we find out that there are no listeners in the composed tree we add\n      // a temporary listener to the target which makes us get called back even\n      // in that case.\n\n      var nativeEvent = unwrap(event);\n      var eventType = nativeEvent.type;\n\n      // Allow dispatching the same event again. This is safe because if user\n      // code calls this during an existing dispatch of the same event the\n      // native dispatchEvent throws (that is required by the spec).\n      handledEventsTable.set(nativeEvent, false);\n\n      // Force rendering since we prefer native dispatch and that works on the\n      // composed tree.\n      scope.renderAllPending();\n\n      var tempListener;\n      if (!hasListenerInAncestors(this, eventType)) {\n        tempListener = function() {};\n        this.addEventListener(eventType, tempListener, true);\n      }\n\n      try {\n        return unwrap(this).dispatchEvent_(nativeEvent);\n      } finally {\n        if (tempListener)\n          this.removeEventListener(eventType, tempListener, true);\n      }\n    }\n  };\n\n  function hasListener(node, type) {\n    var listeners = listenersTable.get(node);\n    if (listeners) {\n      for (var i = 0; i < listeners.length; i++) {\n        if (!listeners[i].removed && listeners[i].type === type)\n          return true;\n      }\n    }\n    return false;\n  }\n\n  function hasListenerInAncestors(target, type) {\n    for (var node = unwrap(target); node; node = node.parentNode) {\n      if (hasListener(wrap(node), type))\n        return true;\n    }\n    return false;\n  }\n\n  if (OriginalEventTarget)\n    registerWrapper(OriginalEventTarget, EventTarget);\n\n  function wrapEventTargetMethods(constructors) {\n    forwardMethodsToWrapper(constructors, methodNames);\n  }\n\n  var originalElementFromPoint = document.elementFromPoint;\n\n  function elementFromPoint(self, document, x, y) {\n    scope.renderAllPending();\n\n    var element =\n        wrap(originalElementFromPoint.call(unsafeUnwrap(document), x, y));\n    if (!element)\n      return null;\n    var path = getEventPath(element, null);\n\n    // scope the path to this TreeScope\n    var idx = path.lastIndexOf(self);\n    if (idx == -1)\n      return null;\n    else\n      path = path.slice(0, idx);\n\n    // TODO(dfreedm): pass idx to eventRetargetting to avoid array copy\n    return eventRetargetting(path, self);\n  }\n\n  /**\n   * Returns a function that is to be used as a getter for `onfoo` properties.\n   * @param {string} name\n   * @return {Function}\n   */\n  function getEventHandlerGetter(name) {\n    return function() {\n      var inlineEventHandlers = eventHandlersTable.get(this);\n      return inlineEventHandlers && inlineEventHandlers[name] &&\n          inlineEventHandlers[name].value || null;\n     };\n  }\n\n  /**\n   * Returns a function that is to be used as a setter for `onfoo` properties.\n   * @param {string} name\n   * @return {Function}\n   */\n  function getEventHandlerSetter(name) {\n    var eventType = name.slice(2);\n    return function(value) {\n      var inlineEventHandlers = eventHandlersTable.get(this);\n      if (!inlineEventHandlers) {\n        inlineEventHandlers = Object.create(null);\n        eventHandlersTable.set(this, inlineEventHandlers);\n      }\n\n      var old = inlineEventHandlers[name];\n      if (old)\n        this.removeEventListener(eventType, old.wrapped, false);\n\n      if (typeof value === 'function') {\n        var wrapped = function(e) {\n          var rv = value.call(this, e);\n          if (rv === false)\n            e.preventDefault();\n          else if (name === 'onbeforeunload' && typeof rv === 'string')\n            e.returnValue = rv;\n          // mouseover uses true for preventDefault but preventDefault for\n          // mouseover is ignored by browsers these day.\n        };\n\n        this.addEventListener(eventType, wrapped, false);\n        inlineEventHandlers[name] = {\n          value: value,\n          wrapped: wrapped\n        };\n      }\n    };\n  }\n\n  scope.elementFromPoint = elementFromPoint;\n  scope.getEventHandlerGetter = getEventHandlerGetter;\n  scope.getEventHandlerSetter = getEventHandlerSetter;\n  scope.wrapEventTargetMethods = wrapEventTargetMethods;\n  scope.wrappers.BeforeUnloadEvent = BeforeUnloadEvent;\n  scope.wrappers.CustomEvent = CustomEvent;\n  scope.wrappers.Event = Event;\n  scope.wrappers.EventTarget = EventTarget;\n  scope.wrappers.FocusEvent = FocusEvent;\n  scope.wrappers.MouseEvent = MouseEvent;\n  scope.wrappers.UIEvent = UIEvent;\n\n})(window.ShadowDOMPolyfill);\n","/*\n * Copyright 2014 The Polymer Authors. All rights reserved.\n * Use of this source code is goverened by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\n(function(scope) {\n  'use strict';\n\n  var UIEvent = scope.wrappers.UIEvent;\n  var mixin = scope.mixin;\n  var registerWrapper = scope.registerWrapper;\n  var setWrapper = scope.setWrapper;\n  var unsafeUnwrap = scope.unsafeUnwrap;\n  var wrap = scope.wrap;\n\n  // TouchEvent is WebKit/Blink only.\n  var OriginalTouchEvent = window.TouchEvent;\n  if (!OriginalTouchEvent)\n    return;\n\n  var nativeEvent;\n  try {\n    nativeEvent = document.createEvent('TouchEvent');\n  } catch (ex) {\n    // In Chrome creating a TouchEvent fails if the feature is not turned on\n    // which it isn't on desktop Chrome.\n    return;\n  }\n\n  var nonEnumDescriptor = {enumerable: false};\n\n  function nonEnum(obj, prop) {\n    Object.defineProperty(obj, prop, nonEnumDescriptor);\n  }\n\n  function Touch(impl) {\n    setWrapper(impl, this);\n  }\n\n  Touch.prototype = {\n    get target() {\n      return wrap(unsafeUnwrap(this).target);\n    }\n  };\n\n  var descr = {\n    configurable: true,\n    enumerable: true,\n    get: null\n  };\n\n  [\n    'clientX',\n    'clientY',\n    'screenX',\n    'screenY',\n    'pageX',\n    'pageY',\n    'identifier',\n    'webkitRadiusX',\n    'webkitRadiusY',\n    'webkitRotationAngle',\n    'webkitForce'\n  ].forEach(function(name) {\n    descr.get = function() {\n      return unsafeUnwrap(this)[name];\n    };\n    Object.defineProperty(Touch.prototype, name, descr);\n  });\n\n  function TouchList() {\n    this.length = 0;\n    nonEnum(this, 'length');\n  }\n\n  TouchList.prototype = {\n    item: function(index) {\n      return this[index];\n    }\n  };\n\n  function wrapTouchList(nativeTouchList) {\n    var list = new TouchList();\n    for (var i = 0; i < nativeTouchList.length; i++) {\n      list[i] = new Touch(nativeTouchList[i]);\n    }\n    list.length = i;\n    return list;\n  }\n\n  function TouchEvent(impl) {\n    UIEvent.call(this, impl);\n  }\n\n  TouchEvent.prototype = Object.create(UIEvent.prototype);\n\n  mixin(TouchEvent.prototype, {\n    get touches() {\n      return wrapTouchList(unsafeUnwrap(this).touches);\n    },\n\n    get targetTouches() {\n      return wrapTouchList(unsafeUnwrap(this).targetTouches);\n    },\n\n    get changedTouches() {\n      return wrapTouchList(unsafeUnwrap(this).changedTouches);\n    },\n\n    initTouchEvent: function() {\n      // The only way to use this is to reuse the TouchList from an existing\n      // TouchEvent. Since this is WebKit/Blink proprietary API we will not\n      // implement this until someone screams.\n      throw new Error('Not implemented');\n    }\n  });\n\n  registerWrapper(OriginalTouchEvent, TouchEvent, nativeEvent);\n\n  scope.wrappers.Touch = Touch;\n  scope.wrappers.TouchEvent = TouchEvent;\n  scope.wrappers.TouchList = TouchList;\n\n})(window.ShadowDOMPolyfill);\n\n","// Copyright 2012 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var unsafeUnwrap = scope.unsafeUnwrap;\n  var wrap = scope.wrap;\n\n  var nonEnumDescriptor = {enumerable: false};\n\n  function nonEnum(obj, prop) {\n    Object.defineProperty(obj, prop, nonEnumDescriptor);\n  }\n\n  function NodeList() {\n    this.length = 0;\n    nonEnum(this, 'length');\n  }\n  NodeList.prototype = {\n    item: function(index) {\n      return this[index];\n    }\n  };\n  nonEnum(NodeList.prototype, 'item');\n\n  function wrapNodeList(list) {\n    if (list == null)\n      return list;\n    var wrapperList = new NodeList();\n    for (var i = 0, length = list.length; i < length; i++) {\n      wrapperList[i] = wrap(list[i]);\n    }\n    wrapperList.length = length;\n    return wrapperList;\n  }\n\n  function addWrapNodeListMethod(wrapperConstructor, name) {\n    wrapperConstructor.prototype[name] = function() {\n      return wrapNodeList(\n          unsafeUnwrap(this)[name].apply(unsafeUnwrap(this), arguments));\n    };\n  }\n\n  scope.wrappers.NodeList = NodeList;\n  scope.addWrapNodeListMethod = addWrapNodeListMethod;\n  scope.wrapNodeList = wrapNodeList;\n\n})(window.ShadowDOMPolyfill);\n","/*\n * Copyright 2014 The Polymer Authors. All rights reserved.\n * Use of this source code is goverened by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\n(function(scope) {\n  'use strict';\n\n  // TODO(arv): Implement.\n\n  scope.wrapHTMLCollection = scope.wrapNodeList;\n  scope.wrappers.HTMLCollection = scope.wrappers.NodeList;\n\n})(window.ShadowDOMPolyfill);\n","/**\n * Copyright 2012 The Polymer Authors. All rights reserved.\n * Use of this source code is goverened by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\n(function(scope) {\n  'use strict';\n\n  var EventTarget = scope.wrappers.EventTarget;\n  var NodeList = scope.wrappers.NodeList;\n  var TreeScope = scope.TreeScope;\n  var assert = scope.assert;\n  var defineWrapGetter = scope.defineWrapGetter;\n  var enqueueMutation = scope.enqueueMutation;\n  var getTreeScope = scope.getTreeScope;\n  var isWrapper = scope.isWrapper;\n  var mixin = scope.mixin;\n  var registerTransientObservers = scope.registerTransientObservers;\n  var registerWrapper = scope.registerWrapper;\n  var setTreeScope = scope.setTreeScope;\n  var unsafeUnwrap = scope.unsafeUnwrap;\n  var unwrap = scope.unwrap;\n  var unwrapIfNeeded = scope.unwrapIfNeeded;\n  var wrap = scope.wrap;\n  var wrapIfNeeded = scope.wrapIfNeeded;\n  var wrappers = scope.wrappers;\n\n  function assertIsNodeWrapper(node) {\n    assert(node instanceof Node);\n  }\n\n  function createOneElementNodeList(node) {\n    var nodes = new NodeList();\n    nodes[0] = node;\n    nodes.length = 1;\n    return nodes;\n  }\n\n  var surpressMutations = false;\n\n  /**\n   * Called before node is inserted into a node to enqueue its removal from its\n   * old parent.\n   * @param {!Node} node The node that is about to be removed.\n   * @param {!Node} parent The parent node that the node is being removed from.\n   * @param {!NodeList} nodes The collected nodes.\n   */\n  function enqueueRemovalForInsertedNodes(node, parent, nodes) {\n    enqueueMutation(parent, 'childList', {\n      removedNodes: nodes,\n      previousSibling: node.previousSibling,\n      nextSibling: node.nextSibling\n    });\n  }\n\n  function enqueueRemovalForInsertedDocumentFragment(df, nodes) {\n    enqueueMutation(df, 'childList', {\n      removedNodes: nodes\n    });\n  }\n\n  /**\n   * Collects nodes from a DocumentFragment or a Node for removal followed\n   * by an insertion.\n   *\n   * This updates the internal pointers for node, previousNode and nextNode.\n   */\n  function collectNodes(node, parentNode, previousNode, nextNode) {\n    if (node instanceof DocumentFragment) {\n      var nodes = collectNodesForDocumentFragment(node);\n\n      // The extra loop is to work around bugs with DocumentFragments in IE.\n      surpressMutations = true;\n      for (var i = nodes.length - 1; i >= 0; i--) {\n        node.removeChild(nodes[i]);\n        nodes[i].parentNode_ = parentNode;\n      }\n      surpressMutations = false;\n\n      for (var i = 0; i < nodes.length; i++) {\n        nodes[i].previousSibling_ = nodes[i - 1] || previousNode;\n        nodes[i].nextSibling_ = nodes[i + 1] || nextNode;\n      }\n\n      if (previousNode)\n        previousNode.nextSibling_ = nodes[0];\n      if (nextNode)\n        nextNode.previousSibling_ = nodes[nodes.length - 1];\n\n      return nodes;\n    }\n\n    var nodes = createOneElementNodeList(node);\n    var oldParent = node.parentNode;\n    if (oldParent) {\n      // This will enqueue the mutation record for the removal as needed.\n      oldParent.removeChild(node);\n    }\n\n    node.parentNode_ = parentNode;\n    node.previousSibling_ = previousNode;\n    node.nextSibling_ = nextNode;\n    if (previousNode)\n      previousNode.nextSibling_ = node;\n    if (nextNode)\n      nextNode.previousSibling_ = node;\n\n    return nodes;\n  }\n\n  function collectNodesNative(node) {\n    if (node instanceof DocumentFragment)\n      return collectNodesForDocumentFragment(node);\n\n    var nodes = createOneElementNodeList(node);\n    var oldParent = node.parentNode;\n    if (oldParent)\n      enqueueRemovalForInsertedNodes(node, oldParent, nodes);\n    return nodes;\n  }\n\n  function collectNodesForDocumentFragment(node) {\n    var nodes = new NodeList();\n    var i = 0;\n    for (var child = node.firstChild; child; child = child.nextSibling) {\n      nodes[i++] = child;\n    }\n    nodes.length = i;\n    enqueueRemovalForInsertedDocumentFragment(node, nodes);\n    return nodes;\n  }\n\n  function snapshotNodeList(nodeList) {\n    // NodeLists are not live at the moment so just return the same object.\n    return nodeList;\n  }\n\n  // http://dom.spec.whatwg.org/#node-is-inserted\n  function nodeWasAdded(node, treeScope) {\n    setTreeScope(node, treeScope);\n    node.nodeIsInserted_();\n  }\n\n  function nodesWereAdded(nodes, parent) {\n    var treeScope = getTreeScope(parent);\n    for (var i = 0; i < nodes.length; i++) {\n      nodeWasAdded(nodes[i], treeScope);\n    }\n  }\n\n  // http://dom.spec.whatwg.org/#node-is-removed\n  function nodeWasRemoved(node) {\n    setTreeScope(node, new TreeScope(node, null));\n  }\n\n  function nodesWereRemoved(nodes) {\n    for (var i = 0; i < nodes.length; i++) {\n      nodeWasRemoved(nodes[i]);\n    }\n  }\n\n  function ensureSameOwnerDocument(parent, child) {\n    var ownerDoc = parent.nodeType === Node.DOCUMENT_NODE ?\n        parent : parent.ownerDocument;\n    if (ownerDoc !== child.ownerDocument)\n      ownerDoc.adoptNode(child);\n  }\n\n  function adoptNodesIfNeeded(owner, nodes) {\n    if (!nodes.length)\n      return;\n\n    var ownerDoc = owner.ownerDocument;\n\n    // All nodes have the same ownerDocument when we get here.\n    if (ownerDoc === nodes[0].ownerDocument)\n      return;\n\n    for (var i = 0; i < nodes.length; i++) {\n      scope.adoptNodeNoRemove(nodes[i], ownerDoc);\n    }\n  }\n\n  function unwrapNodesForInsertion(owner, nodes) {\n    adoptNodesIfNeeded(owner, nodes);\n    var length = nodes.length;\n\n    if (length === 1)\n      return unwrap(nodes[0]);\n\n    var df = unwrap(owner.ownerDocument.createDocumentFragment());\n    for (var i = 0; i < length; i++) {\n      df.appendChild(unwrap(nodes[i]));\n    }\n    return df;\n  }\n\n  function clearChildNodes(wrapper) {\n    if (wrapper.firstChild_ !== undefined) {\n      var child = wrapper.firstChild_;\n      while (child) {\n        var tmp = child;\n        child = child.nextSibling_;\n        tmp.parentNode_ = tmp.previousSibling_ = tmp.nextSibling_ = undefined;\n      }\n    }\n    wrapper.firstChild_ = wrapper.lastChild_ = undefined;\n  }\n\n  function removeAllChildNodes(wrapper) {\n    if (wrapper.invalidateShadowRenderer()) {\n      var childWrapper = wrapper.firstChild;\n      while (childWrapper) {\n        assert(childWrapper.parentNode === wrapper);\n        var nextSibling = childWrapper.nextSibling;\n        var childNode = unwrap(childWrapper);\n        var parentNode = childNode.parentNode;\n        if (parentNode)\n          originalRemoveChild.call(parentNode, childNode);\n        childWrapper.previousSibling_ = childWrapper.nextSibling_ =\n            childWrapper.parentNode_ = null;\n        childWrapper = nextSibling;\n      }\n      wrapper.firstChild_ = wrapper.lastChild_ = null;\n    } else {\n      var node = unwrap(wrapper);\n      var child = node.firstChild;\n      var nextSibling;\n      while (child) {\n        nextSibling = child.nextSibling;\n        originalRemoveChild.call(node, child);\n        child = nextSibling;\n      }\n    }\n  }\n\n  function invalidateParent(node) {\n    var p = node.parentNode;\n    return p && p.invalidateShadowRenderer();\n  }\n\n  function cleanupNodes(nodes) {\n    for (var i = 0, n; i < nodes.length; i++) {\n      n = nodes[i];\n      n.parentNode.removeChild(n);\n    }\n  }\n\n  var originalImportNode = document.importNode;\n  var originalCloneNode = window.Node.prototype.cloneNode;\n\n  function cloneNode(node, deep, opt_doc) {\n    var clone;\n    if (opt_doc)\n      clone = wrap(originalImportNode.call(opt_doc, unsafeUnwrap(node), false));\n    else\n      clone = wrap(originalCloneNode.call(unsafeUnwrap(node), false));\n\n    if (deep) {\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        clone.appendChild(cloneNode(child, true, opt_doc));\n      }\n\n      if (node instanceof wrappers.HTMLTemplateElement) {\n        var cloneContent = clone.content;\n        for (var child = node.content.firstChild;\n             child;\n             child = child.nextSibling) {\n         cloneContent.appendChild(cloneNode(child, true, opt_doc));\n        }\n      }\n    }\n    // TODO(arv): Some HTML elements also clone other data like value.\n    return clone;\n  }\n\n  function contains(self, child) {\n    if (!child || getTreeScope(self) !== getTreeScope(child))\n      return false;\n\n    for (var node = child; node; node = node.parentNode) {\n      if (node === self)\n        return true;\n    }\n    return false;\n  }\n\n  var OriginalNode = window.Node;\n\n  /**\n   * This represents a wrapper of a native DOM node.\n   * @param {!Node} original The original DOM node, aka, the visual DOM node.\n   * @constructor\n   * @extends {EventTarget}\n   */\n  function Node(original) {\n    assert(original instanceof OriginalNode);\n\n    EventTarget.call(this, original);\n\n    // These properties are used to override the visual references with the\n    // logical ones. If the value is undefined it means that the logical is the\n    // same as the visual.\n\n    /**\n     * @type {Node|undefined}\n     * @private\n     */\n    this.parentNode_ = undefined;\n\n    /**\n     * @type {Node|undefined}\n     * @private\n     */\n    this.firstChild_ = undefined;\n\n    /**\n     * @type {Node|undefined}\n     * @private\n     */\n    this.lastChild_ = undefined;\n\n    /**\n     * @type {Node|undefined}\n     * @private\n     */\n    this.nextSibling_ = undefined;\n\n    /**\n     * @type {Node|undefined}\n     * @private\n     */\n    this.previousSibling_ = undefined;\n\n    this.treeScope_ = undefined;\n  }\n\n  var OriginalDocumentFragment = window.DocumentFragment;\n  var originalAppendChild = OriginalNode.prototype.appendChild;\n  var originalCompareDocumentPosition =\n      OriginalNode.prototype.compareDocumentPosition;\n  var originalInsertBefore = OriginalNode.prototype.insertBefore;\n  var originalRemoveChild = OriginalNode.prototype.removeChild;\n  var originalReplaceChild = OriginalNode.prototype.replaceChild;\n\n  var isIe = /Trident/.test(navigator.userAgent);\n\n  var removeChildOriginalHelper = isIe ?\n      function(parent, child) {\n        try {\n          originalRemoveChild.call(parent, child);\n        } catch (ex) {\n          if (!(parent instanceof OriginalDocumentFragment))\n            throw ex;\n        }\n      } :\n      function(parent, child) {\n        originalRemoveChild.call(parent, child);\n      };\n\n  Node.prototype = Object.create(EventTarget.prototype);\n  mixin(Node.prototype, {\n    appendChild: function(childWrapper) {\n      return this.insertBefore(childWrapper, null);\n    },\n\n    insertBefore: function(childWrapper, refWrapper) {\n      assertIsNodeWrapper(childWrapper);\n\n      var refNode;\n      if (refWrapper) {\n        if (isWrapper(refWrapper)) {\n          refNode = unwrap(refWrapper);\n        } else {\n          refNode = refWrapper;\n          refWrapper = wrap(refNode);\n        }\n      } else {\n        refWrapper = null;\n        refNode = null;\n      }\n\n      refWrapper && assert(refWrapper.parentNode === this);\n\n      var nodes;\n      var previousNode =\n          refWrapper ? refWrapper.previousSibling : this.lastChild;\n\n      var useNative = !this.invalidateShadowRenderer() &&\n                      !invalidateParent(childWrapper);\n\n      if (useNative)\n        nodes = collectNodesNative(childWrapper);\n      else\n        nodes = collectNodes(childWrapper, this, previousNode, refWrapper);\n\n      if (useNative) {\n        ensureSameOwnerDocument(this, childWrapper);\n        clearChildNodes(this);\n        originalInsertBefore.call(unsafeUnwrap(this), unwrap(childWrapper), refNode);\n      } else {\n        if (!previousNode)\n          this.firstChild_ = nodes[0];\n        if (!refWrapper) {\n          this.lastChild_ = nodes[nodes.length - 1];\n          if (this.firstChild_ === undefined)\n            this.firstChild_ = this.firstChild;\n        }\n\n        var parentNode = refNode ? refNode.parentNode : unsafeUnwrap(this);\n\n        // insertBefore refWrapper no matter what the parent is?\n        if (parentNode) {\n          originalInsertBefore.call(parentNode,\n              unwrapNodesForInsertion(this, nodes), refNode);\n        } else {\n          adoptNodesIfNeeded(this, nodes);\n        }\n      }\n\n      enqueueMutation(this, 'childList', {\n        addedNodes: nodes,\n        nextSibling: refWrapper,\n        previousSibling: previousNode\n      });\n\n      nodesWereAdded(nodes, this);\n\n      return childWrapper;\n    },\n\n    removeChild: function(childWrapper) {\n      assertIsNodeWrapper(childWrapper);\n      if (childWrapper.parentNode !== this) {\n        // IE has invalid DOM trees at times.\n        var found = false;\n        var childNodes = this.childNodes;\n        for (var ieChild = this.firstChild; ieChild;\n             ieChild = ieChild.nextSibling) {\n          if (ieChild === childWrapper) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          // TODO(arv): DOMException\n          throw new Error('NotFoundError');\n        }\n      }\n\n      var childNode = unwrap(childWrapper);\n      var childWrapperNextSibling = childWrapper.nextSibling;\n      var childWrapperPreviousSibling = childWrapper.previousSibling;\n\n      if (this.invalidateShadowRenderer()) {\n        // We need to remove the real node from the DOM before updating the\n        // pointers. This is so that that mutation event is dispatched before\n        // the pointers have changed.\n        var thisFirstChild = this.firstChild;\n        var thisLastChild = this.lastChild;\n\n        var parentNode = childNode.parentNode;\n        if (parentNode)\n          removeChildOriginalHelper(parentNode, childNode);\n\n        if (thisFirstChild === childWrapper)\n          this.firstChild_ = childWrapperNextSibling;\n        if (thisLastChild === childWrapper)\n          this.lastChild_ = childWrapperPreviousSibling;\n        if (childWrapperPreviousSibling)\n          childWrapperPreviousSibling.nextSibling_ = childWrapperNextSibling;\n        if (childWrapperNextSibling) {\n          childWrapperNextSibling.previousSibling_ =\n              childWrapperPreviousSibling;\n        }\n\n        childWrapper.previousSibling_ = childWrapper.nextSibling_ =\n            childWrapper.parentNode_ = undefined;\n      } else {\n        clearChildNodes(this);\n        removeChildOriginalHelper(unsafeUnwrap(this), childNode);\n      }\n\n      if (!surpressMutations) {\n        enqueueMutation(this, 'childList', {\n          removedNodes: createOneElementNodeList(childWrapper),\n          nextSibling: childWrapperNextSibling,\n          previousSibling: childWrapperPreviousSibling\n        });\n      }\n\n      registerTransientObservers(this, childWrapper);\n\n      return childWrapper;\n    },\n\n    replaceChild: function(newChildWrapper, oldChildWrapper) {\n      assertIsNodeWrapper(newChildWrapper);\n\n      var oldChildNode;\n      if (isWrapper(oldChildWrapper)) {\n        oldChildNode = unwrap(oldChildWrapper);\n      } else {\n        oldChildNode = oldChildWrapper;\n        oldChildWrapper = wrap(oldChildNode);\n      }\n\n      if (oldChildWrapper.parentNode !== this) {\n        // TODO(arv): DOMException\n        throw new Error('NotFoundError');\n      }\n\n      var nextNode = oldChildWrapper.nextSibling;\n      var previousNode = oldChildWrapper.previousSibling;\n      var nodes;\n\n      var useNative = !this.invalidateShadowRenderer() &&\n                      !invalidateParent(newChildWrapper);\n\n      if (useNative) {\n        nodes = collectNodesNative(newChildWrapper);\n      } else {\n        if (nextNode === newChildWrapper)\n          nextNode = newChildWrapper.nextSibling;\n        nodes = collectNodes(newChildWrapper, this, previousNode, nextNode);\n      }\n\n      if (!useNative) {\n        if (this.firstChild === oldChildWrapper)\n          this.firstChild_ = nodes[0];\n        if (this.lastChild === oldChildWrapper)\n          this.lastChild_ = nodes[nodes.length - 1];\n\n        oldChildWrapper.previousSibling_ = oldChildWrapper.nextSibling_ =\n            oldChildWrapper.parentNode_ = undefined;\n\n        // replaceChild no matter what the parent is?\n        if (oldChildNode.parentNode) {\n          originalReplaceChild.call(\n              oldChildNode.parentNode,\n              unwrapNodesForInsertion(this, nodes),\n              oldChildNode);\n        }\n      } else {\n        ensureSameOwnerDocument(this, newChildWrapper);\n        clearChildNodes(this);\n        originalReplaceChild.call(unsafeUnwrap(this), unwrap(newChildWrapper),\n                                  oldChildNode);\n      }\n\n      enqueueMutation(this, 'childList', {\n        addedNodes: nodes,\n        removedNodes: createOneElementNodeList(oldChildWrapper),\n        nextSibling: nextNode,\n        previousSibling: previousNode\n      });\n\n      nodeWasRemoved(oldChildWrapper);\n      nodesWereAdded(nodes, this);\n\n      return oldChildWrapper;\n    },\n\n    /**\n     * Called after a node was inserted. Subclasses override this to invalidate\n     * the renderer as needed.\n     * @private\n     */\n    nodeIsInserted_: function() {\n      for (var child = this.firstChild; child; child = child.nextSibling) {\n        child.nodeIsInserted_();\n      }\n    },\n\n    hasChildNodes: function() {\n      return this.firstChild !== null;\n    },\n\n    /** @type {Node} */\n    get parentNode() {\n      // If the parentNode has not been overridden, use the original parentNode.\n      return this.parentNode_ !== undefined ?\n          this.parentNode_ : wrap(unsafeUnwrap(this).parentNode);\n    },\n\n    /** @type {Node} */\n    get firstChild() {\n      return this.firstChild_ !== undefined ?\n          this.firstChild_ : wrap(unsafeUnwrap(this).firstChild);\n    },\n\n    /** @type {Node} */\n    get lastChild() {\n      return this.lastChild_ !== undefined ?\n          this.lastChild_ : wrap(unsafeUnwrap(this).lastChild);\n    },\n\n    /** @type {Node} */\n    get nextSibling() {\n      return this.nextSibling_ !== undefined ?\n          this.nextSibling_ : wrap(unsafeUnwrap(this).nextSibling);\n    },\n\n    /** @type {Node} */\n    get previousSibling() {\n      return this.previousSibling_ !== undefined ?\n          this.previousSibling_ : wrap(unsafeUnwrap(this).previousSibling);\n    },\n\n    get parentElement() {\n      var p = this.parentNode;\n      while (p && p.nodeType !== Node.ELEMENT_NODE) {\n        p = p.parentNode;\n      }\n      return p;\n    },\n\n    get textContent() {\n      // TODO(arv): This should fallback to unsafeUnwrap(this).textContent if there\n      // are no shadow trees below or above the context node.\n      var s = '';\n      for (var child = this.firstChild; child; child = child.nextSibling) {\n        if (child.nodeType != Node.COMMENT_NODE) {\n          s += child.textContent;\n        }\n      }\n      return s;\n    },\n    set textContent(textContent) {\n      var removedNodes = snapshotNodeList(this.childNodes);\n\n      if (this.invalidateShadowRenderer()) {\n        removeAllChildNodes(this);\n        if (textContent !== '') {\n          var textNode = unsafeUnwrap(this).ownerDocument.createTextNode(textContent);\n          this.appendChild(textNode);\n        }\n      } else {\n        clearChildNodes(this);\n        unsafeUnwrap(this).textContent = textContent;\n      }\n\n      var addedNodes = snapshotNodeList(this.childNodes);\n\n      enqueueMutation(this, 'childList', {\n        addedNodes: addedNodes,\n        removedNodes: removedNodes\n      });\n\n      nodesWereRemoved(removedNodes);\n      nodesWereAdded(addedNodes, this);\n    },\n\n    get childNodes() {\n      var wrapperList = new NodeList();\n      var i = 0;\n      for (var child = this.firstChild; child; child = child.nextSibling) {\n        wrapperList[i++] = child;\n      }\n      wrapperList.length = i;\n      return wrapperList;\n    },\n\n    cloneNode: function(deep) {\n      return cloneNode(this, deep);\n    },\n\n    contains: function(child) {\n      return contains(this, wrapIfNeeded(child));\n    },\n\n    compareDocumentPosition: function(otherNode) {\n      // This only wraps, it therefore only operates on the composed DOM and not\n      // the logical DOM.\n      return originalCompareDocumentPosition.call(unsafeUnwrap(this),\n                                                  unwrapIfNeeded(otherNode));\n    },\n\n    normalize: function() {\n      var nodes = snapshotNodeList(this.childNodes);\n      var remNodes = [];\n      var s = '';\n      var modNode;\n\n      for (var i = 0, n; i < nodes.length; i++) {\n        n = nodes[i];\n        if (n.nodeType === Node.TEXT_NODE) {\n          if (!modNode && !n.data.length)\n            this.removeNode(n);\n          else if (!modNode)\n            modNode = n;\n          else {\n            s += n.data;\n            remNodes.push(n);\n          }\n        } else {\n          if (modNode && remNodes.length) {\n            modNode.data += s;\n            cleanupNodes(remNodes);\n          }\n          remNodes = [];\n          s = '';\n          modNode = null;\n          if (n.childNodes.length)\n            n.normalize();\n        }\n      }\n\n      // handle case where >1 text nodes are the last children\n      if (modNode && remNodes.length) {\n        modNode.data += s;\n        cleanupNodes(remNodes);\n      }\n    }\n  });\n\n  defineWrapGetter(Node, 'ownerDocument');\n\n  // We use a DocumentFragment as a base and then delete the properties of\n  // DocumentFragment.prototype from the wrapper Node. Since delete makes\n  // objects slow in some JS engines we recreate the prototype object.\n  registerWrapper(OriginalNode, Node, document.createDocumentFragment());\n  delete Node.prototype.querySelector;\n  delete Node.prototype.querySelectorAll;\n  Node.prototype = mixin(Object.create(EventTarget.prototype), Node.prototype);\n\n  scope.cloneNode = cloneNode;\n  scope.nodeWasAdded = nodeWasAdded;\n  scope.nodeWasRemoved = nodeWasRemoved;\n  scope.nodesWereAdded = nodesWereAdded;\n  scope.nodesWereRemoved = nodesWereRemoved;\n  scope.snapshotNodeList = snapshotNodeList;\n  scope.wrappers.Node = Node;\n\n})(window.ShadowDOMPolyfill);\n","// Copyright 2013 The Polymer Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var HTMLCollection = scope.wrappers.HTMLCollection;\n  var NodeList = scope.wrappers.NodeList;\n  var getTreeScope = scope.getTreeScope;\n  var unsafeUnwrap = scope.unsafeUnwrap;\n  var wrap = scope.wrap;\n\n  var originalDocumentQuerySelector = document.querySelector;\n  var originalElementQuerySelector = document.documentElement.querySelector;\n\n  var originalDocumentQuerySelectorAll = document.querySelectorAll;\n  var originalElementQuerySelectorAll = document.documentElement.querySelectorAll;\n\n  var originalDocumentGetElementsByTagName = document.getElementsByTagName;\n  var originalElementGetElementsByTagName = document.documentElement.getElementsByTagName;\n\n  var originalDocumentGetElementsByTagNameNS = document.getElementsByTagNameNS;\n  var originalElementGetElementsByTagNameNS = document.documentElement.getElementsByTagNameNS;\n\n  var OriginalElement = window.Element;\n  var OriginalDocument = window.HTMLDocument || window.Document;\n\n  function filterNodeList(list, index, result, deep) {\n    var wrappedItem = null;\n    var root = null;\n    for (var i = 0, length = list.length; i < length; i++) {\n      wrappedItem = wrap(list[i]);\n      if (!deep && (root = getTreeScope(wrappedItem).root)) {\n        if (root instanceof scope.wrappers.ShadowRoot) {\n          continue;\n        }\n      }\n      result[index++] = wrappedItem;\n    }\n\n    return index;\n  }\n\n  function shimSelector(selector) {\n    return String(selector).replace(/\\/deep\\//g, ' ');\n  }\n\n  function findOne(node, selector) {\n    var m, el = node.firstElementChild;\n    while (el) {\n      if (el.matches(selector))\n        return el;\n      m = findOne(el, selector);\n      if (m)\n        return m;\n      el = el.nextElementSibling;\n    }\n    return null;\n  }\n\n  function matchesSelector(el, selector) {\n    return el.matches(selector);\n  }\n\n  var XHTML_NS = 'http://www.w3.org/1999/xhtml';\n\n  function matchesTagName(el, localName, localNameLowerCase) {\n    var ln = el.localName;\n    return ln === localName ||\n        ln === localNameLowerCase && el.namespaceURI === XHTML_NS;\n  }\n\n  function matchesEveryThing() {\n    return true;\n  }\n\n  function matchesLocalNameOnly(el, ns, localName) {\n    return el.localName === localName;\n  }\n\n  function matchesNameSpace(el, ns) {\n    return el.namespaceURI === ns;\n  }\n\n  function matchesLocalNameNS(el, ns, localName) {\n    return el.namespaceURI === ns && el.localName === localName;\n  }\n\n  function findElements(node, index, result, p, arg0, arg1) {\n    var el = node.firstElementChild;\n    while (el) {\n      if (p(el, arg0, arg1))\n        result[index++] = el;\n      index = findElements(el, index, result, p, arg0, arg1);\n      el = el.nextElementSibling;\n    }\n    return index;\n  }\n\n  // find and findAll will only match Simple Selectors,\n  // Structural Pseudo Classes are not guarenteed to be correct\n  // http://www.w3.org/TR/css3-selectors/#simple-selectors\n\n  function querySelectorAllFiltered(p, index, result, selector, deep) {\n    var target = unsafeUnwrap(this);\n    var list;\n    var root = getTreeScope(this).root;\n    if (root instanceof scope.wrappers.ShadowRoot) {\n      // We are in the shadow tree and the logical tree is\n      // going to be disconnected so we do a manual tree traversal\n      return findElements(this, index, result, p, selector, null);\n    } else if (target instanceof OriginalElement) {\n      list = originalElementQuerySelectorAll.call(target, selector);\n    } else if (target instanceof OriginalDocument) {\n      list = originalDocumentQuerySelectorAll.call(target, selector);\n    } else {\n      // When we get a ShadowRoot the logical tree is going to be disconnected\n      // so we do a manual tree traversal\n      return findElements(this, index, result, p, selector, null);\n    }\n\n    return filterNodeList(list, index, result, deep);\n  }\n\n  var SelectorsInterface = {\n    querySelector: function(selector) {\n      var shimmed = shimSelector(selector);\n      var deep = shimmed !== selector;\n      selector = shimmed;\n\n      var target = unsafeUnwrap(this);\n      var wrappedItem;\n      var root = getTreeScope(this).root;\n      if (root instanceof scope.wrappers.ShadowRoot) {\n        // We are in the shadow tree and the logical tree is\n        // going to be disconnected so we do a manual tree traversal\n        return findOne(this, selector);\n      } else if (target instanceof OriginalElement) {\n        wrappedItem = wrap(originalElementQuerySelector.call(target, selector));\n      } else if (target instanceof OriginalDocument) {\n        wrappedItem = wrap(originalDocumentQuerySelector.call(target, selector));\n      } else {\n        // When we get a ShadowRoot the logical tree is going to be disconnected\n        // so we do a manual tree traversal\n        return findOne(this, selector);\n      }\n\n      if (!wrappedItem) {\n        // When the original query returns nothing\n        // we return nothing (to be consistent with the other wrapped calls)\n        return wrappedItem;\n      } else if (!deep && (root = getTreeScope(wrappedItem).root)) {\n        if (root instanceof scope.wrappers.ShadowRoot) {\n          // When the original query returns an element in the ShadowDOM\n          // we must do a manual tree traversal\n          return findOne(this, selector);\n        }\n      }\n\n      return wrappedItem;\n    },\n    querySelectorAll: function(selector) {\n      var shimmed = shimSelector(selector);\n      var deep = shimmed !== selector;\n      selector = shimmed;\n\n      var result = new NodeList();\n\n      result.length = querySelectorAllFiltered.call(this,\n          matchesSelector,\n          0,\n          result,\n          selector,\n          deep);\n\n      return result;\n    }\n  };\n\n  function getElementsByTagNameFiltered(p, index, result, localName,\n                                        lowercase) {\n    var target = unsafeUnwrap(this);\n    var list;\n    var root = getTreeScope(this).root;\n    if (root instanceof scope.wrappers.ShadowRoot) {\n      // We are in the shadow tree and the logical tree is\n      // going to be disconnected so we do a manual tree traversal\n      return findElements(this, index, result, p, localName, lowercase);\n    } else if (target instanceof OriginalElement) {\n      list = originalElementGetElementsByTagName.call(target, localName,\n                                                      lowercase);\n    } else if (target instanceof OriginalDocument) {\n      list = originalDocumentGetElementsByTagName.call(target, localName,\n                                                       lowercase);\n    } else {\n      // When we get a ShadowRoot the logical tree is going to be disconnected\n      // so we do a manual tree traversal\n      return findElements(this, index, result, p, localName, lowercase);\n    }\n\n    return filterNodeList(list, index, result, false);\n  }\n\n  function getElementsByTagNameNSFiltered(p, index, result, ns, localName) {\n    var target = unsafeUnwrap(this);\n    var list;\n    var root = getTreeScope(this).root;\n    if (root instanceof scope.wrappers.ShadowRoot) {\n      // We are in the shadow tree and the logical tree is\n      // going to be disconnected so we do a manual tree traversal\n      return findElements(this, index, result, p, ns, localName);\n    } else if (target instanceof OriginalElement) {\n      list = originalElementGetElementsByTagNameNS.call(target, ns, localName);\n    } else if (target instanceof OriginalDocument) {\n      list = originalDocumentGetElementsByTagNameNS.call(target, ns, localName);\n    } else {\n      // When we get a ShadowRoot the logical tree is going to be disconnected\n      // so we do a manual tree traversal\n      return findElements(this, index, result, p, ns, localName);\n    }\n\n    return filterNodeList(list, index, result, false);\n  }\n\n  var GetElementsByInterface = {\n    getElementsByTagName: function(localName) {\n      var result = new HTMLCollection();\n      var match = localName === '*' ? matchesEveryThing : matchesTagName;\n\n      result.length = getElementsByTagNameFiltered.call(this,\n          match,\n          0,\n          result,\n          localName,\n          localName.toLowerCase());\n\n      return result;\n    },\n\n    getElementsByClassName: function(className) {\n      // TODO(arv): Check className?\n      return this.querySelectorAll('.' + className);\n    },\n\n    getElementsByTagNameNS: function(ns, localName) {\n      var result = new HTMLCollection();\n      var match = null;\n\n      if (ns === '*') {\n        match = localName === '*' ? matchesEveryThing : matchesLocalNameOnly;\n      } else {\n        match = localName === '*' ? matchesNameSpace : matchesLocalNameNS;\n      }\n\n      result.length = getElementsByTagNameNSFiltered.call(this,\n          match,\n          0,\n          result,\n          ns || null,\n          localName);\n\n      return result;\n    }\n  };\n\n  scope.GetElementsByInterface = GetElementsByInterface;\n  scope.SelectorsInterface = SelectorsInterface;\n\n})(window.ShadowDOMPolyfill);\n","// Copyright 2013 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var NodeList = scope.wrappers.NodeList;\n\n  function forwardElement(node) {\n    while (node && node.nodeType !== Node.ELEMENT_NODE) {\n      node = node.nextSibling;\n    }\n    return node;\n  }\n\n  function backwardsElement(node) {\n    while (node && node.nodeType !== Node.ELEMENT_NODE) {\n      node = node.previousSibling;\n    }\n    return node;\n  }\n\n  var ParentNodeInterface = {\n    get firstElementChild() {\n      return forwardElement(this.firstChild);\n    },\n\n    get lastElementChild() {\n      return backwardsElement(this.lastChild);\n    },\n\n    get childElementCount() {\n      var count = 0;\n      for (var child = this.firstElementChild;\n           child;\n           child = child.nextElementSibling) {\n        count++;\n      }\n      return count;\n    },\n\n    get children() {\n      var wrapperList = new NodeList();\n      var i = 0;\n      for (var child = this.firstElementChild;\n           child;\n           child = child.nextElementSibling) {\n        wrapperList[i++] = child;\n      }\n      wrapperList.length = i;\n      return wrapperList;\n    },\n\n    remove: function() {\n      var p = this.parentNode;\n      if (p)\n        p.removeChild(this);\n    }\n  };\n\n  var ChildNodeInterface = {\n    get nextElementSibling() {\n      return forwardElement(this.nextSibling);\n    },\n\n    get previousElementSibling() {\n      return backwardsElement(this.previousSibling);\n    }\n  };\n\n  scope.ChildNodeInterface = ChildNodeInterface;\n  scope.ParentNodeInterface = ParentNodeInterface;\n\n})(window.ShadowDOMPolyfill);\n","// Copyright 2013 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var ChildNodeInterface = scope.ChildNodeInterface;\n  var Node = scope.wrappers.Node;\n  var enqueueMutation = scope.enqueueMutation;\n  var mixin = scope.mixin;\n  var registerWrapper = scope.registerWrapper;\n  var unsafeUnwrap = scope.unsafeUnwrap;\n\n  var OriginalCharacterData = window.CharacterData;\n\n  function CharacterData(node) {\n    Node.call(this, node);\n  }\n  CharacterData.prototype = Object.create(Node.prototype);\n  mixin(CharacterData.prototype, {\n    get textContent() {\n      return this.data;\n    },\n    set textContent(value) {\n      this.data = value;\n    },\n    get data() {\n      return unsafeUnwrap(this).data;\n    },\n    set data(value) {\n      var oldValue = unsafeUnwrap(this).data;\n      enqueueMutation(this, 'characterData', {\n        oldValue: oldValue\n      });\n      unsafeUnwrap(this).data = value;\n    }\n  });\n\n  mixin(CharacterData.prototype, ChildNodeInterface);\n\n  registerWrapper(OriginalCharacterData, CharacterData,\n                  document.createTextNode(''));\n\n  scope.wrappers.CharacterData = CharacterData;\n})(window.ShadowDOMPolyfill);\n","// Copyright 2014 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var CharacterData = scope.wrappers.CharacterData;\n  var enqueueMutation = scope.enqueueMutation;\n  var mixin = scope.mixin;\n  var registerWrapper = scope.registerWrapper;\n\n  function toUInt32(x) {\n    return x >>> 0;\n  }\n\n  var OriginalText = window.Text;\n\n  function Text(node) {\n    CharacterData.call(this, node);\n  }\n  Text.prototype = Object.create(CharacterData.prototype);\n  mixin(Text.prototype, {\n    splitText: function(offset) {\n      offset = toUInt32(offset);\n      var s = this.data;\n      if (offset > s.length)\n        throw new Error('IndexSizeError');\n      var head = s.slice(0, offset);\n      var tail = s.slice(offset);\n      this.data = head;\n      var newTextNode = this.ownerDocument.createTextNode(tail);\n      if (this.parentNode)\n        this.parentNode.insertBefore(newTextNode, this.nextSibling);\n      return newTextNode;\n    }\n  });\n\n  registerWrapper(OriginalText, Text, document.createTextNode(''));\n\n  scope.wrappers.Text = Text;\n})(window.ShadowDOMPolyfill);\n","// Copyright 2014 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var setWrapper = scope.setWrapper;\n  var unsafeUnwrap = scope.unsafeUnwrap;\n\n  function invalidateClass(el) {\n    scope.invalidateRendererBasedOnAttribute(el, 'class');\n  }\n\n  function DOMTokenList(impl, ownerElement) {\n    setWrapper(impl, this);\n    this.ownerElement_ = ownerElement;\n  }\n\n  DOMTokenList.prototype = {\n    constructor: DOMTokenList,\n    get length() {\n      return unsafeUnwrap(this).length;\n    },\n    item: function(index) {\n      return unsafeUnwrap(this).item(index);\n    },\n    contains: function(token) {\n      return unsafeUnwrap(this).contains(token);\n    },\n    add: function() {\n      unsafeUnwrap(this).add.apply(unsafeUnwrap(this), arguments);\n      invalidateClass(this.ownerElement_);\n    },\n    remove: function() {\n      unsafeUnwrap(this).remove.apply(unsafeUnwrap(this), arguments);\n      invalidateClass(this.ownerElement_);\n    },\n    toggle: function(token) {\n      var rv = unsafeUnwrap(this).toggle.apply(unsafeUnwrap(this), arguments);\n      invalidateClass(this.ownerElement_);\n      return rv;\n    },\n    toString: function() {\n      return unsafeUnwrap(this).toString();\n    }\n  };\n\n  scope.wrappers.DOMTokenList = DOMTokenList;\n})(window.ShadowDOMPolyfill);\n","// Copyright 2013 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var ChildNodeInterface = scope.ChildNodeInterface;\n  var GetElementsByInterface = scope.GetElementsByInterface;\n  var Node = scope.wrappers.Node;\n  var DOMTokenList = scope.wrappers.DOMTokenList;\n  var ParentNodeInterface = scope.ParentNodeInterface;\n  var SelectorsInterface = scope.SelectorsInterface;\n  var addWrapNodeListMethod = scope.addWrapNodeListMethod;\n  var enqueueMutation = scope.enqueueMutation;\n  var mixin = scope.mixin;\n  var oneOf = scope.oneOf;\n  var registerWrapper = scope.registerWrapper;\n  var unsafeUnwrap = scope.unsafeUnwrap;\n  var wrappers = scope.wrappers;\n\n  var OriginalElement = window.Element;\n\n  var matchesNames = [\n    'matches',  // needs to come first.\n    'mozMatchesSelector',\n    'msMatchesSelector',\n    'webkitMatchesSelector',\n  ].filter(function(name) {\n    return OriginalElement.prototype[name];\n  });\n\n  var matchesName = matchesNames[0];\n\n  var originalMatches = OriginalElement.prototype[matchesName];\n\n  function invalidateRendererBasedOnAttribute(element, name) {\n    // Only invalidate if parent node is a shadow host.\n    var p = element.parentNode;\n    if (!p || !p.shadowRoot)\n      return;\n\n    var renderer = scope.getRendererForHost(p);\n    if (renderer.dependsOnAttribute(name))\n      renderer.invalidate();\n  }\n\n  function enqueAttributeChange(element, name, oldValue) {\n    // This is not fully spec compliant. We should use localName (which might\n    // have a different case than name) and the namespace (which requires us\n    // to get the Attr object).\n    enqueueMutation(element, 'attributes', {\n      name: name,\n      namespace: null,\n      oldValue: oldValue\n    });\n  }\n\n  var classListTable = new WeakMap();\n\n  function Element(node) {\n    Node.call(this, node);\n  }\n  Element.prototype = Object.create(Node.prototype);\n  mixin(Element.prototype, {\n    createShadowRoot: function() {\n      var newShadowRoot = new wrappers.ShadowRoot(this);\n      unsafeUnwrap(this).polymerShadowRoot_ = newShadowRoot;\n\n      var renderer = scope.getRendererForHost(this);\n      renderer.invalidate();\n\n      return newShadowRoot;\n    },\n\n    get shadowRoot() {\n      return unsafeUnwrap(this).polymerShadowRoot_ || null;\n    },\n\n    // getDestinationInsertionPoints added in ShadowRenderer.js\n\n    setAttribute: function(name, value) {\n      var oldValue = unsafeUnwrap(this).getAttribute(name);\n      unsafeUnwrap(this).setAttribute(name, value);\n      enqueAttributeChange(this, name, oldValue);\n      invalidateRendererBasedOnAttribute(this, name);\n    },\n\n    removeAttribute: function(name) {\n      var oldValue = unsafeUnwrap(this).getAttribute(name);\n      unsafeUnwrap(this).removeAttribute(name);\n      enqueAttributeChange(this, name, oldValue);\n      invalidateRendererBasedOnAttribute(this, name);\n    },\n\n    matches: function(selector) {\n      return originalMatches.call(unsafeUnwrap(this), selector);\n    },\n\n    get classList() {\n      var list = classListTable.get(this);\n      if (!list) {\n        classListTable.set(this,\n            list = new DOMTokenList(unsafeUnwrap(this).classList, this));\n      }\n      return list;\n    },\n\n    get className() {\n      return unsafeUnwrap(this).className;\n    },\n\n    set className(v) {\n      this.setAttribute('class', v);\n    },\n\n    get id() {\n      return unsafeUnwrap(this).id;\n    },\n\n    set id(v) {\n      this.setAttribute('id', v);\n    }\n  });\n\n  matchesNames.forEach(function(name) {\n    if (name !== 'matches') {\n      Element.prototype[name] = function(selector) {\n        return this.matches(selector);\n      };\n    }\n  });\n\n  if (OriginalElement.prototype.webkitCreateShadowRoot) {\n    Element.prototype.webkitCreateShadowRoot =\n        Element.prototype.createShadowRoot;\n  }\n\n  mixin(Element.prototype, ChildNodeInterface);\n  mixin(Element.prototype, GetElementsByInterface);\n  mixin(Element.prototype, ParentNodeInterface);\n  mixin(Element.prototype, SelectorsInterface);\n\n  registerWrapper(OriginalElement, Element,\n                  document.createElementNS(null, 'x'));\n\n  scope.invalidateRendererBasedOnAttribute = invalidateRendererBasedOnAttribute;\n  scope.matchesNames = matchesNames;\n  scope.wrappers.Element = Element;\n})(window.ShadowDOMPolyfill);\n","// Copyright 2013 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var Element = scope.wrappers.Element;\n  var defineGetter = scope.defineGetter;\n  var enqueueMutation = scope.enqueueMutation;\n  var mixin = scope.mixin;\n  var nodesWereAdded = scope.nodesWereAdded;\n  var nodesWereRemoved = scope.nodesWereRemoved;\n  var registerWrapper = scope.registerWrapper;\n  var snapshotNodeList = scope.snapshotNodeList;\n  var unsafeUnwrap = scope.unsafeUnwrap;\n  var unwrap = scope.unwrap;\n  var wrap = scope.wrap;\n  var wrappers = scope.wrappers;\n\n  /////////////////////////////////////////////////////////////////////////////\n  // innerHTML and outerHTML\n\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#escapingString\n  var escapeAttrRegExp = /[&\\u00A0\"]/g;\n  var escapeDataRegExp = /[&\\u00A0<>]/g;\n\n  function escapeReplace(c) {\n    switch (c) {\n      case '&':\n        return '&amp;';\n      case '<':\n        return '&lt;';\n      case '>':\n        return '&gt;';\n      case '\"':\n        return '&quot;'\n      case '\\u00A0':\n        return '&nbsp;';\n    }\n  }\n\n  function escapeAttr(s) {\n    return s.replace(escapeAttrRegExp, escapeReplace);\n  }\n\n  function escapeData(s) {\n    return s.replace(escapeDataRegExp, escapeReplace);\n  }\n\n  function makeSet(arr) {\n    var set = {};\n    for (var i = 0; i < arr.length; i++) {\n      set[arr[i]] = true;\n    }\n    return set;\n  }\n\n  // http://www.whatwg.org/specs/web-apps/current-work/#void-elements\n  var voidElements = makeSet([\n    'area',\n    'base',\n    'br',\n    'col',\n    'command',\n    'embed',\n    'hr',\n    'img',\n    'input',\n    'keygen',\n    'link',\n    'meta',\n    'param',\n    'source',\n    'track',\n    'wbr'\n  ]);\n\n  var plaintextParents = makeSet([\n    'style',\n    'script',\n    'xmp',\n    'iframe',\n    'noembed',\n    'noframes',\n    'plaintext',\n    'noscript'\n  ]);\n\n  function getOuterHTML(node, parentNode) {\n    switch (node.nodeType) {\n      case Node.ELEMENT_NODE:\n        var tagName = node.tagName.toLowerCase();\n        var s = '<' + tagName;\n        var attrs = node.attributes;\n        for (var i = 0, attr; attr = attrs[i]; i++) {\n          s += ' ' + attr.name + '=\"' + escapeAttr(attr.value) + '\"';\n        }\n        s += '>';\n        if (voidElements[tagName])\n          return s;\n\n        return s + getInnerHTML(node) + '</' + tagName + '>';\n\n      case Node.TEXT_NODE:\n        var data = node.data;\n        if (parentNode && plaintextParents[parentNode.localName])\n          return data;\n        return escapeData(data);\n\n      case Node.COMMENT_NODE:\n        return '<!--' + node.data + '-->';\n\n      default:\n        console.error(node);\n        throw new Error('not implemented');\n    }\n  }\n\n  function getInnerHTML(node) {\n    if (node instanceof wrappers.HTMLTemplateElement)\n      node = node.content;\n\n    var s = '';\n    for (var child = node.firstChild; child; child = child.nextSibling) {\n      s += getOuterHTML(child, node);\n    }\n    return s;\n  }\n\n  function setInnerHTML(node, value, opt_tagName) {\n    var tagName = opt_tagName || 'div';\n    node.textContent = '';\n    var tempElement = unwrap(node.ownerDocument.createElement(tagName));\n    tempElement.innerHTML = value;\n    var firstChild;\n    while (firstChild = tempElement.firstChild) {\n      node.appendChild(wrap(firstChild));\n    }\n  }\n\n  // IE11 does not have MSIE in the user agent string.\n  var oldIe = /MSIE/.test(navigator.userAgent);\n\n  var OriginalHTMLElement = window.HTMLElement;\n  var OriginalHTMLTemplateElement = window.HTMLTemplateElement;\n\n  function HTMLElement(node) {\n    Element.call(this, node);\n  }\n  HTMLElement.prototype = Object.create(Element.prototype);\n  mixin(HTMLElement.prototype, {\n    get innerHTML() {\n      return getInnerHTML(this);\n    },\n    set innerHTML(value) {\n      // IE9 does not handle set innerHTML correctly on plaintextParents. It\n      // creates element children. For example\n      //\n      //   scriptElement.innerHTML = '<a>test</a>'\n      //\n      // Creates a single HTMLAnchorElement child.\n      if (oldIe && plaintextParents[this.localName]) {\n        this.textContent = value;\n        return;\n      }\n\n      var removedNodes = snapshotNodeList(this.childNodes);\n\n      if (this.invalidateShadowRenderer()) {\n        if (this instanceof wrappers.HTMLTemplateElement)\n          setInnerHTML(this.content, value);\n        else\n          setInnerHTML(this, value, this.tagName);\n\n      // If we have a non native template element we need to handle this\n      // manually since setting impl.innerHTML would add the html as direct\n      // children and not be moved over to the content fragment.\n      } else if (!OriginalHTMLTemplateElement &&\n                 this instanceof wrappers.HTMLTemplateElement) {\n        setInnerHTML(this.content, value);\n      } else {\n        unsafeUnwrap(this).innerHTML = value;\n      }\n\n      var addedNodes = snapshotNodeList(this.childNodes);\n\n      enqueueMutation(this, 'childList', {\n        addedNodes: addedNodes,\n        removedNodes: removedNodes\n      });\n\n      nodesWereRemoved(removedNodes);\n      nodesWereAdded(addedNodes, this);\n    },\n\n    get outerHTML() {\n      return getOuterHTML(this, this.parentNode);\n    },\n    set outerHTML(value) {\n      var p = this.parentNode;\n      if (p) {\n        p.invalidateShadowRenderer();\n        var df = frag(p, value);\n        p.replaceChild(df, this);\n      }\n    },\n\n    insertAdjacentHTML: function(position, text) {\n      var contextElement, refNode;\n      switch (String(position).toLowerCase()) {\n        case 'beforebegin':\n          contextElement = this.parentNode;\n          refNode = this;\n          break;\n        case 'afterend':\n          contextElement = this.parentNode;\n          refNode = this.nextSibling;\n          break;\n        case 'afterbegin':\n          contextElement = this;\n          refNode = this.firstChild;\n          break;\n        case 'beforeend':\n          contextElement = this;\n          refNode = null;\n          break;\n        default:\n          return;\n      }\n\n      var df = frag(contextElement, text);\n      contextElement.insertBefore(df, refNode);\n    },\n\n    get hidden() {\n      return this.hasAttribute('hidden');\n    },\n    set hidden(v) {\n      if (v) {\n        this.setAttribute('hidden', '');\n      } else {\n        this.removeAttribute('hidden');\n      }\n    }\n  });\n\n  function frag(contextElement, html) {\n    // TODO(arv): This does not work with SVG and other non HTML elements.\n    var p = unwrap(contextElement.cloneNode(false));\n    p.innerHTML = html;\n    var df = unwrap(document.createDocumentFragment());\n    var c;\n    while (c = p.firstChild) {\n      df.appendChild(c);\n    }\n    return wrap(df);\n  }\n\n  function getter(name) {\n    return function() {\n      scope.renderAllPending();\n      return unsafeUnwrap(this)[name];\n    };\n  }\n\n  function getterRequiresRendering(name) {\n    defineGetter(HTMLElement, name, getter(name));\n  }\n\n  [\n    'clientHeight',\n    'clientLeft',\n    'clientTop',\n    'clientWidth',\n    'offsetHeight',\n    'offsetLeft',\n    'offsetTop',\n    'offsetWidth',\n    'scrollHeight',\n    'scrollWidth',\n  ].forEach(getterRequiresRendering);\n\n  function getterAndSetterRequiresRendering(name) {\n    Object.defineProperty(HTMLElement.prototype, name, {\n      get: getter(name),\n      set: function(v) {\n        scope.renderAllPending();\n        unsafeUnwrap(this)[name] = v;\n      },\n      configurable: true,\n      enumerable: true\n    });\n  }\n\n  [\n    'scrollLeft',\n    'scrollTop',\n  ].forEach(getterAndSetterRequiresRendering);\n\n  function methodRequiresRendering(name) {\n    Object.defineProperty(HTMLElement.prototype, name, {\n      value: function() {\n        scope.renderAllPending();\n        return unsafeUnwrap(this)[name].apply(unsafeUnwrap(this), arguments);\n      },\n      configurable: true,\n      enumerable: true\n    });\n  }\n\n  [\n    'getBoundingClientRect',\n    'getClientRects',\n    'scrollIntoView'\n  ].forEach(methodRequiresRendering);\n\n  // HTMLElement is abstract so we use a subclass that has no members.\n  registerWrapper(OriginalHTMLElement, HTMLElement,\n                  document.createElement('b'));\n\n  scope.wrappers.HTMLElement = HTMLElement;\n\n  // TODO: Find a better way to share these two with WrapperShadowRoot.\n  scope.getInnerHTML = getInnerHTML;\n  scope.setInnerHTML = setInnerHTML\n})(window.ShadowDOMPolyfill);\n","// Copyright 2013 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var HTMLElement = scope.wrappers.HTMLElement;\n  var mixin = scope.mixin;\n  var registerWrapper = scope.registerWrapper;\n  var unsafeUnwrap = scope.unsafeUnwrap;\n  var wrap = scope.wrap;\n\n  var OriginalHTMLCanvasElement = window.HTMLCanvasElement;\n\n  function HTMLCanvasElement(node) {\n    HTMLElement.call(this, node);\n  }\n  HTMLCanvasElement.prototype = Object.create(HTMLElement.prototype);\n\n  mixin(HTMLCanvasElement.prototype, {\n    getContext: function() {\n      var context = unsafeUnwrap(this).getContext.apply(unsafeUnwrap(this), arguments);\n      return context && wrap(context);\n    }\n  });\n\n  registerWrapper(OriginalHTMLCanvasElement, HTMLCanvasElement,\n                  document.createElement('canvas'));\n\n  scope.wrappers.HTMLCanvasElement = HTMLCanvasElement;\n})(window.ShadowDOMPolyfill);\n","// Copyright 2013 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var HTMLElement = scope.wrappers.HTMLElement;\n  var mixin = scope.mixin;\n  var registerWrapper = scope.registerWrapper;\n\n  var OriginalHTMLContentElement = window.HTMLContentElement;\n\n  function HTMLContentElement(node) {\n    HTMLElement.call(this, node);\n  }\n  HTMLContentElement.prototype = Object.create(HTMLElement.prototype);\n  mixin(HTMLContentElement.prototype, {\n    constructor: HTMLContentElement,\n\n    get select() {\n      return this.getAttribute('select');\n    },\n    set select(value) {\n      this.setAttribute('select', value);\n    },\n\n    setAttribute: function(n, v) {\n      HTMLElement.prototype.setAttribute.call(this, n, v);\n      if (String(n).toLowerCase() === 'select')\n        this.invalidateShadowRenderer(true);\n    }\n\n    // getDistributedNodes is added in ShadowRenderer\n  });\n\n  if (OriginalHTMLContentElement)\n    registerWrapper(OriginalHTMLContentElement, HTMLContentElement);\n\n  scope.wrappers.HTMLContentElement = HTMLContentElement;\n})(window.ShadowDOMPolyfill);\n","/*\n * Copyright 2014 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\n(function(scope) {\n  'use strict';\n\n  var HTMLElement = scope.wrappers.HTMLElement;\n  var mixin = scope.mixin;\n  var registerWrapper = scope.registerWrapper;\n  var wrapHTMLCollection = scope.wrapHTMLCollection;\n  var unwrap = scope.unwrap;\n\n  var OriginalHTMLFormElement = window.HTMLFormElement;\n\n  function HTMLFormElement(node) {\n    HTMLElement.call(this, node);\n  }\n  HTMLFormElement.prototype = Object.create(HTMLElement.prototype);\n  mixin(HTMLFormElement.prototype, {\n    get elements() {\n      // Note: technically this should be an HTMLFormControlsCollection, but\n      // that inherits from HTMLCollection, so should be good enough. Spec:\n      // http://www.whatwg.org/specs/web-apps/current-work/multipage/common-dom-interfaces.html#htmlformcontrolscollection\n      return wrapHTMLCollection(unwrap(this).elements);\n    }\n  });\n\n  registerWrapper(OriginalHTMLFormElement, HTMLFormElement,\n                  document.createElement('form'));\n\n  scope.wrappers.HTMLFormElement = HTMLFormElement;\n})(window.ShadowDOMPolyfill);\n","// Copyright 2013 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var HTMLElement = scope.wrappers.HTMLElement;\n  var registerWrapper = scope.registerWrapper;\n  var unwrap = scope.unwrap;\n  var rewrap = scope.rewrap;\n\n  var OriginalHTMLImageElement = window.HTMLImageElement;\n\n  function HTMLImageElement(node) {\n    HTMLElement.call(this, node);\n  }\n  HTMLImageElement.prototype = Object.create(HTMLElement.prototype);\n\n  registerWrapper(OriginalHTMLImageElement, HTMLImageElement,\n                  document.createElement('img'));\n\n  function Image(width, height) {\n    if (!(this instanceof Image)) {\n      throw new TypeError(\n          'DOM object constructor cannot be called as a function.');\n    }\n\n    var node = unwrap(document.createElement('img'));\n    HTMLElement.call(this, node);\n    rewrap(node, this);\n\n    if (width !== undefined)\n      node.width = width;\n    if (height !== undefined)\n      node.height = height;\n  }\n\n  Image.prototype = HTMLImageElement.prototype;\n\n  scope.wrappers.HTMLImageElement = HTMLImageElement;\n  scope.wrappers.Image = Image;\n})(window.ShadowDOMPolyfill);\n","// Copyright 2013 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var HTMLElement = scope.wrappers.HTMLElement;\n  var mixin = scope.mixin;\n  var NodeList = scope.wrappers.NodeList;\n  var registerWrapper = scope.registerWrapper;\n\n  var OriginalHTMLShadowElement = window.HTMLShadowElement;\n\n  function HTMLShadowElement(node) {\n    HTMLElement.call(this, node);\n  }\n  HTMLShadowElement.prototype = Object.create(HTMLElement.prototype);\n  HTMLShadowElement.prototype.constructor = HTMLShadowElement;\n\n  // getDistributedNodes is added in ShadowRenderer\n\n  if (OriginalHTMLShadowElement)\n    registerWrapper(OriginalHTMLShadowElement, HTMLShadowElement);\n\n  scope.wrappers.HTMLShadowElement = HTMLShadowElement;\n})(window.ShadowDOMPolyfill);\n","// Copyright 2013 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var HTMLElement = scope.wrappers.HTMLElement;\n  var mixin = scope.mixin;\n  var registerWrapper = scope.registerWrapper;\n  var unsafeUnwrap = scope.unsafeUnwrap;\n  var unwrap = scope.unwrap;\n  var wrap = scope.wrap;\n\n  var contentTable = new WeakMap();\n  var templateContentsOwnerTable = new WeakMap();\n\n  // http://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/templates/index.html#dfn-template-contents-owner\n  function getTemplateContentsOwner(doc) {\n    if (!doc.defaultView)\n      return doc;\n    var d = templateContentsOwnerTable.get(doc);\n    if (!d) {\n      // TODO(arv): This should either be a Document or HTMLDocument depending\n      // on doc.\n      d = doc.implementation.createHTMLDocument('');\n      while (d.lastChild) {\n        d.removeChild(d.lastChild);\n      }\n      templateContentsOwnerTable.set(doc, d);\n    }\n    return d;\n  }\n\n  function extractContent(templateElement) {\n    // templateElement is not a wrapper here.\n    var doc = getTemplateContentsOwner(templateElement.ownerDocument);\n    var df = unwrap(doc.createDocumentFragment());\n    var child;\n    while (child = templateElement.firstChild) {\n      df.appendChild(child);\n    }\n    return df;\n  }\n\n  var OriginalHTMLTemplateElement = window.HTMLTemplateElement;\n\n  function HTMLTemplateElement(node) {\n    HTMLElement.call(this, node);\n    if (!OriginalHTMLTemplateElement) {\n      var content = extractContent(node);\n      contentTable.set(this, wrap(content));\n    }\n  }\n  HTMLTemplateElement.prototype = Object.create(HTMLElement.prototype);\n\n  mixin(HTMLTemplateElement.prototype, {\n    constructor: HTMLTemplateElement,\n    get content() {\n      if (OriginalHTMLTemplateElement)\n        return wrap(unsafeUnwrap(this).content);\n      return contentTable.get(this);\n    },\n\n    // TODO(arv): cloneNode needs to clone content.\n\n  });\n\n  if (OriginalHTMLTemplateElement)\n    registerWrapper(OriginalHTMLTemplateElement, HTMLTemplateElement);\n\n  scope.wrappers.HTMLTemplateElement = HTMLTemplateElement;\n})(window.ShadowDOMPolyfill);\n","// Copyright 2013 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var HTMLElement = scope.wrappers.HTMLElement;\n  var registerWrapper = scope.registerWrapper;\n\n  var OriginalHTMLMediaElement = window.HTMLMediaElement;\n\n  if (!OriginalHTMLMediaElement) return;\n\n  function HTMLMediaElement(node) {\n    HTMLElement.call(this, node);\n  }\n  HTMLMediaElement.prototype = Object.create(HTMLElement.prototype);\n\n  registerWrapper(OriginalHTMLMediaElement, HTMLMediaElement,\n                  document.createElement('audio'));\n\n  scope.wrappers.HTMLMediaElement = HTMLMediaElement;\n})(window.ShadowDOMPolyfill);\n","// Copyright 2013 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var HTMLMediaElement = scope.wrappers.HTMLMediaElement;\n  var registerWrapper = scope.registerWrapper;\n  var unwrap = scope.unwrap;\n  var rewrap = scope.rewrap;\n\n  var OriginalHTMLAudioElement = window.HTMLAudioElement;\n\n  if (!OriginalHTMLAudioElement) return;\n\n  function HTMLAudioElement(node) {\n    HTMLMediaElement.call(this, node);\n  }\n  HTMLAudioElement.prototype = Object.create(HTMLMediaElement.prototype);\n\n  registerWrapper(OriginalHTMLAudioElement, HTMLAudioElement,\n                  document.createElement('audio'));\n\n  function Audio(src) {\n    if (!(this instanceof Audio)) {\n      throw new TypeError(\n          'DOM object constructor cannot be called as a function.');\n    }\n\n    var node = unwrap(document.createElement('audio'));\n    HTMLMediaElement.call(this, node);\n    rewrap(node, this);\n\n    node.setAttribute('preload', 'auto');\n    if (src !== undefined)\n      node.setAttribute('src', src);\n  }\n\n  Audio.prototype = HTMLAudioElement.prototype;\n\n  scope.wrappers.HTMLAudioElement = HTMLAudioElement;\n  scope.wrappers.Audio = Audio;\n})(window.ShadowDOMPolyfill);\n","// Copyright 2013 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var HTMLElement = scope.wrappers.HTMLElement;\n  var mixin = scope.mixin;\n  var registerWrapper = scope.registerWrapper;\n  var rewrap = scope.rewrap;\n  var unwrap = scope.unwrap;\n  var wrap = scope.wrap;\n\n  var OriginalHTMLOptionElement = window.HTMLOptionElement;\n\n  function trimText(s) {\n    return s.replace(/\\s+/g, ' ').trim();\n  }\n\n  function HTMLOptionElement(node) {\n    HTMLElement.call(this, node);\n  }\n  HTMLOptionElement.prototype = Object.create(HTMLElement.prototype);\n  mixin(HTMLOptionElement.prototype, {\n    get text() {\n      return trimText(this.textContent);\n    },\n    set text(value) {\n      this.textContent = trimText(String(value));\n    },\n    get form() {\n      return wrap(unwrap(this).form);\n    }\n  });\n\n  registerWrapper(OriginalHTMLOptionElement, HTMLOptionElement,\n                  document.createElement('option'));\n\n  function Option(text, value, defaultSelected, selected) {\n    if (!(this instanceof Option)) {\n      throw new TypeError(\n          'DOM object constructor cannot be called as a function.');\n    }\n\n    var node = unwrap(document.createElement('option'));\n    HTMLElement.call(this, node);\n    rewrap(node, this);\n\n    if (text !== undefined)\n      node.text = text;\n    if (value !== undefined)\n      node.setAttribute('value', value);\n    if (defaultSelected === true)\n      node.setAttribute('selected', '');\n    node.selected = selected === true;\n  }\n\n  Option.prototype = HTMLOptionElement.prototype;\n\n  scope.wrappers.HTMLOptionElement = HTMLOptionElement;\n  scope.wrappers.Option = Option;\n})(window.ShadowDOMPolyfill);\n","// Copyright 2014 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var HTMLElement = scope.wrappers.HTMLElement;\n  var mixin = scope.mixin;\n  var registerWrapper = scope.registerWrapper;\n  var unwrap = scope.unwrap;\n  var wrap = scope.wrap;\n\n  var OriginalHTMLSelectElement = window.HTMLSelectElement;\n\n  function HTMLSelectElement(node) {\n    HTMLElement.call(this, node);\n  }\n  HTMLSelectElement.prototype = Object.create(HTMLElement.prototype);\n  mixin(HTMLSelectElement.prototype, {\n    add: function(element, before) {\n      if (typeof before === 'object')  // also includes null\n        before = unwrap(before);\n      unwrap(this).add(unwrap(element), before);\n    },\n\n    remove: function(indexOrNode) {\n      // Spec only allows index but implementations allow index or node.\n      // remove() is also allowed which is same as remove(undefined)\n      if (indexOrNode === undefined) {\n        HTMLElement.prototype.remove.call(this);\n        return;\n      }\n\n      if (typeof indexOrNode === 'object')\n        indexOrNode = unwrap(indexOrNode);\n\n      unwrap(this).remove(indexOrNode);\n    },\n\n    get form() {\n      return wrap(unwrap(this).form);\n    }\n  });\n\n  registerWrapper(OriginalHTMLSelectElement, HTMLSelectElement,\n                  document.createElement('select'));\n\n  scope.wrappers.HTMLSelectElement = HTMLSelectElement;\n})(window.ShadowDOMPolyfill);\n","/*\n * Copyright 2014 The Polymer Authors. All rights reserved.\n * Use of this source code is goverened by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\n(function(scope) {\n  'use strict';\n\n  var HTMLElement = scope.wrappers.HTMLElement;\n  var mixin = scope.mixin;\n  var registerWrapper = scope.registerWrapper;\n  var unwrap = scope.unwrap;\n  var wrap = scope.wrap;\n  var wrapHTMLCollection = scope.wrapHTMLCollection;\n\n  var OriginalHTMLTableElement = window.HTMLTableElement;\n\n  function HTMLTableElement(node) {\n    HTMLElement.call(this, node);\n  }\n  HTMLTableElement.prototype = Object.create(HTMLElement.prototype);\n  mixin(HTMLTableElement.prototype, {\n    get caption() {\n      return wrap(unwrap(this).caption);\n    },\n    createCaption: function() {\n      return wrap(unwrap(this).createCaption());\n    },\n\n    get tHead() {\n      return wrap(unwrap(this).tHead);\n    },\n    createTHead: function() {\n      return wrap(unwrap(this).createTHead());\n    },\n\n    createTFoot: function() {\n      return wrap(unwrap(this).createTFoot());\n    },\n    get tFoot() {\n      return wrap(unwrap(this).tFoot);\n    },\n\n    get tBodies() {\n      return wrapHTMLCollection(unwrap(this).tBodies);\n    },\n    createTBody: function() {\n      return wrap(unwrap(this).createTBody());\n    },\n\n    get rows() {\n      return wrapHTMLCollection(unwrap(this).rows);\n    },\n    insertRow: function(index) {\n      return wrap(unwrap(this).insertRow(index));\n    }\n  });\n\n  registerWrapper(OriginalHTMLTableElement, HTMLTableElement,\n                  document.createElement('table'));\n\n  scope.wrappers.HTMLTableElement = HTMLTableElement;\n})(window.ShadowDOMPolyfill);\n","/*\n * Copyright 2014 The Polymer Authors. All rights reserved.\n * Use of this source code is goverened by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\n(function(scope) {\n  'use strict';\n\n  var HTMLElement = scope.wrappers.HTMLElement;\n  var mixin = scope.mixin;\n  var registerWrapper = scope.registerWrapper;\n  var wrapHTMLCollection = scope.wrapHTMLCollection;\n  var unwrap = scope.unwrap;\n  var wrap = scope.wrap;\n\n  var OriginalHTMLTableSectionElement = window.HTMLTableSectionElement;\n\n  function HTMLTableSectionElement(node) {\n    HTMLElement.call(this, node);\n  }\n  HTMLTableSectionElement.prototype = Object.create(HTMLElement.prototype);\n  mixin(HTMLTableSectionElement.prototype, {\n    constructor: HTMLTableSectionElement,\n    get rows() {\n      return wrapHTMLCollection(unwrap(this).rows);\n    },\n    insertRow: function(index) {\n      return wrap(unwrap(this).insertRow(index));\n    }\n  });\n\n  registerWrapper(OriginalHTMLTableSectionElement, HTMLTableSectionElement,\n                  document.createElement('thead'));\n\n  scope.wrappers.HTMLTableSectionElement = HTMLTableSectionElement;\n})(window.ShadowDOMPolyfill);\n","/*\n * Copyright 2014 The Polymer Authors. All rights reserved.\n * Use of this source code is goverened by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\n(function(scope) {\n  'use strict';\n\n  var HTMLElement = scope.wrappers.HTMLElement;\n  var mixin = scope.mixin;\n  var registerWrapper = scope.registerWrapper;\n  var wrapHTMLCollection = scope.wrapHTMLCollection;\n  var unwrap = scope.unwrap;\n  var wrap = scope.wrap;\n\n  var OriginalHTMLTableRowElement = window.HTMLTableRowElement;\n\n  function HTMLTableRowElement(node) {\n    HTMLElement.call(this, node);\n  }\n  HTMLTableRowElement.prototype = Object.create(HTMLElement.prototype);\n  mixin(HTMLTableRowElement.prototype, {\n    get cells() {\n      return wrapHTMLCollection(unwrap(this).cells);\n    },\n\n    insertCell: function(index) {\n      return wrap(unwrap(this).insertCell(index));\n    }\n  });\n\n  registerWrapper(OriginalHTMLTableRowElement, HTMLTableRowElement,\n                  document.createElement('tr'));\n\n  scope.wrappers.HTMLTableRowElement = HTMLTableRowElement;\n})(window.ShadowDOMPolyfill);\n","// Copyright 2013 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var HTMLContentElement = scope.wrappers.HTMLContentElement;\n  var HTMLElement = scope.wrappers.HTMLElement;\n  var HTMLShadowElement = scope.wrappers.HTMLShadowElement;\n  var HTMLTemplateElement = scope.wrappers.HTMLTemplateElement;\n  var mixin = scope.mixin;\n  var registerWrapper = scope.registerWrapper;\n\n  var OriginalHTMLUnknownElement = window.HTMLUnknownElement;\n\n  function HTMLUnknownElement(node) {\n    switch (node.localName) {\n      case 'content':\n        return new HTMLContentElement(node);\n      case 'shadow':\n        return new HTMLShadowElement(node);\n      case 'template':\n        return new HTMLTemplateElement(node);\n    }\n    HTMLElement.call(this, node);\n  }\n  HTMLUnknownElement.prototype = Object.create(HTMLElement.prototype);\n  registerWrapper(OriginalHTMLUnknownElement, HTMLUnknownElement);\n  scope.wrappers.HTMLUnknownElement = HTMLUnknownElement;\n})(window.ShadowDOMPolyfill);\n","// Copyright 2014 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var Element = scope.wrappers.Element;\n  var HTMLElement = scope.wrappers.HTMLElement;\n  var registerObject = scope.registerObject;\n\n  var SVG_NS = 'http://www.w3.org/2000/svg';\n  var svgTitleElement = document.createElementNS(SVG_NS, 'title');\n  var SVGTitleElement = registerObject(svgTitleElement);\n  var SVGElement = Object.getPrototypeOf(SVGTitleElement.prototype).constructor;\n\n  // IE11 does not have classList for SVG elements. The spec says that classList\n  // is an accessor on Element, but IE11 puts classList on HTMLElement, leaving\n  // SVGElement without a classList property. We therefore move the accessor for\n  // IE11.\n  if (!('classList' in svgTitleElement)) {\n    var descr = Object.getOwnPropertyDescriptor(Element.prototype, 'classList');\n    Object.defineProperty(HTMLElement.prototype, 'classList', descr);\n    delete Element.prototype.classList;\n  }\n\n  scope.wrappers.SVGElement = SVGElement;\n})(window.ShadowDOMPolyfill);\n","// Copyright 2014 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var mixin = scope.mixin;\n  var registerWrapper = scope.registerWrapper;\n  var unwrap = scope.unwrap;\n  var wrap = scope.wrap;\n\n  var OriginalSVGUseElement = window.SVGUseElement;\n\n  // IE uses SVGElement as parent interface, SVG2 (Blink & Gecko) uses\n  // SVGGraphicsElement. Use the <g> element to get the right prototype.\n\n  var SVG_NS = 'http://www.w3.org/2000/svg';\n  var gWrapper = wrap(document.createElementNS(SVG_NS, 'g'));\n  var useElement = document.createElementNS(SVG_NS, 'use');\n  var SVGGElement = gWrapper.constructor;\n  var parentInterfacePrototype = Object.getPrototypeOf(SVGGElement.prototype);\n  var parentInterface = parentInterfacePrototype.constructor;\n\n  function SVGUseElement(impl) {\n    parentInterface.call(this, impl);\n  }\n\n  SVGUseElement.prototype = Object.create(parentInterfacePrototype);\n\n  // Firefox does not expose instanceRoot.\n  if ('instanceRoot' in useElement) {\n    mixin(SVGUseElement.prototype, {\n      get instanceRoot() {\n        return wrap(unwrap(this).instanceRoot);\n      },\n      get animatedInstanceRoot() {\n        return wrap(unwrap(this).animatedInstanceRoot);\n      },\n    });\n  }\n\n  registerWrapper(OriginalSVGUseElement, SVGUseElement, useElement);\n\n  scope.wrappers.SVGUseElement = SVGUseElement;\n})(window.ShadowDOMPolyfill);\n","// Copyright 2014 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var EventTarget = scope.wrappers.EventTarget;\n  var mixin = scope.mixin;\n  var registerWrapper = scope.registerWrapper;\n  var unsafeUnwrap = scope.unsafeUnwrap;\n  var wrap = scope.wrap;\n\n  var OriginalSVGElementInstance = window.SVGElementInstance;\n  if (!OriginalSVGElementInstance)\n    return;\n\n  function SVGElementInstance(impl) {\n    EventTarget.call(this, impl);\n  }\n\n  SVGElementInstance.prototype = Object.create(EventTarget.prototype);\n  mixin(SVGElementInstance.prototype, {\n    /** @type {SVGElement} */\n    get correspondingElement() {\n      return wrap(unsafeUnwrap(this).correspondingElement);\n    },\n\n    /** @type {SVGUseElement} */\n    get correspondingUseElement() {\n      return wrap(unsafeUnwrap(this).correspondingUseElement);\n    },\n\n    /** @type {SVGElementInstance} */\n    get parentNode() {\n      return wrap(unsafeUnwrap(this).parentNode);\n    },\n\n    /** @type {SVGElementInstanceList} */\n    get childNodes() {\n      throw new Error('Not implemented');\n    },\n\n    /** @type {SVGElementInstance} */\n    get firstChild() {\n      return wrap(unsafeUnwrap(this).firstChild);\n    },\n\n    /** @type {SVGElementInstance} */\n    get lastChild() {\n      return wrap(unsafeUnwrap(this).lastChild);\n    },\n\n    /** @type {SVGElementInstance} */\n    get previousSibling() {\n      return wrap(unsafeUnwrap(this).previousSibling);\n    },\n\n    /** @type {SVGElementInstance} */\n    get nextSibling() {\n      return wrap(unsafeUnwrap(this).nextSibling);\n    }\n  });\n\n  registerWrapper(OriginalSVGElementInstance, SVGElementInstance);\n\n  scope.wrappers.SVGElementInstance = SVGElementInstance;\n})(window.ShadowDOMPolyfill);\n","// Copyright 2013 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var mixin = scope.mixin;\n  var registerWrapper = scope.registerWrapper;\n  var setWrapper = scope.setWrapper;\n  var unsafeUnwrap = scope.unsafeUnwrap;\n  var unwrap = scope.unwrap;\n  var unwrapIfNeeded = scope.unwrapIfNeeded;\n  var wrap = scope.wrap;\n\n  var OriginalCanvasRenderingContext2D = window.CanvasRenderingContext2D;\n\n  function CanvasRenderingContext2D(impl) {\n    setWrapper(impl, this);\n  }\n\n  mixin(CanvasRenderingContext2D.prototype, {\n    get canvas() {\n      return wrap(unsafeUnwrap(this).canvas);\n    },\n\n    drawImage: function() {\n      arguments[0] = unwrapIfNeeded(arguments[0]);\n      unsafeUnwrap(this).drawImage.apply(unsafeUnwrap(this), arguments);\n    },\n\n    createPattern: function() {\n      arguments[0] = unwrap(arguments[0]);\n      return unsafeUnwrap(this).createPattern.apply(unsafeUnwrap(this), arguments);\n    }\n  });\n\n  registerWrapper(OriginalCanvasRenderingContext2D, CanvasRenderingContext2D,\n                  document.createElement('canvas').getContext('2d'));\n\n  scope.wrappers.CanvasRenderingContext2D = CanvasRenderingContext2D;\n})(window.ShadowDOMPolyfill);\n","// Copyright 2013 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var mixin = scope.mixin;\n  var registerWrapper = scope.registerWrapper;\n  var setWrapper = scope.setWrapper;\n  var unsafeUnwrap = scope.unsafeUnwrap;\n  var unwrapIfNeeded = scope.unwrapIfNeeded;\n  var wrap = scope.wrap;\n\n  var OriginalWebGLRenderingContext = window.WebGLRenderingContext;\n\n  // IE10 does not have WebGL.\n  if (!OriginalWebGLRenderingContext)\n    return;\n\n  function WebGLRenderingContext(impl) {\n    setWrapper(impl, this);\n  }\n\n  mixin(WebGLRenderingContext.prototype, {\n    get canvas() {\n      return wrap(unsafeUnwrap(this).canvas);\n    },\n\n    texImage2D: function() {\n      arguments[5] = unwrapIfNeeded(arguments[5]);\n      unsafeUnwrap(this).texImage2D.apply(unsafeUnwrap(this), arguments);\n    },\n\n    texSubImage2D: function() {\n      arguments[6] = unwrapIfNeeded(arguments[6]);\n      unsafeUnwrap(this).texSubImage2D.apply(unsafeUnwrap(this), arguments);\n    }\n  });\n\n  // Blink/WebKit has broken DOM bindings. Usually we would create an instance\n  // of the object and pass it into registerWrapper as a \"blueprint\" but\n  // creating WebGL contexts is expensive and might fail so we use a dummy\n  // object with dummy instance properties for these broken browsers.\n  var instanceProperties = /WebKit/.test(navigator.userAgent) ?\n      {drawingBufferHeight: null, drawingBufferWidth: null} : {};\n\n  registerWrapper(OriginalWebGLRenderingContext, WebGLRenderingContext,\n      instanceProperties);\n\n  scope.wrappers.WebGLRenderingContext = WebGLRenderingContext;\n})(window.ShadowDOMPolyfill);\n","// Copyright 2013 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var registerWrapper = scope.registerWrapper;\n  var setWrapper = scope.setWrapper;\n  var unsafeUnwrap = scope.unsafeUnwrap;\n  var unwrap = scope.unwrap;\n  var unwrapIfNeeded = scope.unwrapIfNeeded;\n  var wrap = scope.wrap;\n\n  var OriginalRange = window.Range;\n\n  function Range(impl) {\n    setWrapper(impl, this);\n  }\n  Range.prototype = {\n    get startContainer() {\n      return wrap(unsafeUnwrap(this).startContainer);\n    },\n    get endContainer() {\n      return wrap(unsafeUnwrap(this).endContainer);\n    },\n    get commonAncestorContainer() {\n      return wrap(unsafeUnwrap(this).commonAncestorContainer);\n    },\n    setStart: function(refNode,offset) {\n      unsafeUnwrap(this).setStart(unwrapIfNeeded(refNode), offset);\n    },\n    setEnd: function(refNode,offset) {\n      unsafeUnwrap(this).setEnd(unwrapIfNeeded(refNode), offset);\n    },\n    setStartBefore: function(refNode) {\n      unsafeUnwrap(this).setStartBefore(unwrapIfNeeded(refNode));\n    },\n    setStartAfter: function(refNode) {\n      unsafeUnwrap(this).setStartAfter(unwrapIfNeeded(refNode));\n    },\n    setEndBefore: function(refNode) {\n      unsafeUnwrap(this).setEndBefore(unwrapIfNeeded(refNode));\n    },\n    setEndAfter: function(refNode) {\n      unsafeUnwrap(this).setEndAfter(unwrapIfNeeded(refNode));\n    },\n    selectNode: function(refNode) {\n      unsafeUnwrap(this).selectNode(unwrapIfNeeded(refNode));\n    },\n    selectNodeContents: function(refNode) {\n      unsafeUnwrap(this).selectNodeContents(unwrapIfNeeded(refNode));\n    },\n    compareBoundaryPoints: function(how, sourceRange) {\n      return unsafeUnwrap(this).compareBoundaryPoints(how, unwrap(sourceRange));\n    },\n    extractContents: function() {\n      return wrap(unsafeUnwrap(this).extractContents());\n    },\n    cloneContents: function() {\n      return wrap(unsafeUnwrap(this).cloneContents());\n    },\n    insertNode: function(node) {\n      unsafeUnwrap(this).insertNode(unwrapIfNeeded(node));\n    },\n    surroundContents: function(newParent) {\n      unsafeUnwrap(this).surroundContents(unwrapIfNeeded(newParent));\n    },\n    cloneRange: function() {\n      return wrap(unsafeUnwrap(this).cloneRange());\n    },\n    isPointInRange: function(node, offset) {\n      return unsafeUnwrap(this).isPointInRange(unwrapIfNeeded(node), offset);\n    },\n    comparePoint: function(node, offset) {\n      return unsafeUnwrap(this).comparePoint(unwrapIfNeeded(node), offset);\n    },\n    intersectsNode: function(node) {\n      return unsafeUnwrap(this).intersectsNode(unwrapIfNeeded(node));\n    },\n    toString: function() {\n      return unsafeUnwrap(this).toString();\n    }\n  };\n\n  // IE9 does not have createContextualFragment.\n  if (OriginalRange.prototype.createContextualFragment) {\n    Range.prototype.createContextualFragment = function(html) {\n      return wrap(unsafeUnwrap(this).createContextualFragment(html));\n    };\n  }\n\n  registerWrapper(window.Range, Range, document.createRange());\n\n  scope.wrappers.Range = Range;\n\n})(window.ShadowDOMPolyfill);\n","// Copyright 2013 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var GetElementsByInterface = scope.GetElementsByInterface;\n  var ParentNodeInterface = scope.ParentNodeInterface;\n  var SelectorsInterface = scope.SelectorsInterface;\n  var mixin = scope.mixin;\n  var registerObject = scope.registerObject;\n\n  var DocumentFragment = registerObject(document.createDocumentFragment());\n  mixin(DocumentFragment.prototype, ParentNodeInterface);\n  mixin(DocumentFragment.prototype, SelectorsInterface);\n  mixin(DocumentFragment.prototype, GetElementsByInterface);\n\n  var Comment = registerObject(document.createComment(''));\n\n  scope.wrappers.Comment = Comment;\n  scope.wrappers.DocumentFragment = DocumentFragment;\n\n})(window.ShadowDOMPolyfill);\n","// Copyright 2013 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var DocumentFragment = scope.wrappers.DocumentFragment;\n  var TreeScope = scope.TreeScope;\n  var elementFromPoint = scope.elementFromPoint;\n  var getInnerHTML = scope.getInnerHTML;\n  var getTreeScope = scope.getTreeScope;\n  var mixin = scope.mixin;\n  var rewrap = scope.rewrap;\n  var setInnerHTML = scope.setInnerHTML;\n  var unsafeUnwrap = scope.unsafeUnwrap;\n  var unwrap = scope.unwrap;\n\n  var shadowHostTable = new WeakMap();\n  var nextOlderShadowTreeTable = new WeakMap();\n\n  var spaceCharRe = /[ \\t\\n\\r\\f]/;\n\n  function ShadowRoot(hostWrapper) {\n    var node = unwrap(unsafeUnwrap(hostWrapper).ownerDocument.createDocumentFragment());\n    DocumentFragment.call(this, node);\n\n    // createDocumentFragment associates the node with a wrapper\n    // DocumentFragment instance. Override that.\n    rewrap(node, this);\n\n    var oldShadowRoot = hostWrapper.shadowRoot;\n    nextOlderShadowTreeTable.set(this, oldShadowRoot);\n\n    this.treeScope_ =\n        new TreeScope(this, getTreeScope(oldShadowRoot || hostWrapper));\n\n    shadowHostTable.set(this, hostWrapper);\n  }\n  ShadowRoot.prototype = Object.create(DocumentFragment.prototype);\n  mixin(ShadowRoot.prototype, {\n    constructor: ShadowRoot,\n\n    get innerHTML() {\n      return getInnerHTML(this);\n    },\n    set innerHTML(value) {\n      setInnerHTML(this, value);\n      this.invalidateShadowRenderer();\n    },\n\n    get olderShadowRoot() {\n      return nextOlderShadowTreeTable.get(this) || null;\n    },\n\n    get host() {\n      return shadowHostTable.get(this) || null;\n    },\n\n    invalidateShadowRenderer: function() {\n      return shadowHostTable.get(this).invalidateShadowRenderer();\n    },\n\n    elementFromPoint: function(x, y) {\n      return elementFromPoint(this, this.ownerDocument, x, y);\n    },\n\n    getElementById: function(id) {\n      if (spaceCharRe.test(id))\n        return null;\n      return this.querySelector('[id=\"' + id + '\"]');\n    }\n  });\n\n  scope.wrappers.ShadowRoot = ShadowRoot;\n\n})(window.ShadowDOMPolyfill);\n","// Copyright 2013 The Polymer Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var Element = scope.wrappers.Element;\n  var HTMLContentElement = scope.wrappers.HTMLContentElement;\n  var HTMLShadowElement = scope.wrappers.HTMLShadowElement;\n  var Node = scope.wrappers.Node;\n  var ShadowRoot = scope.wrappers.ShadowRoot;\n  var assert = scope.assert;\n  var getTreeScope = scope.getTreeScope;\n  var mixin = scope.mixin;\n  var oneOf = scope.oneOf;\n  var unsafeUnwrap = scope.unsafeUnwrap;\n  var unwrap = scope.unwrap;\n  var wrap = scope.wrap;\n\n  /**\n   * Updates the fields of a wrapper to a snapshot of the logical DOM as needed.\n   * Up means parentNode\n   * Sideways means previous and next sibling.\n   * @param {!Node} wrapper\n   */\n  function updateWrapperUpAndSideways(wrapper) {\n    wrapper.previousSibling_ = wrapper.previousSibling;\n    wrapper.nextSibling_ = wrapper.nextSibling;\n    wrapper.parentNode_ = wrapper.parentNode;\n  }\n\n  /**\n   * Updates the fields of a wrapper to a snapshot of the logical DOM as needed.\n   * Down means first and last child\n   * @param {!Node} wrapper\n   */\n  function updateWrapperDown(wrapper) {\n    wrapper.firstChild_ = wrapper.firstChild;\n    wrapper.lastChild_ = wrapper.lastChild;\n  }\n\n  function updateAllChildNodes(parentNodeWrapper) {\n    assert(parentNodeWrapper instanceof Node);\n    for (var childWrapper = parentNodeWrapper.firstChild;\n         childWrapper;\n         childWrapper = childWrapper.nextSibling) {\n      updateWrapperUpAndSideways(childWrapper);\n    }\n    updateWrapperDown(parentNodeWrapper);\n  }\n\n  function insertBefore(parentNodeWrapper, newChildWrapper, refChildWrapper) {\n    var parentNode = unwrap(parentNodeWrapper);\n    var newChild = unwrap(newChildWrapper);\n    var refChild = refChildWrapper ? unwrap(refChildWrapper) : null;\n\n    remove(newChildWrapper);\n    updateWrapperUpAndSideways(newChildWrapper);\n\n    if (!refChildWrapper) {\n      parentNodeWrapper.lastChild_ = parentNodeWrapper.lastChild;\n      if (parentNodeWrapper.lastChild === parentNodeWrapper.firstChild)\n        parentNodeWrapper.firstChild_ = parentNodeWrapper.firstChild;\n\n      var lastChildWrapper = wrap(parentNode.lastChild);\n      if (lastChildWrapper)\n        lastChildWrapper.nextSibling_ = lastChildWrapper.nextSibling;\n    } else {\n      if (parentNodeWrapper.firstChild === refChildWrapper)\n        parentNodeWrapper.firstChild_ = refChildWrapper;\n\n      refChildWrapper.previousSibling_ = refChildWrapper.previousSibling;\n    }\n\n    parentNode.insertBefore(newChild, refChild);\n  }\n\n  function remove(nodeWrapper) {\n    var node = unwrap(nodeWrapper)\n    var parentNode = node.parentNode;\n    if (!parentNode)\n      return;\n\n    var parentNodeWrapper = wrap(parentNode);\n    updateWrapperUpAndSideways(nodeWrapper);\n\n    if (nodeWrapper.previousSibling)\n      nodeWrapper.previousSibling.nextSibling_ = nodeWrapper;\n    if (nodeWrapper.nextSibling)\n      nodeWrapper.nextSibling.previousSibling_ = nodeWrapper;\n\n    if (parentNodeWrapper.lastChild === nodeWrapper)\n      parentNodeWrapper.lastChild_ = nodeWrapper;\n    if (parentNodeWrapper.firstChild === nodeWrapper)\n      parentNodeWrapper.firstChild_ = nodeWrapper;\n\n    parentNode.removeChild(node);\n  }\n\n  var distributedNodesTable = new WeakMap();\n  var destinationInsertionPointsTable = new WeakMap();\n  var rendererForHostTable = new WeakMap();\n\n  function resetDistributedNodes(insertionPoint) {\n    distributedNodesTable.set(insertionPoint, []);\n  }\n\n  function getDistributedNodes(insertionPoint) {\n    var rv = distributedNodesTable.get(insertionPoint);\n    if (!rv)\n      distributedNodesTable.set(insertionPoint, rv = []);\n    return rv;\n  }\n\n  function getChildNodesSnapshot(node) {\n    var result = [], i = 0;\n    for (var child = node.firstChild; child; child = child.nextSibling) {\n      result[i++] = child;\n    }\n    return result;\n  }\n\n  var request = oneOf(window, [\n    'requestAnimationFrame',\n    'mozRequestAnimationFrame',\n    'webkitRequestAnimationFrame',\n    'setTimeout'\n  ]);\n\n  var pendingDirtyRenderers = [];\n  var renderTimer;\n\n  function renderAllPending() {\n    // TODO(arv): Order these in document order. That way we do not have to\n    // render something twice.\n    for (var i = 0; i < pendingDirtyRenderers.length; i++) {\n      var renderer = pendingDirtyRenderers[i];\n      var parentRenderer = renderer.parentRenderer;\n      if (parentRenderer && parentRenderer.dirty)\n        continue;\n      renderer.render();\n    }\n\n    pendingDirtyRenderers = [];\n  }\n\n  function handleRequestAnimationFrame() {\n    renderTimer = null;\n    renderAllPending();\n  }\n\n  /**\n   * Returns existing shadow renderer for a host or creates it if it is needed.\n   * @params {!Element} host\n   * @return {!ShadowRenderer}\n   */\n  function getRendererForHost(host) {\n    var renderer = rendererForHostTable.get(host);\n    if (!renderer) {\n      renderer = new ShadowRenderer(host);\n      rendererForHostTable.set(host, renderer);\n    }\n    return renderer;\n  }\n\n  function getShadowRootAncestor(node) {\n    var root = getTreeScope(node).root;\n    if (root instanceof ShadowRoot)\n      return root;\n    return null;\n  }\n\n  function getRendererForShadowRoot(shadowRoot) {\n    return getRendererForHost(shadowRoot.host);\n  }\n\n  var spliceDiff = new ArraySplice();\n  spliceDiff.equals = function(renderNode, rawNode) {\n    return unwrap(renderNode.node) === rawNode;\n  };\n\n  /**\n   * RenderNode is used as an in memory \"render tree\". When we render the\n   * composed tree we create a tree of RenderNodes, then we diff this against\n   * the real DOM tree and make minimal changes as needed.\n   */\n  function RenderNode(node) {\n    this.skip = false;\n    this.node = node;\n    this.childNodes = [];\n  }\n\n  RenderNode.prototype = {\n    append: function(node) {\n      var rv = new RenderNode(node);\n      this.childNodes.push(rv);\n      return rv;\n    },\n\n    sync: function(opt_added) {\n      if (this.skip)\n        return;\n\n      var nodeWrapper = this.node;\n      // plain array of RenderNodes\n      var newChildren = this.childNodes;\n      // plain array of real nodes.\n      var oldChildren = getChildNodesSnapshot(unwrap(nodeWrapper));\n      var added = opt_added || new WeakMap();\n\n      var splices = spliceDiff.calculateSplices(newChildren, oldChildren);\n\n      var newIndex = 0, oldIndex = 0;\n      var lastIndex = 0;\n      for (var i = 0; i < splices.length; i++) {\n        var splice = splices[i];\n        for (; lastIndex < splice.index; lastIndex++) {\n          oldIndex++;\n          newChildren[newIndex++].sync(added);\n        }\n\n        var removedCount = splice.removed.length;\n        for (var j = 0; j < removedCount; j++) {\n          var wrapper = wrap(oldChildren[oldIndex++]);\n          if (!added.get(wrapper))\n            remove(wrapper);\n        }\n\n        var addedCount = splice.addedCount;\n        var refNode = oldChildren[oldIndex] && wrap(oldChildren[oldIndex]);\n        for (var j = 0; j < addedCount; j++) {\n          var newChildRenderNode = newChildren[newIndex++];\n          var newChildWrapper = newChildRenderNode.node;\n          insertBefore(nodeWrapper, newChildWrapper, refNode);\n\n          // Keep track of added so that we do not remove the node after it\n          // has been added.\n          added.set(newChildWrapper, true);\n\n          newChildRenderNode.sync(added);\n        }\n\n        lastIndex += addedCount;\n      }\n\n      for (var i = lastIndex; i < newChildren.length; i++) {\n        newChildren[i].sync(added);\n      }\n    }\n  };\n\n  function ShadowRenderer(host) {\n    this.host = host;\n    this.dirty = false;\n    this.invalidateAttributes();\n    this.associateNode(host);\n  }\n\n  ShadowRenderer.prototype = {\n\n    // http://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#rendering-shadow-trees\n    render: function(opt_renderNode) {\n      if (!this.dirty)\n        return;\n\n      this.invalidateAttributes();\n\n      var host = this.host;\n\n      this.distribution(host);\n      var renderNode = opt_renderNode || new RenderNode(host);\n      this.buildRenderTree(renderNode, host);\n\n      var topMostRenderer = !opt_renderNode;\n      if (topMostRenderer)\n        renderNode.sync();\n\n      this.dirty = false;\n    },\n\n    get parentRenderer() {\n      return getTreeScope(this.host).renderer;\n    },\n\n    invalidate: function() {\n      if (!this.dirty) {\n        this.dirty = true;\n        var parentRenderer = this.parentRenderer;\n        if (parentRenderer)\n          parentRenderer.invalidate();\n        pendingDirtyRenderers.push(this);\n        if (renderTimer)\n          return;\n        renderTimer = window[request](handleRequestAnimationFrame, 0);\n      }\n    },\n\n    // http://w3c.github.io/webcomponents/spec/shadow/#distribution-algorithms\n    distribution: function(root) {\n      this.resetAll(root);\n      this.distributionResolution(root);\n    },\n\n    resetAll: function(node) {\n      if (isInsertionPoint(node))\n        resetDistributedNodes(node);\n      else\n        resetDestinationInsertionPoints(node);\n\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        this.resetAll(child);\n      }\n\n      if (node.shadowRoot)\n        this.resetAll(node.shadowRoot);\n\n      if (node.olderShadowRoot)\n        this.resetAll(node.olderShadowRoot);\n    },\n\n    // http://w3c.github.io/webcomponents/spec/shadow/#distribution-results\n    distributionResolution: function(node) {\n      if (isShadowHost(node)) {\n        var shadowHost = node;\n        // 1.1\n        var pool = poolPopulation(shadowHost);\n\n        var shadowTrees = getShadowTrees(shadowHost);\n\n        // 1.2\n        for (var i = 0; i < shadowTrees.length; i++) {\n          // 1.2.1\n          this.poolDistribution(shadowTrees[i], pool);\n        }\n\n        // 1.3\n        for (var i = shadowTrees.length - 1; i >= 0; i--) {\n          var shadowTree = shadowTrees[i];\n\n          // 1.3.1\n          // TODO(arv): We should keep the shadow insertion points on the\n          // shadow root (or renderer) so we don't have to search the tree\n          // every time.\n          var shadow = getShadowInsertionPoint(shadowTree);\n\n          // 1.3.2\n          if (shadow) {\n\n            // 1.3.2.1\n            var olderShadowRoot = shadowTree.olderShadowRoot;\n            if (olderShadowRoot) {\n              // 1.3.2.1.1\n              pool = poolPopulation(olderShadowRoot);\n            }\n\n            // 1.3.2.2\n            for (var j = 0; j < pool.length; j++) {\n              // 1.3.2.2.1\n              destributeNodeInto(pool[j], shadow);\n            }\n          }\n\n          // 1.3.3\n          this.distributionResolution(shadowTree);\n        }\n      }\n\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        this.distributionResolution(child);\n      }\n    },\n\n    // http://w3c.github.io/webcomponents/spec/shadow/#dfn-pool-distribution-algorithm\n    poolDistribution: function (node, pool) {\n      if (node instanceof HTMLShadowElement)\n        return;\n\n      if (node instanceof HTMLContentElement) {\n        var content = node;\n        this.updateDependentAttributes(content.getAttribute('select'));\n\n        var anyDistributed = false;\n\n        // 1.1\n        for (var i = 0; i < pool.length; i++) {\n          var node = pool[i];\n          if (!node)\n            continue;\n          if (matches(node, content)) {\n            destributeNodeInto(node, content);\n            pool[i] = undefined;\n            anyDistributed = true;\n          }\n        }\n\n        // 1.2\n        // Fallback content\n        if (!anyDistributed) {\n          for (var child = content.firstChild;\n               child;\n               child = child.nextSibling) {\n            destributeNodeInto(child, content);\n          }\n        }\n\n        return;\n      }\n\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        this.poolDistribution(child, pool);\n      }\n    },\n\n    buildRenderTree: function(renderNode, node) {\n      var children = this.compose(node);\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        var childRenderNode = renderNode.append(child);\n        this.buildRenderTree(childRenderNode, child);\n      }\n\n      if (isShadowHost(node)) {\n        var renderer = getRendererForHost(node);\n        renderer.dirty = false;\n      }\n\n    },\n\n    compose: function(node) {\n      var children = [];\n      var p = node.shadowRoot || node;\n      for (var child = p.firstChild; child; child = child.nextSibling) {\n        if (isInsertionPoint(child)) {\n          this.associateNode(p);\n          var distributedNodes = getDistributedNodes(child);\n          for (var j = 0; j < distributedNodes.length; j++) {\n            var distributedNode = distributedNodes[j];\n            if (isFinalDestination(child, distributedNode))\n              children.push(distributedNode);\n          }\n        } else {\n          children.push(child);\n        }\n      }\n      return children;\n    },\n\n    /**\n     * Invalidates the attributes used to keep track of which attributes may\n     * cause the renderer to be invalidated.\n     */\n    invalidateAttributes: function() {\n      this.attributes = Object.create(null);\n    },\n\n    /**\n     * Parses the selector and makes this renderer dependent on the attribute\n     * being used in the selector.\n     * @param {string} selector\n     */\n    updateDependentAttributes: function(selector) {\n      if (!selector)\n        return;\n\n      var attributes = this.attributes;\n\n      // .class\n      if (/\\.\\w+/.test(selector))\n        attributes['class'] = true;\n\n      // #id\n      if (/#\\w+/.test(selector))\n        attributes['id'] = true;\n\n      selector.replace(/\\[\\s*([^\\s=\\|~\\]]+)/g, function(_, name) {\n        attributes[name] = true;\n      });\n\n      // Pseudo selectors have been removed from the spec.\n    },\n\n    dependsOnAttribute: function(name) {\n      return this.attributes[name];\n    },\n\n    associateNode: function(node) {\n      unsafeUnwrap(node).polymerShadowRenderer_ = this;\n    }\n  };\n\n  // http://w3c.github.io/webcomponents/spec/shadow/#dfn-pool-population-algorithm\n  function poolPopulation(node) {\n    var pool = [];\n    for (var child = node.firstChild; child; child = child.nextSibling) {\n      if (isInsertionPoint(child)) {\n        pool.push.apply(pool, getDistributedNodes(child));\n      } else {\n        pool.push(child);\n      }\n    }\n    return pool;\n  }\n\n  function getShadowInsertionPoint(node) {\n    if (node instanceof HTMLShadowElement)\n      return node;\n    if (node instanceof HTMLContentElement)\n      return null;\n    for (var child = node.firstChild; child; child = child.nextSibling) {\n      var res = getShadowInsertionPoint(child);\n      if (res)\n        return res;\n    }\n    return null;\n  }\n\n  function destributeNodeInto(child, insertionPoint) {\n    getDistributedNodes(insertionPoint).push(child);\n    var points = destinationInsertionPointsTable.get(child);\n    if (!points)\n      destinationInsertionPointsTable.set(child, [insertionPoint]);\n    else\n      points.push(insertionPoint);\n  }\n\n  function getDestinationInsertionPoints(node) {\n    return destinationInsertionPointsTable.get(node);\n  }\n\n  function resetDestinationInsertionPoints(node) {\n    // IE11 crashes when delete is used.\n    destinationInsertionPointsTable.set(node, undefined);\n  }\n\n  // AllowedSelectors :\n  //   TypeSelector\n  //   *\n  //   ClassSelector\n  //   IDSelector\n  //   AttributeSelector\n  //   negation\n  var selectorStartCharRe = /^(:not\\()?[*.#[a-zA-Z_|]/;\n\n  function matches(node, contentElement) {\n    var select = contentElement.getAttribute('select');\n    if (!select)\n      return true;\n\n    // Here we know the select attribute is a non empty string.\n    select = select.trim();\n    if (!select)\n      return true;\n\n    if (!(node instanceof Element))\n      return false;\n\n    if (!selectorStartCharRe.test(select))\n      return false;\n\n    try {\n      return node.matches(select);\n    } catch (ex) {\n      // Invalid selector.\n      return false;\n    }\n  }\n\n  function isFinalDestination(insertionPoint, node) {\n    var points = getDestinationInsertionPoints(node);\n    return points && points[points.length - 1] === insertionPoint;\n  }\n\n  function isInsertionPoint(node) {\n    return node instanceof HTMLContentElement ||\n           node instanceof HTMLShadowElement;\n  }\n\n  function isShadowHost(shadowHost) {\n    return shadowHost.shadowRoot;\n  }\n\n  // Returns the shadow trees as an array, with the youngest tree at the\n  // beginning of the array.\n  function getShadowTrees(host) {\n    var trees = [];\n\n    for (var tree = host.shadowRoot; tree; tree = tree.olderShadowRoot) {\n      trees.push(tree);\n    }\n    return trees;\n  }\n\n  function render(host) {\n    new ShadowRenderer(host).render();\n  };\n\n  // Need to rerender shadow host when:\n  //\n  // - a direct child to the ShadowRoot is added or removed\n  // - a direct child to the host is added or removed\n  // - a new shadow root is created\n  // - a direct child to a content/shadow element is added or removed\n  // - a sibling to a content/shadow element is added or removed\n  // - content[select] is changed\n  // - an attribute in a direct child to a host is modified\n\n  /**\n   * This gets called when a node was added or removed to it.\n   */\n  Node.prototype.invalidateShadowRenderer = function(force) {\n    var renderer = unsafeUnwrap(this).polymerShadowRenderer_;\n    if (renderer) {\n      renderer.invalidate();\n      return true;\n    }\n\n    return false;\n  };\n\n  HTMLContentElement.prototype.getDistributedNodes =\n  HTMLShadowElement.prototype.getDistributedNodes = function() {\n    // TODO(arv): We should only rerender the dirty ancestor renderers (from\n    // the root and down).\n    renderAllPending();\n    return getDistributedNodes(this);\n  };\n\n  Element.prototype.getDestinationInsertionPoints = function() {\n    renderAllPending();\n    return getDestinationInsertionPoints(this) || [];\n  };\n\n  HTMLContentElement.prototype.nodeIsInserted_ =\n  HTMLShadowElement.prototype.nodeIsInserted_ = function() {\n    // Invalidate old renderer if any.\n    this.invalidateShadowRenderer();\n\n    var shadowRoot = getShadowRootAncestor(this);\n    var renderer;\n    if (shadowRoot)\n      renderer = getRendererForShadowRoot(shadowRoot);\n    unsafeUnwrap(this).polymerShadowRenderer_ = renderer;\n    if (renderer)\n      renderer.invalidate();\n  };\n\n  scope.getRendererForHost = getRendererForHost;\n  scope.getShadowTrees = getShadowTrees;\n  scope.renderAllPending = renderAllPending;\n\n  scope.getDestinationInsertionPoints = getDestinationInsertionPoints;\n\n  // Exposed for testing\n  scope.visual = {\n    insertBefore: insertBefore,\n    remove: remove,\n  };\n\n})(window.ShadowDOMPolyfill);\n","// Copyright 2013 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var HTMLElement = scope.wrappers.HTMLElement;\n  var assert = scope.assert;\n  var mixin = scope.mixin;\n  var registerWrapper = scope.registerWrapper;\n  var unwrap = scope.unwrap;\n  var wrap = scope.wrap;\n\n  var elementsWithFormProperty = [\n    'HTMLButtonElement',\n    'HTMLFieldSetElement',\n    'HTMLInputElement',\n    'HTMLKeygenElement',\n    'HTMLLabelElement',\n    'HTMLLegendElement',\n    'HTMLObjectElement',\n    // HTMLOptionElement is handled in HTMLOptionElement.js\n    'HTMLOutputElement',\n    // HTMLSelectElement is handled in HTMLSelectElement.js\n    'HTMLTextAreaElement',\n  ];\n\n  function createWrapperConstructor(name) {\n    if (!window[name])\n      return;\n\n    // Ensure we are not overriding an already existing constructor.\n    assert(!scope.wrappers[name]);\n\n    var GeneratedWrapper = function(node) {\n      // At this point all of them extend HTMLElement.\n      HTMLElement.call(this, node);\n    }\n    GeneratedWrapper.prototype = Object.create(HTMLElement.prototype);\n    mixin(GeneratedWrapper.prototype, {\n      get form() {\n        return wrap(unwrap(this).form);\n      },\n    });\n\n    registerWrapper(window[name], GeneratedWrapper,\n        document.createElement(name.slice(4, -7)));\n    scope.wrappers[name] = GeneratedWrapper;\n  }\n\n  elementsWithFormProperty.forEach(createWrapperConstructor);\n\n})(window.ShadowDOMPolyfill);\n","// Copyright 2014 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var registerWrapper = scope.registerWrapper;\n  var setWrapper = scope.setWrapper;\n  var unsafeUnwrap = scope.unsafeUnwrap;\n  var unwrap = scope.unwrap;\n  var unwrapIfNeeded = scope.unwrapIfNeeded;\n  var wrap = scope.wrap;\n\n  var OriginalSelection = window.Selection;\n\n  function Selection(impl) {\n    setWrapper(impl, this);\n  }\n  Selection.prototype = {\n    get anchorNode() {\n      return wrap(unsafeUnwrap(this).anchorNode);\n    },\n    get focusNode() {\n      return wrap(unsafeUnwrap(this).focusNode);\n    },\n    addRange: function(range) {\n      unsafeUnwrap(this).addRange(unwrap(range));\n    },\n    collapse: function(node, index) {\n      unsafeUnwrap(this).collapse(unwrapIfNeeded(node), index);\n    },\n    containsNode: function(node, allowPartial) {\n      return unsafeUnwrap(this).containsNode(unwrapIfNeeded(node), allowPartial);\n    },\n    extend: function(node, offset) {\n      unsafeUnwrap(this).extend(unwrapIfNeeded(node), offset);\n    },\n    getRangeAt: function(index) {\n      return wrap(unsafeUnwrap(this).getRangeAt(index));\n    },\n    removeRange: function(range) {\n      unsafeUnwrap(this).removeRange(unwrap(range));\n    },\n    selectAllChildren: function(node) {\n      unsafeUnwrap(this).selectAllChildren(unwrapIfNeeded(node));\n    },\n    toString: function() {\n      return unsafeUnwrap(this).toString();\n    }\n  };\n\n  // WebKit extensions. Not implemented.\n  // readonly attribute Node baseNode;\n  // readonly attribute long baseOffset;\n  // readonly attribute Node extentNode;\n  // readonly attribute long extentOffset;\n  // [RaisesException] void setBaseAndExtent([Default=Undefined] optional Node baseNode,\n  //                       [Default=Undefined] optional long baseOffset,\n  //                       [Default=Undefined] optional Node extentNode,\n  //                       [Default=Undefined] optional long extentOffset);\n  // [RaisesException, ImplementedAs=collapse] void setPosition([Default=Undefined] optional Node node,\n  //                  [Default=Undefined] optional long offset);\n\n  registerWrapper(window.Selection, Selection, window.getSelection());\n\n  scope.wrappers.Selection = Selection;\n\n})(window.ShadowDOMPolyfill);\n","// Copyright 2013 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var GetElementsByInterface = scope.GetElementsByInterface;\n  var Node = scope.wrappers.Node;\n  var ParentNodeInterface = scope.ParentNodeInterface;\n  var Selection = scope.wrappers.Selection;\n  var SelectorsInterface = scope.SelectorsInterface;\n  var ShadowRoot = scope.wrappers.ShadowRoot;\n  var TreeScope = scope.TreeScope;\n  var cloneNode = scope.cloneNode;\n  var defineWrapGetter = scope.defineWrapGetter;\n  var elementFromPoint = scope.elementFromPoint;\n  var forwardMethodsToWrapper = scope.forwardMethodsToWrapper;\n  var matchesNames = scope.matchesNames;\n  var mixin = scope.mixin;\n  var registerWrapper = scope.registerWrapper;\n  var renderAllPending = scope.renderAllPending;\n  var rewrap = scope.rewrap;\n  var setWrapper = scope.setWrapper;\n  var unsafeUnwrap = scope.unsafeUnwrap;\n  var unwrap = scope.unwrap;\n  var wrap = scope.wrap;\n  var wrapEventTargetMethods = scope.wrapEventTargetMethods;\n  var wrapNodeList = scope.wrapNodeList;\n\n  var implementationTable = new WeakMap();\n\n  function Document(node) {\n    Node.call(this, node);\n    this.treeScope_ = new TreeScope(this, null);\n  }\n  Document.prototype = Object.create(Node.prototype);\n\n  defineWrapGetter(Document, 'documentElement');\n\n  // Conceptually both body and head can be in a shadow but suporting that seems\n  // overkill at this point.\n  defineWrapGetter(Document, 'body');\n  defineWrapGetter(Document, 'head');\n\n  // document cannot be overridden so we override a bunch of its methods\n  // directly on the instance.\n\n  function wrapMethod(name) {\n    var original = document[name];\n    Document.prototype[name] = function() {\n      return wrap(original.apply(unsafeUnwrap(this), arguments));\n    };\n  }\n\n  [\n    'createComment',\n    'createDocumentFragment',\n    'createElement',\n    'createElementNS',\n    'createEvent',\n    'createEventNS',\n    'createRange',\n    'createTextNode',\n    'getElementById'\n  ].forEach(wrapMethod);\n\n  var originalAdoptNode = document.adoptNode;\n\n  function adoptNodeNoRemove(node, doc) {\n    originalAdoptNode.call(unsafeUnwrap(doc), unwrap(node));\n    adoptSubtree(node, doc);\n  }\n\n  function adoptSubtree(node, doc) {\n    if (node.shadowRoot)\n      doc.adoptNode(node.shadowRoot);\n    if (node instanceof ShadowRoot)\n      adoptOlderShadowRoots(node, doc);\n    for (var child = node.firstChild; child; child = child.nextSibling) {\n      adoptSubtree(child, doc);\n    }\n  }\n\n  function adoptOlderShadowRoots(shadowRoot, doc) {\n    var oldShadowRoot = shadowRoot.olderShadowRoot;\n    if (oldShadowRoot)\n      doc.adoptNode(oldShadowRoot);\n  }\n\n  var originalGetSelection = document.getSelection;\n\n  mixin(Document.prototype, {\n    adoptNode: function(node) {\n      if (node.parentNode)\n        node.parentNode.removeChild(node);\n      adoptNodeNoRemove(node, this);\n      return node;\n    },\n    elementFromPoint: function(x, y) {\n      return elementFromPoint(this, this, x, y);\n    },\n    importNode: function(node, deep) {\n      return cloneNode(node, deep, unsafeUnwrap(this));\n    },\n    getSelection: function() {\n      renderAllPending();\n      return new Selection(originalGetSelection.call(unwrap(this)));\n    },\n    getElementsByName: function(name) {\n      return SelectorsInterface.querySelectorAll.call(this,\n          '[name=' + JSON.stringify(String(name)) + ']');\n    }\n  });\n\n  if (document.registerElement) {\n    var originalRegisterElement = document.registerElement;\n    Document.prototype.registerElement = function(tagName, object) {\n      var prototype, extendsOption;\n      if (object !== undefined) {\n        prototype = object.prototype;\n        extendsOption = object.extends;\n      }\n\n      if (!prototype)\n        prototype = Object.create(HTMLElement.prototype);\n\n\n      // If we already used the object as a prototype for another custom\n      // element.\n      if (scope.nativePrototypeTable.get(prototype)) {\n        // TODO(arv): DOMException\n        throw new Error('NotSupportedError');\n      }\n\n      // Find first object on the prototype chain that already have a native\n      // prototype. Keep track of all the objects before that so we can create\n      // a similar structure for the native case.\n      var proto = Object.getPrototypeOf(prototype);\n      var nativePrototype;\n      var prototypes = [];\n      while (proto) {\n        nativePrototype = scope.nativePrototypeTable.get(proto);\n        if (nativePrototype)\n          break;\n        prototypes.push(proto);\n        proto = Object.getPrototypeOf(proto);\n      }\n\n      if (!nativePrototype) {\n        // TODO(arv): DOMException\n        throw new Error('NotSupportedError');\n      }\n\n      // This works by creating a new prototype object that is empty, but has\n      // the native prototype as its proto. The original prototype object\n      // passed into register is used as the wrapper prototype.\n\n      var newPrototype = Object.create(nativePrototype);\n      for (var i = prototypes.length - 1; i >= 0; i--) {\n        newPrototype = Object.create(newPrototype);\n      }\n\n      // Add callbacks if present.\n      // Names are taken from:\n      //   https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/bindings/v8/CustomElementConstructorBuilder.cpp&sq=package:chromium&type=cs&l=156\n      // and not from the spec since the spec is out of date.\n      [\n        'createdCallback',\n        'attachedCallback',\n        'detachedCallback',\n        'attributeChangedCallback',\n      ].forEach(function(name) {\n        var f = prototype[name];\n        if (!f)\n          return;\n        newPrototype[name] = function() {\n          // if this element has been wrapped prior to registration,\n          // the wrapper is stale; in this case rewrap\n          if (!(wrap(this) instanceof CustomElementConstructor)) {\n            rewrap(this);\n          }\n          f.apply(wrap(this), arguments);\n        };\n      });\n\n      var p = {prototype: newPrototype};\n      if (extendsOption)\n        p.extends = extendsOption;\n\n      function CustomElementConstructor(node) {\n        if (!node) {\n          if (extendsOption) {\n            return document.createElement(extendsOption, tagName);\n          } else {\n            return document.createElement(tagName);\n          }\n        }\n        setWrapper(node, this);\n      }\n      CustomElementConstructor.prototype = prototype;\n      CustomElementConstructor.prototype.constructor = CustomElementConstructor;\n\n      scope.constructorTable.set(newPrototype, CustomElementConstructor);\n      scope.nativePrototypeTable.set(prototype, newPrototype);\n\n      // registration is synchronous so do it last\n      var nativeConstructor = originalRegisterElement.call(unwrap(this),\n          tagName, p);\n      return CustomElementConstructor;\n    };\n\n    forwardMethodsToWrapper([\n      window.HTMLDocument || window.Document,  // Gecko adds these to HTMLDocument\n    ], [\n      'registerElement',\n    ]);\n  }\n\n  // We also override some of the methods on document.body and document.head\n  // for convenience.\n  forwardMethodsToWrapper([\n    window.HTMLBodyElement,\n    window.HTMLDocument || window.Document,  // Gecko adds these to HTMLDocument\n    window.HTMLHeadElement,\n    window.HTMLHtmlElement,\n  ], [\n    'appendChild',\n    'compareDocumentPosition',\n    'contains',\n    'getElementsByClassName',\n    'getElementsByTagName',\n    'getElementsByTagNameNS',\n    'insertBefore',\n    'querySelector',\n    'querySelectorAll',\n    'removeChild',\n    'replaceChild',\n  ].concat(matchesNames));\n\n  forwardMethodsToWrapper([\n    window.HTMLDocument || window.Document,  // Gecko adds these to HTMLDocument\n  ], [\n    'adoptNode',\n    'importNode',\n    'contains',\n    'createComment',\n    'createDocumentFragment',\n    'createElement',\n    'createElementNS',\n    'createEvent',\n    'createEventNS',\n    'createRange',\n    'createTextNode',\n    'elementFromPoint',\n    'getElementById',\n    'getElementsByName',\n    'getSelection',\n  ]);\n\n  mixin(Document.prototype, GetElementsByInterface);\n  mixin(Document.prototype, ParentNodeInterface);\n  mixin(Document.prototype, SelectorsInterface);\n\n  mixin(Document.prototype, {\n    get implementation() {\n      var implementation = implementationTable.get(this);\n      if (implementation)\n        return implementation;\n      implementation =\n          new DOMImplementation(unwrap(this).implementation);\n      implementationTable.set(this, implementation);\n      return implementation;\n    },\n\n    get defaultView() {\n      return wrap(unwrap(this).defaultView);\n    }\n  });\n\n  registerWrapper(window.Document, Document,\n      document.implementation.createHTMLDocument(''));\n\n  // Both WebKit and Gecko uses HTMLDocument for document. HTML5/DOM only has\n  // one Document interface and IE implements the standard correctly.\n  if (window.HTMLDocument)\n    registerWrapper(window.HTMLDocument, Document);\n\n  wrapEventTargetMethods([\n    window.HTMLBodyElement,\n    window.HTMLDocument || window.Document,  // Gecko adds these to HTMLDocument\n    window.HTMLHeadElement,\n  ]);\n\n  function DOMImplementation(impl) {\n    setWrapper(impl, this);\n  }\n\n  function wrapImplMethod(constructor, name) {\n    var original = document.implementation[name];\n    constructor.prototype[name] = function() {\n      return wrap(original.apply(unsafeUnwrap(this), arguments));\n    };\n  }\n\n  function forwardImplMethod(constructor, name) {\n    var original = document.implementation[name];\n    constructor.prototype[name] = function() {\n      return original.apply(unsafeUnwrap(this), arguments);\n    };\n  }\n\n  wrapImplMethod(DOMImplementation, 'createDocumentType');\n  wrapImplMethod(DOMImplementation, 'createDocument');\n  wrapImplMethod(DOMImplementation, 'createHTMLDocument');\n  forwardImplMethod(DOMImplementation, 'hasFeature');\n\n  registerWrapper(window.DOMImplementation, DOMImplementation);\n\n  forwardMethodsToWrapper([\n    window.DOMImplementation,\n  ], [\n    'createDocumentType',\n    'createDocument',\n    'createHTMLDocument',\n    'hasFeature',\n  ]);\n\n  scope.adoptNodeNoRemove = adoptNodeNoRemove;\n  scope.wrappers.DOMImplementation = DOMImplementation;\n  scope.wrappers.Document = Document;\n\n})(window.ShadowDOMPolyfill);\n","// Copyright 2013 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var EventTarget = scope.wrappers.EventTarget;\n  var Selection = scope.wrappers.Selection;\n  var mixin = scope.mixin;\n  var registerWrapper = scope.registerWrapper;\n  var renderAllPending = scope.renderAllPending;\n  var unwrap = scope.unwrap;\n  var unwrapIfNeeded = scope.unwrapIfNeeded;\n  var wrap = scope.wrap;\n\n  var OriginalWindow = window.Window;\n  var originalGetComputedStyle = window.getComputedStyle;\n  var originalGetDefaultComputedStyle = window.getDefaultComputedStyle;\n  var originalGetSelection = window.getSelection;\n\n  function Window(impl) {\n    EventTarget.call(this, impl);\n  }\n  Window.prototype = Object.create(EventTarget.prototype);\n\n  OriginalWindow.prototype.getComputedStyle = function(el, pseudo) {\n    return wrap(this || window).getComputedStyle(unwrapIfNeeded(el), pseudo);\n  };\n\n  // Mozilla proprietary extension.\n  if (originalGetDefaultComputedStyle) {\n    OriginalWindow.prototype.getDefaultComputedStyle = function(el, pseudo) {\n      return wrap(this || window).getDefaultComputedStyle(\n          unwrapIfNeeded(el), pseudo);\n    };\n  }\n\n  OriginalWindow.prototype.getSelection = function() {\n    return wrap(this || window).getSelection();\n  };\n\n  // Work around for https://bugzilla.mozilla.org/show_bug.cgi?id=943065\n  delete window.getComputedStyle;\n  delete window.getSelection;\n\n  ['addEventListener', 'removeEventListener', 'dispatchEvent'].forEach(\n      function(name) {\n        OriginalWindow.prototype[name] = function() {\n          var w = wrap(this || window);\n          return w[name].apply(w, arguments);\n        };\n\n        // Work around for https://bugzilla.mozilla.org/show_bug.cgi?id=943065\n        delete window[name];\n      });\n\n  mixin(Window.prototype, {\n    getComputedStyle: function(el, pseudo) {\n      renderAllPending();\n      return originalGetComputedStyle.call(unwrap(this), unwrapIfNeeded(el),\n                                           pseudo);\n    },\n    getSelection: function() {\n      renderAllPending();\n      return new Selection(originalGetSelection.call(unwrap(this)));\n    },\n\n    get document() {\n      return wrap(unwrap(this).document);\n    }\n  });\n\n  // Mozilla proprietary extension.\n  if (originalGetDefaultComputedStyle) {\n    Window.prototype.getDefaultComputedStyle = function(el, pseudo) {\n      renderAllPending();\n      return originalGetDefaultComputedStyle.call(unwrap(this),\n          unwrapIfNeeded(el),pseudo);\n    };\n  }\n\n  registerWrapper(OriginalWindow, Window, window);\n\n  scope.wrappers.Window = Window;\n\n})(window.ShadowDOMPolyfill);\n","/**\n * Copyright 2014 The Polymer Authors. All rights reserved.\n * Use of this source code is goverened by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\n(function(scope) {\n  'use strict';\n\n  var unwrap = scope.unwrap;\n\n  // DataTransfer (Clipboard in old Blink/WebKit) has a single method that\n  // requires wrapping. Since it is only a method we do not need a real wrapper,\n  // we can just override the method.\n\n  var OriginalDataTransfer = window.DataTransfer || window.Clipboard;\n  var OriginalDataTransferSetDragImage =\n      OriginalDataTransfer.prototype.setDragImage;\n\n  if (OriginalDataTransferSetDragImage) {\n    OriginalDataTransfer.prototype.setDragImage = function(image, x, y) {\n      OriginalDataTransferSetDragImage.call(this, unwrap(image), x, y);\n    };\n  }\n\n})(window.ShadowDOMPolyfill);\n","/**\n * Copyright 2014 The Polymer Authors. All rights reserved.\n * Use of this source code is goverened by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\n(function(scope) {\n  'use strict';\n\n  var registerWrapper = scope.registerWrapper;\n  var setWrapper = scope.setWrapper;\n  var unwrap = scope.unwrap;\n\n  var OriginalFormData = window.FormData;\n\n  function FormData(formElement) {\n    var impl;\n    if (formElement instanceof OriginalFormData) {\n      impl = formElement;\n    } else {\n      impl = new OriginalFormData(formElement && unwrap(formElement));\n    }\n    setWrapper(impl, this);\n  }\n\n  registerWrapper(OriginalFormData, FormData, new OriginalFormData());\n\n  scope.wrappers.FormData = FormData;\n\n})(window.ShadowDOMPolyfill);\n","// Copyright 2013 The Polymer Authors. All rights reserved.\n// Use of this source code is goverened by a BSD-style\n// license that can be found in the LICENSE file.\n\n(function(scope) {\n  'use strict';\n\n  var isWrapperFor = scope.isWrapperFor;\n\n  // This is a list of the elements we currently override the global constructor\n  // for.\n  var elements = {\n    'a': 'HTMLAnchorElement',\n    // Do not create an applet element by default since it shows a warning in\n    // IE.\n    // https://github.com/Polymer/polymer/issues/217\n    // 'applet': 'HTMLAppletElement',\n    'area': 'HTMLAreaElement',\n    'audio': 'HTMLAudioElement',\n    'base': 'HTMLBaseElement',\n    'body': 'HTMLBodyElement',\n    'br': 'HTMLBRElement',\n    'button': 'HTMLButtonElement',\n    'canvas': 'HTMLCanvasElement',\n    'caption': 'HTMLTableCaptionElement',\n    'col': 'HTMLTableColElement',\n    // 'command': 'HTMLCommandElement',  // Not fully implemented in Gecko.\n    'content': 'HTMLContentElement',\n    'data': 'HTMLDataElement',\n    'datalist': 'HTMLDataListElement',\n    'del': 'HTMLModElement',\n    'dir': 'HTMLDirectoryElement',\n    'div': 'HTMLDivElement',\n    'dl': 'HTMLDListElement',\n    'embed': 'HTMLEmbedElement',\n    'fieldset': 'HTMLFieldSetElement',\n    'font': 'HTMLFontElement',\n    'form': 'HTMLFormElement',\n    'frame': 'HTMLFrameElement',\n    'frameset': 'HTMLFrameSetElement',\n    'h1': 'HTMLHeadingElement',\n    'head': 'HTMLHeadElement',\n    'hr': 'HTMLHRElement',\n    'html': 'HTMLHtmlElement',\n    'iframe': 'HTMLIFrameElement',\n    'img': 'HTMLImageElement',\n    'input': 'HTMLInputElement',\n    'keygen': 'HTMLKeygenElement',\n    'label': 'HTMLLabelElement',\n    'legend': 'HTMLLegendElement',\n    'li': 'HTMLLIElement',\n    'link': 'HTMLLinkElement',\n    'map': 'HTMLMapElement',\n    'marquee': 'HTMLMarqueeElement',\n    'menu': 'HTMLMenuElement',\n    'menuitem': 'HTMLMenuItemElement',\n    'meta': 'HTMLMetaElement',\n    'meter': 'HTMLMeterElement',\n    'object': 'HTMLObjectElement',\n    'ol': 'HTMLOListElement',\n    'optgroup': 'HTMLOptGroupElement',\n    'option': 'HTMLOptionElement',\n    'output': 'HTMLOutputElement',\n    'p': 'HTMLParagraphElement',\n    'param': 'HTMLParamElement',\n    'pre': 'HTMLPreElement',\n    'progress': 'HTMLProgressElement',\n    'q': 'HTMLQuoteElement',\n    'script': 'HTMLScriptElement',\n    'select': 'HTMLSelectElement',\n    'shadow': 'HTMLShadowElement',\n    'source': 'HTMLSourceElement',\n    'span': 'HTMLSpanElement',\n    'style': 'HTMLStyleElement',\n    'table': 'HTMLTableElement',\n    'tbody': 'HTMLTableSectionElement',\n    // WebKit and Moz are wrong:\n    // https://bugs.webkit.org/show_bug.cgi?id=111469\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=848096\n    // 'td': 'HTMLTableCellElement',\n    'template': 'HTMLTemplateElement',\n    'textarea': 'HTMLTextAreaElement',\n    'thead': 'HTMLTableSectionElement',\n    'time': 'HTMLTimeElement',\n    'title': 'HTMLTitleElement',\n    'tr': 'HTMLTableRowElement',\n    'track': 'HTMLTrackElement',\n    'ul': 'HTMLUListElement',\n    'video': 'HTMLVideoElement',\n  };\n\n  function overrideConstructor(tagName) {\n    var nativeConstructorName = elements[tagName];\n    var nativeConstructor = window[nativeConstructorName];\n    if (!nativeConstructor)\n      return;\n    var element = document.createElement(tagName);\n    var wrapperConstructor = element.constructor;\n    window[nativeConstructorName] = wrapperConstructor;\n  }\n\n  Object.keys(elements).forEach(overrideConstructor);\n\n  Object.getOwnPropertyNames(scope.wrappers).forEach(function(name) {\n    window[name] = scope.wrappers[name]\n  });\n\n})(window.ShadowDOMPolyfill);\n","/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n  // convenient global\n  window.wrap = ShadowDOMPolyfill.wrapIfNeeded;\n  window.unwrap = ShadowDOMPolyfill.unwrapIfNeeded;\n\n  // users may want to customize other types\n  // TODO(sjmiles): 'button' is now supported by ShadowDOMPolyfill, but\n  // I've left this code here in case we need to temporarily patch another\n  // type\n  /*\n  (function() {\n    var elts = {HTMLButtonElement: 'button'};\n    for (var c in elts) {\n      window[c] = function() { throw 'Patched Constructor'; };\n      window[c].prototype = Object.getPrototypeOf(\n          document.createElement(elts[c]));\n    }\n  })();\n  */\n\n  // patch in prefixed name\n  Object.defineProperty(Element.prototype, 'webkitShadowRoot',\n      Object.getOwnPropertyDescriptor(Element.prototype, 'shadowRoot'));\n\n  var originalCreateShadowRoot = Element.prototype.createShadowRoot;\n  Element.prototype.createShadowRoot = function() {\n    var root = originalCreateShadowRoot.call(this);\n    CustomElements.watchShadow(this);\n    return root;\n  };\n\n  Element.prototype.webkitCreateShadowRoot = Element.prototype.createShadowRoot;\n\n  function queryShadow(node, selector) {\n    var m, el = node.firstElementChild;\n    var shadows, sr, i;\n    shadows = [];\n    sr = node.shadowRoot;\n    while(sr) {\n      shadows.push(sr);\n      sr = sr.olderShadowRoot;\n    }\n    for(i = shadows.length - 1; i >= 0; i--) {\n      m = shadows[i].querySelector(selector);\n      if (m) {\n        return m;\n      }\n    }\n    while(el) {\n      m = queryShadow(el, selector);\n      if (m) {\n        return m;\n      }\n      el = el.nextElementSibling;\n    }\n    return null;\n  }\n\n  function queryAllShadows(node, selector, results) {\n    var el = node.firstElementChild;\n    var temp, sr, shadows, i, j;\n    shadows = [];\n    sr = node.shadowRoot;\n    while(sr) {\n      shadows.push(sr);\n      sr = sr.olderShadowRoot;\n    }\n    for (i = shadows.length - 1; i >= 0; i--) {\n      temp = shadows[i].querySelectorAll(selector);\n      for(j = 0; j < temp.length; j++) {\n        results.push(temp[j]);\n      }\n    }\n    while (el) {\n      queryAllShadows(el, selector, results);\n      el = el.nextElementSibling;\n    }\n    return results;\n  }\n\n  scope.queryAllShadows = function(node, selector, all) {\n    if (all) {\n      return queryAllShadows(node, selector, []);\n    } else {\n      return queryShadow(node, selector);\n    }\n  };\n})(window.Platform);\n","/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n/*\n  This is a limited shim for ShadowDOM css styling.\n  https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles\n  \n  The intention here is to support only the styling features which can be \n  relatively simply implemented. The goal is to allow users to avoid the \n  most obvious pitfalls and do so without compromising performance significantly. \n  For ShadowDOM styling that's not covered here, a set of best practices\n  can be provided that should allow users to accomplish more complex styling.\n\n  The following is a list of specific ShadowDOM styling features and a brief\n  discussion of the approach used to shim.\n\n  Shimmed features:\n\n  * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host\n  element using the :host rule. To shim this feature, the :host styles are \n  reformatted and prefixed with a given scope name and promoted to a \n  document level stylesheet.\n  For example, given a scope name of .foo, a rule like this:\n  \n    :host {\n        background: red;\n      }\n    }\n  \n  becomes:\n  \n    .foo {\n      background: red;\n    }\n  \n  * encapsultion: Styles defined within ShadowDOM, apply only to \n  dom inside the ShadowDOM. Polymer uses one of two techniques to imlement\n  this feature.\n  \n  By default, rules are prefixed with the host element tag name \n  as a descendant selector. This ensures styling does not leak out of the 'top'\n  of the element's ShadowDOM. For example,\n\n  div {\n      font-weight: bold;\n    }\n  \n  becomes:\n\n  x-foo div {\n      font-weight: bold;\n    }\n  \n  becomes:\n\n\n  Alternatively, if Platform.ShadowCSS.strictStyling is set to true then \n  selectors are scoped by adding an attribute selector suffix to each\n  simple selector that contains the host element tag name. Each element \n  in the element's ShadowDOM template is also given the scope attribute. \n  Thus, these rules match only elements that have the scope attribute.\n  For example, given a scope name of x-foo, a rule like this:\n  \n    div {\n      font-weight: bold;\n    }\n  \n  becomes:\n  \n    div[x-foo] {\n      font-weight: bold;\n    }\n\n  Note that elements that are dynamically added to a scope must have the scope\n  selector added to them manually.\n\n  * upper/lower bound encapsulation: Styles which are defined outside a\n  shadowRoot should not cross the ShadowDOM boundary and should not apply\n  inside a shadowRoot.\n\n  This styling behavior is not emulated. Some possible ways to do this that \n  were rejected due to complexity and/or performance concerns include: (1) reset\n  every possible property for every possible selector for a given scope name;\n  (2) re-implement css in javascript.\n  \n  As an alternative, users should make sure to use selectors\n  specific to the scope in which they are working.\n  \n  * ::distributed: This behavior is not emulated. It's often not necessary\n  to style the contents of a specific insertion point and instead, descendants\n  of the host element can be styled selectively. Users can also create an \n  extra node around an insertion point and style that node's contents\n  via descendent selectors. For example, with a shadowRoot like this:\n  \n    <style>\n      ::content(div) {\n        background: red;\n      }\n    </style>\n    <content></content>\n  \n  could become:\n  \n    <style>\n      / *@polyfill .content-container div * / \n      ::content(div) {\n        background: red;\n      }\n    </style>\n    <div class=\"content-container\">\n      <content></content>\n    </div>\n  \n  Note the use of @polyfill in the comment above a ShadowDOM specific style\n  declaration. This is a directive to the styling shim to use the selector \n  in comments in lieu of the next selector when running under polyfill.\n*/\n(function(scope) {\n\nvar ShadowCSS = {\n  strictStyling: false,\n  registry: {},\n  // Shim styles for a given root associated with a name and extendsName\n  // 1. cache root styles by name\n  // 2. optionally tag root nodes with scope name\n  // 3. shim polyfill directives /* @polyfill */ and /* @polyfill-rule */\n  // 4. shim :host and scoping\n  shimStyling: function(root, name, extendsName) {\n    var scopeStyles = this.prepareRoot(root, name, extendsName);\n    var typeExtension = this.isTypeExtension(extendsName);\n    var scopeSelector = this.makeScopeSelector(name, typeExtension);\n    // use caching to make working with styles nodes easier and to facilitate\n    // lookup of extendee\n    var cssText = stylesToCssText(scopeStyles, true);\n    cssText = this.scopeCssText(cssText, scopeSelector);\n    // cache shimmed css on root for user extensibility\n    if (root) {\n      root.shimmedStyle = cssText;\n    }\n    // add style to document\n    this.addCssToDocument(cssText, name);\n  },\n  /*\n  * Shim a style element with the given selector. Returns cssText that can\n  * be included in the document via Platform.ShadowCSS.addCssToDocument(css).\n  */\n  shimStyle: function(style, selector) {\n    return this.shimCssText(style.textContent, selector);\n  },\n  /*\n  * Shim some cssText with the given selector. Returns cssText that can\n  * be included in the document via Platform.ShadowCSS.addCssToDocument(css).\n  */\n  shimCssText: function(cssText, selector) {\n    cssText = this.insertDirectives(cssText);\n    return this.scopeCssText(cssText, selector);\n  },\n  makeScopeSelector: function(name, typeExtension) {\n    if (name) {\n      return typeExtension ? '[is=' + name + ']' : name;\n    }\n    return '';\n  },\n  isTypeExtension: function(extendsName) {\n    return extendsName && extendsName.indexOf('-') < 0;\n  },\n  prepareRoot: function(root, name, extendsName) {\n    var def = this.registerRoot(root, name, extendsName);\n    this.replaceTextInStyles(def.rootStyles, this.insertDirectives);\n    // remove existing style elements\n    this.removeStyles(root, def.rootStyles);\n    // apply strict attr\n    if (this.strictStyling) {\n      this.applyScopeToContent(root, name);\n    }\n    return def.scopeStyles;\n  },\n  removeStyles: function(root, styles) {\n    for (var i=0, l=styles.length, s; (i<l) && (s=styles[i]); i++) {\n      s.parentNode.removeChild(s);\n    }\n  },\n  registerRoot: function(root, name, extendsName) {\n    var def = this.registry[name] = {\n      root: root,\n      name: name,\n      extendsName: extendsName\n    }\n    var styles = this.findStyles(root);\n    def.rootStyles = styles;\n    def.scopeStyles = def.rootStyles;\n    var extendee = this.registry[def.extendsName];\n    if (extendee) {\n      def.scopeStyles = extendee.scopeStyles.concat(def.scopeStyles);\n    }\n    return def;\n  },\n  findStyles: function(root) {\n    if (!root) {\n      return [];\n    }\n    var styles = root.querySelectorAll('style');\n    return Array.prototype.filter.call(styles, function(s) {\n      return !s.hasAttribute(NO_SHIM_ATTRIBUTE);\n    });\n  },\n  applyScopeToContent: function(root, name) {\n    if (root) {\n      // add the name attribute to each node in root.\n      Array.prototype.forEach.call(root.querySelectorAll('*'),\n          function(node) {\n            node.setAttribute(name, '');\n          });\n      // and template contents too\n      Array.prototype.forEach.call(root.querySelectorAll('template'),\n          function(template) {\n            this.applyScopeToContent(template.content, name);\n          },\n          this);\n    }\n  },\n  insertDirectives: function(cssText) {\n    cssText = this.insertPolyfillDirectivesInCssText(cssText);\n    return this.insertPolyfillRulesInCssText(cssText);\n  },\n  /*\n   * Process styles to convert native ShadowDOM rules that will trip\n   * up the css parser; we rely on decorating the stylesheet with inert rules.\n   * \n   * For example, we convert this rule:\n   * \n   * polyfill-next-selector { content: ':host menu-item'; }\n   * ::content menu-item {\n   * \n   * to this:\n   * \n   * scopeName menu-item {\n   *\n  **/\n  insertPolyfillDirectivesInCssText: function(cssText) {\n    // TODO(sorvell): remove either content or comment\n    cssText = cssText.replace(cssCommentNextSelectorRe, function(match, p1) {\n      // remove end comment delimiter and add block start\n      return p1.slice(0, -2) + '{';\n    });\n    return cssText.replace(cssContentNextSelectorRe, function(match, p1) {\n      return p1 + ' {';\n    });\n  },\n  /*\n   * Process styles to add rules which will only apply under the polyfill\n   * \n   * For example, we convert this rule:\n   * \n   * polyfill-rule {\n   *   content: ':host menu-item';\n   * ...\n   * }\n   * \n   * to this:\n   * \n   * scopeName menu-item {...}\n   *\n  **/\n  insertPolyfillRulesInCssText: function(cssText) {\n    // TODO(sorvell): remove either content or comment\n    cssText = cssText.replace(cssCommentRuleRe, function(match, p1) {\n      // remove end comment delimiter\n      return p1.slice(0, -1);\n    });\n    return cssText.replace(cssContentRuleRe, function(match, p1, p2, p3) {\n      var rule = match.replace(p1, '').replace(p2, '');\n      return p3 + rule;\n    });\n  },\n  /* Ensure styles are scoped. Pseudo-scoping takes a rule like:\n   * \n   *  .foo {... } \n   *  \n   *  and converts this to\n   *  \n   *  scopeName .foo { ... }\n  */\n  scopeCssText: function(cssText, scopeSelector) {\n    var unscoped = this.extractUnscopedRulesFromCssText(cssText);\n    cssText = this.insertPolyfillHostInCssText(cssText);\n    cssText = this.convertColonHost(cssText);\n    cssText = this.convertColonHostContext(cssText);\n    cssText = this.convertShadowDOMSelectors(cssText);\n    if (scopeSelector) {\n      var self = this, cssText;\n      withCssRules(cssText, function(rules) {\n        cssText = self.scopeRules(rules, scopeSelector);\n      });\n\n    }\n    cssText = cssText + '\\n' + unscoped;\n    return cssText.trim();\n  },\n  /*\n   * Process styles to add rules which will only apply under the polyfill\n   * and do not process via CSSOM. (CSSOM is destructive to rules on rare \n   * occasions, e.g. -webkit-calc on Safari.)\n   * For example, we convert this rule:\n   * \n   * (comment start) @polyfill-unscoped-rule menu-item { \n   * ... } (comment end)\n   * \n   * to this:\n   * \n   * menu-item {...}\n   *\n  **/\n  extractUnscopedRulesFromCssText: function(cssText) {\n    // TODO(sorvell): remove either content or comment\n    var r = '', m;\n    while (m = cssCommentUnscopedRuleRe.exec(cssText)) {\n      r += m[1].slice(0, -1) + '\\n\\n';\n    }\n    while (m = cssContentUnscopedRuleRe.exec(cssText)) {\n      r += m[0].replace(m[2], '').replace(m[1], m[3]) + '\\n\\n';\n    }\n    return r;\n  },\n  /*\n   * convert a rule like :host(.foo) > .bar { }\n   *\n   * to\n   *\n   * scopeName.foo > .bar\n  */\n  convertColonHost: function(cssText) {\n    return this.convertColonRule(cssText, cssColonHostRe,\n        this.colonHostPartReplacer);\n  },\n  /*\n   * convert a rule like :host-context(.foo) > .bar { }\n   *\n   * to\n   *\n   * scopeName.foo > .bar, .foo scopeName > .bar { }\n   * \n   * and\n   *\n   * :host-context(.foo:host) .bar { ... }\n   * \n   * to\n   * \n   * scopeName.foo .bar { ... }\n  */\n  convertColonHostContext: function(cssText) {\n    return this.convertColonRule(cssText, cssColonHostContextRe,\n        this.colonHostContextPartReplacer);\n  },\n  convertColonRule: function(cssText, regExp, partReplacer) {\n    // p1 = :host, p2 = contents of (), p3 rest of rule\n    return cssText.replace(regExp, function(m, p1, p2, p3) {\n      p1 = polyfillHostNoCombinator;\n      if (p2) {\n        var parts = p2.split(','), r = [];\n        for (var i=0, l=parts.length, p; (i<l) && (p=parts[i]); i++) {\n          p = p.trim();\n          r.push(partReplacer(p1, p, p3));\n        }\n        return r.join(',');\n      } else {\n        return p1 + p3;\n      }\n    });\n  },\n  colonHostContextPartReplacer: function(host, part, suffix) {\n    if (part.match(polyfillHost)) {\n      return this.colonHostPartReplacer(host, part, suffix);\n    } else {\n      return host + part + suffix + ', ' + part + ' ' + host + suffix;\n    }\n  },\n  colonHostPartReplacer: function(host, part, suffix) {\n    return host + part.replace(polyfillHost, '') + suffix;\n  },\n  /*\n   * Convert combinators like ::shadow and pseudo-elements like ::content\n   * by replacing with space.\n  */\n  convertShadowDOMSelectors: function(cssText) {\n    for (var i=0; i < shadowDOMSelectorsRe.length; i++) {\n      cssText = cssText.replace(shadowDOMSelectorsRe[i], ' ');\n    }\n    return cssText;\n  },\n  // change a selector like 'div' to 'name div'\n  scopeRules: function(cssRules, scopeSelector) {\n    var cssText = '';\n    if (cssRules) {\n      Array.prototype.forEach.call(cssRules, function(rule) {\n        if (rule.selectorText && (rule.style && rule.style.cssText !== undefined)) {\n          cssText += this.scopeSelector(rule.selectorText, scopeSelector, \n            this.strictStyling) + ' {\\n\\t';\n          cssText += this.propertiesFromRule(rule) + '\\n}\\n\\n';\n        } else if (rule.type === CSSRule.MEDIA_RULE) {\n          cssText += '@media ' + rule.media.mediaText + ' {\\n';\n          cssText += this.scopeRules(rule.cssRules, scopeSelector);\n          cssText += '\\n}\\n\\n';\n        } else {\n          // KEYFRAMES_RULE in IE throws when we query cssText\n          // when it contains a -webkit- property.\n          // if this happens, we fallback to constructing the rule\n          // from the CSSRuleSet\n          // https://connect.microsoft.com/IE/feedbackdetail/view/955703/accessing-csstext-of-a-keyframe-rule-that-contains-a-webkit-property-via-cssom-generates-exception\n          try {\n            if (rule.cssText) {\n              cssText += rule.cssText + '\\n\\n';\n            }\n          } catch(x) {\n            if (rule.type === CSSRule.KEYFRAMES_RULE && rule.cssRules) {\n              cssText += this.ieSafeCssTextFromKeyFrameRule(rule);\n            }\n          }\n        }\n      }, this);\n    }\n    return cssText;\n  },\n  ieSafeCssTextFromKeyFrameRule: function(rule) {\n    var cssText = '@keyframes ' + rule.name + ' {';\n    Array.prototype.forEach.call(rule.cssRules, function(rule) {\n      cssText += ' ' + rule.keyText + ' {' + rule.style.cssText + '}';\n    });\n    cssText += ' }';\n    return cssText;\n  },\n  scopeSelector: function(selector, scopeSelector, strict) {\n    var r = [], parts = selector.split(',');\n    parts.forEach(function(p) {\n      p = p.trim();\n      if (this.selectorNeedsScoping(p, scopeSelector)) {\n        p = (strict && !p.match(polyfillHostNoCombinator)) ? \n            this.applyStrictSelectorScope(p, scopeSelector) :\n            this.applySelectorScope(p, scopeSelector);\n      }\n      r.push(p);\n    }, this);\n    return r.join(', ');\n  },\n  selectorNeedsScoping: function(selector, scopeSelector) {\n    if (Array.isArray(scopeSelector)) {\n      return true;\n    }\n    var re = this.makeScopeMatcher(scopeSelector);\n    return !selector.match(re);\n  },\n  makeScopeMatcher: function(scopeSelector) {\n    scopeSelector = scopeSelector.replace(/\\[/g, '\\\\[').replace(/\\[/g, '\\\\]');\n    return new RegExp('^(' + scopeSelector + ')' + selectorReSuffix, 'm');\n  },\n  applySelectorScope: function(selector, selectorScope) {\n    return Array.isArray(selectorScope) ?\n        this.applySelectorScopeList(selector, selectorScope) :\n        this.applySimpleSelectorScope(selector, selectorScope);\n  },\n  // apply an array of selectors\n  applySelectorScopeList: function(selector, scopeSelectorList) {\n    var r = [];\n    for (var i=0, s; (s=scopeSelectorList[i]); i++) {\n      r.push(this.applySimpleSelectorScope(selector, s));\n    }\n    return r.join(', ');\n  },\n  // scope via name and [is=name]\n  applySimpleSelectorScope: function(selector, scopeSelector) {\n    if (selector.match(polyfillHostRe)) {\n      selector = selector.replace(polyfillHostNoCombinator, scopeSelector);\n      return selector.replace(polyfillHostRe, scopeSelector + ' ');\n    } else {\n      return scopeSelector + ' ' + selector;\n    }\n  },\n  // return a selector with [name] suffix on each simple selector\n  // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]\n  applyStrictSelectorScope: function(selector, scopeSelector) {\n    scopeSelector = scopeSelector.replace(/\\[is=([^\\]]*)\\]/g, '$1');\n    var splits = [' ', '>', '+', '~'],\n      scoped = selector,\n      attrName = '[' + scopeSelector + ']';\n    splits.forEach(function(sep) {\n      var parts = scoped.split(sep);\n      scoped = parts.map(function(p) {\n        // remove :host since it should be unnecessary\n        var t = p.trim().replace(polyfillHostRe, '');\n        if (t && (splits.indexOf(t) < 0) && (t.indexOf(attrName) < 0)) {\n          p = t.replace(/([^:]*)(:*)(.*)/, '$1' + attrName + '$2$3')\n        }\n        return p;\n      }).join(sep);\n    });\n    return scoped;\n  },\n  insertPolyfillHostInCssText: function(selector) {\n    return selector.replace(colonHostContextRe, polyfillHostContext).replace(\n        colonHostRe, polyfillHost);\n  },\n  propertiesFromRule: function(rule) {\n    var cssText = rule.style.cssText;\n    // TODO(sorvell): Safari cssom incorrectly removes quotes from the content\n    // property. (https://bugs.webkit.org/show_bug.cgi?id=118045)\n    // don't replace attr rules\n    if (rule.style.content && !rule.style.content.match(/['\"]+|attr/)) {\n      cssText = cssText.replace(/content:[^;]*;/g, 'content: \\'' + \n          rule.style.content + '\\';');\n    }\n    // TODO(sorvell): we can workaround this issue here, but we need a list\n    // of troublesome properties to fix https://github.com/Polymer/platform/issues/53\n    //\n    // inherit rules can be omitted from cssText\n    // TODO(sorvell): remove when Blink bug is fixed:\n    // https://code.google.com/p/chromium/issues/detail?id=358273\n    var style = rule.style;\n    for (var i in style) {\n      if (style[i] === 'initial') {\n        cssText += i + ': initial; ';\n      }\n    }\n    return cssText;\n  },\n  replaceTextInStyles: function(styles, action) {\n    if (styles && action) {\n      if (!(styles instanceof Array)) {\n        styles = [styles];\n      }\n      Array.prototype.forEach.call(styles, function(s) {\n        s.textContent = action.call(this, s.textContent);\n      }, this);\n    }\n  },\n  addCssToDocument: function(cssText, name) {\n    if (cssText.match('@import')) {\n      addOwnSheet(cssText, name);\n    } else {\n      addCssToDocument(cssText);\n    }\n  }\n};\n\nvar selectorRe = /([^{]*)({[\\s\\S]*?})/gim,\n    cssCommentRe = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//gim,\n    // TODO(sorvell): remove either content or comment\n    cssCommentNextSelectorRe = /\\/\\*\\s*@polyfill ([^*]*\\*+([^/*][^*]*\\*+)*\\/)([^{]*?){/gim,\n    cssContentNextSelectorRe = /polyfill-next-selector[^}]*content\\:[\\s]*?['\"](.*?)['\"][;\\s]*}([^{]*?){/gim,  \n    // TODO(sorvell): remove either content or comment\n    cssCommentRuleRe = /\\/\\*\\s@polyfill-rule([^*]*\\*+([^/*][^*]*\\*+)*)\\//gim,\n    cssContentRuleRe = /(polyfill-rule)[^}]*(content\\:[\\s]*['\"](.*?)['\"])[;\\s]*[^}]*}/gim,\n    // TODO(sorvell): remove either content or comment\n    cssCommentUnscopedRuleRe = /\\/\\*\\s@polyfill-unscoped-rule([^*]*\\*+([^/*][^*]*\\*+)*)\\//gim,\n    cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content\\:[\\s]*['\"](.*?)['\"])[;\\s]*[^}]*}/gim,\n    cssPseudoRe = /::(x-[^\\s{,(]*)/gim,\n    cssPartRe = /::part\\(([^)]*)\\)/gim,\n    // note: :host pre-processed to -shadowcsshost.\n    polyfillHost = '-shadowcsshost',\n    // note: :host-context pre-processed to -shadowcsshostcontext.\n    polyfillHostContext = '-shadowcsscontext',\n    parenSuffix = ')(?:\\\\((' +\n        '(?:\\\\([^)(]*\\\\)|[^)(]*)+?' +\n        ')\\\\))?([^,{]*)';\n    cssColonHostRe = new RegExp('(' + polyfillHost + parenSuffix, 'gim'),\n    cssColonHostContextRe = new RegExp('(' + polyfillHostContext + parenSuffix, 'gim'),\n    selectorReSuffix = '([>\\\\s~+\\[.,{:][\\\\s\\\\S]*)?$',\n    colonHostRe = /\\:host/gim,\n    colonHostContextRe = /\\:host-context/gim,\n    /* host name without combinator */\n    polyfillHostNoCombinator = polyfillHost + '-no-combinator',\n    polyfillHostRe = new RegExp(polyfillHost, 'gim'),\n    polyfillHostContextRe = new RegExp(polyfillHostContext, 'gim'),\n    shadowDOMSelectorsRe = [\n      /\\^\\^/g,\n      /\\^/g,\n      /\\/shadow\\//g,\n      /\\/shadow-deep\\//g,\n      /::shadow/g,\n      /\\/deep\\//g,\n      /::content/g\n    ];\n\nfunction stylesToCssText(styles, preserveComments) {\n  var cssText = '';\n  Array.prototype.forEach.call(styles, function(s) {\n    cssText += s.textContent + '\\n\\n';\n  });\n  // strip comments for easier processing\n  if (!preserveComments) {\n    cssText = cssText.replace(cssCommentRe, '');\n  }\n  return cssText;\n}\n\nfunction cssTextToStyle(cssText) {\n  var style = document.createElement('style');\n  style.textContent = cssText;\n  return style;\n}\n\nfunction cssToRules(cssText) {\n  var style = cssTextToStyle(cssText);\n  document.head.appendChild(style);\n  var rules = [];\n  if (style.sheet) {\n    // TODO(sorvell): Firefox throws when accessing the rules of a stylesheet\n    // with an @import\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=625013\n    try {\n      rules = style.sheet.cssRules;\n    } catch(e) {\n      //\n    }\n  } else {\n    console.warn('sheet not found', style);\n  }\n  style.parentNode.removeChild(style);\n  return rules;\n}\n\nvar frame = document.createElement('iframe');\nframe.style.display = 'none';\n\nfunction initFrame() {\n  frame.initialized = true;\n  document.body.appendChild(frame);\n  var doc = frame.contentDocument;\n  var base = doc.createElement('base');\n  base.href = document.baseURI;\n  doc.head.appendChild(base);\n}\n\nfunction inFrame(fn) {\n  if (!frame.initialized) {\n    initFrame();\n  }\n  document.body.appendChild(frame);\n  fn(frame.contentDocument);\n  document.body.removeChild(frame);\n}\n\n// TODO(sorvell): use an iframe if the cssText contains an @import to workaround\n// https://code.google.com/p/chromium/issues/detail?id=345114\nvar isChrome = navigator.userAgent.match('Chrome');\nfunction withCssRules(cssText, callback) {\n  if (!callback) {\n    return;\n  }\n  var rules;\n  if (cssText.match('@import') && isChrome) {\n    var style = cssTextToStyle(cssText);\n    inFrame(function(doc) {\n      doc.head.appendChild(style.impl);\n      rules = Array.prototype.slice.call(style.sheet.cssRules, 0);\n      callback(rules);\n    });\n  } else {\n    rules = cssToRules(cssText);\n    callback(rules);\n  }\n}\n\nfunction rulesToCss(cssRules) {\n  for (var i=0, css=[]; i < cssRules.length; i++) {\n    css.push(cssRules[i].cssText);\n  }\n  return css.join('\\n\\n');\n}\n\nfunction addCssToDocument(cssText) {\n  if (cssText) {\n    getSheet().appendChild(document.createTextNode(cssText));\n  }\n}\n\nfunction addOwnSheet(cssText, name) {\n  var style = cssTextToStyle(cssText);\n  style.setAttribute(name, '');\n  style.setAttribute(SHIMMED_ATTRIBUTE, '');\n  document.head.appendChild(style);\n}\n\nvar SHIM_ATTRIBUTE = 'shim-shadowdom';\nvar SHIMMED_ATTRIBUTE = 'shim-shadowdom-css';\nvar NO_SHIM_ATTRIBUTE = 'no-shim';\n\nvar sheet;\nfunction getSheet() {\n  if (!sheet) {\n    sheet = document.createElement(\"style\");\n    sheet.setAttribute(SHIMMED_ATTRIBUTE, '');\n    sheet[SHIMMED_ATTRIBUTE] = true;\n  }\n  return sheet;\n}\n\n// add polyfill stylesheet to document\nif (window.ShadowDOMPolyfill) {\n  addCssToDocument('style { display: none !important; }\\n');\n  var doc = wrap(document);\n  var head = doc.querySelector('head');\n  head.insertBefore(getSheet(), head.childNodes[0]);\n\n  // TODO(sorvell): monkey-patching HTMLImports is abusive;\n  // consider a better solution.\n  document.addEventListener('DOMContentLoaded', function() {\n    var urlResolver = scope.urlResolver;\n    \n    if (window.HTMLImports && !HTMLImports.useNative) {\n      var SHIM_SHEET_SELECTOR = 'link[rel=stylesheet]' +\n          '[' + SHIM_ATTRIBUTE + ']';\n      var SHIM_STYLE_SELECTOR = 'style[' + SHIM_ATTRIBUTE + ']';\n      HTMLImports.importer.documentPreloadSelectors += ',' + SHIM_SHEET_SELECTOR;\n      HTMLImports.importer.importsPreloadSelectors += ',' + SHIM_SHEET_SELECTOR;\n\n      HTMLImports.parser.documentSelectors = [\n        HTMLImports.parser.documentSelectors,\n        SHIM_SHEET_SELECTOR,\n        SHIM_STYLE_SELECTOR\n      ].join(',');\n  \n      var originalParseGeneric = HTMLImports.parser.parseGeneric;\n\n      HTMLImports.parser.parseGeneric = function(elt) {\n        if (elt[SHIMMED_ATTRIBUTE]) {\n          return;\n        }\n        var style = elt.__importElement || elt;\n        if (!style.hasAttribute(SHIM_ATTRIBUTE)) {\n          originalParseGeneric.call(this, elt);\n          return;\n        }\n        if (elt.__resource) {\n          style = elt.ownerDocument.createElement('style');\n          style.textContent = elt.__resource;\n        }\n        // relay on HTMLImports for path fixup\n        HTMLImports.path.resolveUrlsInStyle(style);\n        style.textContent = ShadowCSS.shimStyle(style);\n        style.removeAttribute(SHIM_ATTRIBUTE, '');\n        style.setAttribute(SHIMMED_ATTRIBUTE, '');\n        style[SHIMMED_ATTRIBUTE] = true;\n        // place in document\n        if (style.parentNode !== head) {\n          // replace links in head\n          if (elt.parentNode === head) {\n            head.replaceChild(style, elt);\n          } else {\n            this.addElementToDocument(style);\n          }\n        }\n        style.__importParsed = true;\n        this.markParsingComplete(elt);\n        this.parseNext();\n      }\n\n      var hasResource = HTMLImports.parser.hasResource;\n      HTMLImports.parser.hasResource = function(node) {\n        if (node.localName === 'link' && node.rel === 'stylesheet' &&\n            node.hasAttribute(SHIM_ATTRIBUTE)) {\n          return (node.__resource);\n        } else {\n          return hasResource.call(this, node);\n        }\n      }\n\n    }\n  });\n}\n\n// exports\nscope.ShadowCSS = ShadowCSS;\n\n})(window.Platform);\n","/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n  // so we can call wrap/unwrap without testing for ShadowDOMPolyfill\n  window.wrap = window.unwrap = function(n){\n    return n;\n  }\n\n  addEventListener('DOMContentLoaded', function() {\n    if (CustomElements.useNative === false) {\n      var originalCreateShadowRoot = Element.prototype.createShadowRoot;\n      Element.prototype.createShadowRoot = function() {\n        var root = originalCreateShadowRoot.call(this);\n        CustomElements.watchShadow(this);\n        return root;\n      };\n    }\n  });\n\n})(window.Platform);\n","/* Any copyright is dedicated to the Public Domain.\n * http://creativecommons.org/publicdomain/zero/1.0/ */\n\n(function(scope) {\n  'use strict';\n\n  // feature detect for URL constructor\n  var hasWorkingUrl = false;\n  if (!scope.forceJURL) {\n    try {\n      var u = new URL('b', 'http://a');\n      hasWorkingUrl = u.href === 'http://a/b';\n    } catch(e) {}\n  }\n\n  if (hasWorkingUrl)\n    return;\n\n  var relative = Object.create(null);\n  relative['ftp'] = 21;\n  relative['file'] = 0;\n  relative['gopher'] = 70;\n  relative['http'] = 80;\n  relative['https'] = 443;\n  relative['ws'] = 80;\n  relative['wss'] = 443;\n\n  var relativePathDotMapping = Object.create(null);\n  relativePathDotMapping['%2e'] = '.';\n  relativePathDotMapping['.%2e'] = '..';\n  relativePathDotMapping['%2e.'] = '..';\n  relativePathDotMapping['%2e%2e'] = '..';\n\n  function isRelativeScheme(scheme) {\n    return relative[scheme] !== undefined;\n  }\n\n  function invalid() {\n    clear.call(this);\n    this._isInvalid = true;\n  }\n\n  function IDNAToASCII(h) {\n    if ('' == h) {\n      invalid.call(this)\n    }\n    // XXX\n    return h.toLowerCase()\n  }\n\n  function percentEscape(c) {\n    var unicode = c.charCodeAt(0);\n    if (unicode > 0x20 &&\n       unicode < 0x7F &&\n       // \" # < > ? `\n       [0x22, 0x23, 0x3C, 0x3E, 0x3F, 0x60].indexOf(unicode) == -1\n      ) {\n      return c;\n    }\n    return encodeURIComponent(c);\n  }\n\n  function percentEscapeQuery(c) {\n    // XXX This actually needs to encode c using encoding and then\n    // convert the bytes one-by-one.\n\n    var unicode = c.charCodeAt(0);\n    if (unicode > 0x20 &&\n       unicode < 0x7F &&\n       // \" # < > ` (do not escape '?')\n       [0x22, 0x23, 0x3C, 0x3E, 0x60].indexOf(unicode) == -1\n      ) {\n      return c;\n    }\n    return encodeURIComponent(c);\n  }\n\n  var EOF = undefined,\n      ALPHA = /[a-zA-Z]/,\n      ALPHANUMERIC = /[a-zA-Z0-9\\+\\-\\.]/;\n\n  function parse(input, stateOverride, base) {\n    function err(message) {\n      errors.push(message)\n    }\n\n    var state = stateOverride || 'scheme start',\n        cursor = 0,\n        buffer = '',\n        seenAt = false,\n        seenBracket = false,\n        errors = [];\n\n    loop: while ((input[cursor - 1] != EOF || cursor == 0) && !this._isInvalid) {\n      var c = input[cursor];\n      switch (state) {\n        case 'scheme start':\n          if (c && ALPHA.test(c)) {\n            buffer += c.toLowerCase(); // ASCII-safe\n            state = 'scheme';\n          } else if (!stateOverride) {\n            buffer = '';\n            state = 'no scheme';\n            continue;\n          } else {\n            err('Invalid scheme.');\n            break loop;\n          }\n          break;\n\n        case 'scheme':\n          if (c && ALPHANUMERIC.test(c)) {\n            buffer += c.toLowerCase(); // ASCII-safe\n          } else if (':' == c) {\n            this._scheme = buffer;\n            buffer = '';\n            if (stateOverride) {\n              break loop;\n            }\n            if (isRelativeScheme(this._scheme)) {\n              this._isRelative = true;\n            }\n            if ('file' == this._scheme) {\n              state = 'relative';\n            } else if (this._isRelative && base && base._scheme == this._scheme) {\n              state = 'relative or authority';\n            } else if (this._isRelative) {\n              state = 'authority first slash';\n            } else {\n              state = 'scheme data';\n            }\n          } else if (!stateOverride) {\n            buffer = '';\n            cursor = 0;\n            state = 'no scheme';\n            continue;\n          } else if (EOF == c) {\n            break loop;\n          } else {\n            err('Code point not allowed in scheme: ' + c)\n            break loop;\n          }\n          break;\n\n        case 'scheme data':\n          if ('?' == c) {\n            query = '?';\n            state = 'query';\n          } else if ('#' == c) {\n            this._fragment = '#';\n            state = 'fragment';\n          } else {\n            // XXX error handling\n            if (EOF != c && '\\t' != c && '\\n' != c && '\\r' != c) {\n              this._schemeData += percentEscape(c);\n            }\n          }\n          break;\n\n        case 'no scheme':\n          if (!base || !(isRelativeScheme(base._scheme))) {\n            err('Missing scheme.');\n            invalid.call(this);\n          } else {\n            state = 'relative';\n            continue;\n          }\n          break;\n\n        case 'relative or authority':\n          if ('/' == c && '/' == input[cursor+1]) {\n            state = 'authority ignore slashes';\n          } else {\n            err('Expected /, got: ' + c);\n            state = 'relative';\n            continue\n          }\n          break;\n\n        case 'relative':\n          this._isRelative = true;\n          if ('file' != this._scheme)\n            this._scheme = base._scheme;\n          if (EOF == c) {\n            this._host = base._host;\n            this._port = base._port;\n            this._path = base._path.slice();\n            this._query = base._query;\n            break loop;\n          } else if ('/' == c || '\\\\' == c) {\n            if ('\\\\' == c)\n              err('\\\\ is an invalid code point.');\n            state = 'relative slash';\n          } else if ('?' == c) {\n            this._host = base._host;\n            this._port = base._port;\n            this._path = base._path.slice();\n            this._query = '?';\n            state = 'query';\n          } else if ('#' == c) {\n            this._host = base._host;\n            this._port = base._port;\n            this._path = base._path.slice();\n            this._query = base._query;\n            this._fragment = '#';\n            state = 'fragment';\n          } else {\n            var nextC = input[cursor+1]\n            var nextNextC = input[cursor+2]\n            if (\n              'file' != this._scheme || !ALPHA.test(c) ||\n              (nextC != ':' && nextC != '|') ||\n              (EOF != nextNextC && '/' != nextNextC && '\\\\' != nextNextC && '?' != nextNextC && '#' != nextNextC)) {\n              this._host = base._host;\n              this._port = base._port;\n              this._path = base._path.slice();\n              this._path.pop();\n            }\n            state = 'relative path';\n            continue;\n          }\n          break;\n\n        case 'relative slash':\n          if ('/' == c || '\\\\' == c) {\n            if ('\\\\' == c) {\n              err('\\\\ is an invalid code point.');\n            }\n            if ('file' == this._scheme) {\n              state = 'file host';\n            } else {\n              state = 'authority ignore slashes';\n            }\n          } else {\n            if ('file' != this._scheme) {\n              this._host = base._host;\n              this._port = base._port;\n            }\n            state = 'relative path';\n            continue;\n          }\n          break;\n\n        case 'authority first slash':\n          if ('/' == c) {\n            state = 'authority second slash';\n          } else {\n            err(\"Expected '/', got: \" + c);\n            state = 'authority ignore slashes';\n            continue;\n          }\n          break;\n\n        case 'authority second slash':\n          state = 'authority ignore slashes';\n          if ('/' != c) {\n            err(\"Expected '/', got: \" + c);\n            continue;\n          }\n          break;\n\n        case 'authority ignore slashes':\n          if ('/' != c && '\\\\' != c) {\n            state = 'authority';\n            continue;\n          } else {\n            err('Expected authority, got: ' + c);\n          }\n          break;\n\n        case 'authority':\n          if ('@' == c) {\n            if (seenAt) {\n              err('@ already seen.');\n              buffer += '%40';\n            }\n            seenAt = true;\n            for (var i = 0; i < buffer.length; i++) {\n              var cp = buffer[i];\n              if ('\\t' == cp || '\\n' == cp || '\\r' == cp) {\n                err('Invalid whitespace in authority.');\n                continue;\n              }\n              // XXX check URL code points\n              if (':' == cp && null === this._password) {\n                this._password = '';\n                continue;\n              }\n              var tempC = percentEscape(cp);\n              (null !== this._password) ? this._password += tempC : this._username += tempC;\n            }\n            buffer = '';\n          } else if (EOF == c || '/' == c || '\\\\' == c || '?' == c || '#' == c) {\n            cursor -= buffer.length;\n            buffer = '';\n            state = 'host';\n            continue;\n          } else {\n            buffer += c;\n          }\n          break;\n\n        case 'file host':\n          if (EOF == c || '/' == c || '\\\\' == c || '?' == c || '#' == c) {\n            if (buffer.length == 2 && ALPHA.test(buffer[0]) && (buffer[1] == ':' || buffer[1] == '|')) {\n              state = 'relative path';\n            } else if (buffer.length == 0) {\n              state = 'relative path start';\n            } else {\n              this._host = IDNAToASCII.call(this, buffer);\n              buffer = '';\n              state = 'relative path start';\n            }\n            continue;\n          } else if ('\\t' == c || '\\n' == c || '\\r' == c) {\n            err('Invalid whitespace in file host.');\n          } else {\n            buffer += c;\n          }\n          break;\n\n        case 'host':\n        case 'hostname':\n          if (':' == c && !seenBracket) {\n            // XXX host parsing\n            this._host = IDNAToASCII.call(this, buffer);\n            buffer = '';\n            state = 'port';\n            if ('hostname' == stateOverride) {\n              break loop;\n            }\n          } else if (EOF == c || '/' == c || '\\\\' == c || '?' == c || '#' == c) {\n            this._host = IDNAToASCII.call(this, buffer);\n            buffer = '';\n            state = 'relative path start';\n            if (stateOverride) {\n              break loop;\n            }\n            continue;\n          } else if ('\\t' != c && '\\n' != c && '\\r' != c) {\n            if ('[' == c) {\n              seenBracket = true;\n            } else if (']' == c) {\n              seenBracket = false;\n            }\n            buffer += c;\n          } else {\n            err('Invalid code point in host/hostname: ' + c);\n          }\n          break;\n\n        case 'port':\n          if (/[0-9]/.test(c)) {\n            buffer += c;\n          } else if (EOF == c || '/' == c || '\\\\' == c || '?' == c || '#' == c || stateOverride) {\n            if ('' != buffer) {\n              var temp = parseInt(buffer, 10);\n              if (temp != relative[this._scheme]) {\n                this._port = temp + '';\n              }\n              buffer = '';\n            }\n            if (stateOverride) {\n              break loop;\n            }\n            state = 'relative path start';\n            continue;\n          } else if ('\\t' == c || '\\n' == c || '\\r' == c) {\n            err('Invalid code point in port: ' + c);\n          } else {\n            invalid.call(this);\n          }\n          break;\n\n        case 'relative path start':\n          if ('\\\\' == c)\n            err(\"'\\\\' not allowed in path.\");\n          state = 'relative path';\n          if ('/' != c && '\\\\' != c) {\n            continue;\n          }\n          break;\n\n        case 'relative path':\n          if (EOF == c || '/' == c || '\\\\' == c || (!stateOverride && ('?' == c || '#' == c))) {\n            if ('\\\\' == c) {\n              err('\\\\ not allowed in relative path.');\n            }\n            var tmp;\n            if (tmp = relativePathDotMapping[buffer.toLowerCase()]) {\n              buffer = tmp;\n            }\n            if ('..' == buffer) {\n              this._path.pop();\n              if ('/' != c && '\\\\' != c) {\n                this._path.push('');\n              }\n            } else if ('.' == buffer && '/' != c && '\\\\' != c) {\n              this._path.push('');\n            } else if ('.' != buffer) {\n              if ('file' == this._scheme && this._path.length == 0 && buffer.length == 2 && ALPHA.test(buffer[0]) && buffer[1] == '|') {\n                buffer = buffer[0] + ':';\n              }\n              this._path.push(buffer);\n            }\n            buffer = '';\n            if ('?' == c) {\n              this._query = '?';\n              state = 'query';\n            } else if ('#' == c) {\n              this._fragment = '#';\n              state = 'fragment';\n            }\n          } else if ('\\t' != c && '\\n' != c && '\\r' != c) {\n            buffer += percentEscape(c);\n          }\n          break;\n\n        case 'query':\n          if (!stateOverride && '#' == c) {\n            this._fragment = '#';\n            state = 'fragment';\n          } else if (EOF != c && '\\t' != c && '\\n' != c && '\\r' != c) {\n            this._query += percentEscapeQuery(c);\n          }\n          break;\n\n        case 'fragment':\n          if (EOF != c && '\\t' != c && '\\n' != c && '\\r' != c) {\n            this._fragment += c;\n          }\n          break;\n      }\n\n      cursor++;\n    }\n  }\n\n  function clear() {\n    this._scheme = '';\n    this._schemeData = '';\n    this._username = '';\n    this._password = null;\n    this._host = '';\n    this._port = '';\n    this._path = [];\n    this._query = '';\n    this._fragment = '';\n    this._isInvalid = false;\n    this._isRelative = false;\n  }\n\n  // Does not process domain names or IP addresses.\n  // Does not handle encoding for the query parameter.\n  function jURL(url, base /* , encoding */) {\n    if (base !== undefined && !(base instanceof jURL))\n      base = new jURL(String(base));\n\n    this._url = url;\n    clear.call(this);\n\n    var input = url.replace(/^[ \\t\\r\\n\\f]+|[ \\t\\r\\n\\f]+$/g, '');\n    // encoding = encoding || 'utf-8'\n\n    parse.call(this, input, null, base);\n  }\n\n  jURL.prototype = {\n    get href() {\n      if (this._isInvalid)\n        return this._url;\n\n      var authority = '';\n      if ('' != this._username || null != this._password) {\n        authority = this._username +\n            (null != this._password ? ':' + this._password : '') + '@';\n      }\n\n      return this.protocol +\n          (this._isRelative ? '//' + authority + this.host : '') +\n          this.pathname + this._query + this._fragment;\n    },\n    set href(href) {\n      clear.call(this);\n      parse.call(this, href);\n    },\n\n    get protocol() {\n      return this._scheme + ':';\n    },\n    set protocol(protocol) {\n      if (this._isInvalid)\n        return;\n      parse.call(this, protocol + ':', 'scheme start');\n    },\n\n    get host() {\n      return this._isInvalid ? '' : this._port ?\n          this._host + ':' + this._port : this._host;\n    },\n    set host(host) {\n      if (this._isInvalid || !this._isRelative)\n        return;\n      parse.call(this, host, 'host');\n    },\n\n    get hostname() {\n      return this._host;\n    },\n    set hostname(hostname) {\n      if (this._isInvalid || !this._isRelative)\n        return;\n      parse.call(this, hostname, 'hostname');\n    },\n\n    get port() {\n      return this._port;\n    },\n    set port(port) {\n      if (this._isInvalid || !this._isRelative)\n        return;\n      parse.call(this, port, 'port');\n    },\n\n    get pathname() {\n      return this._isInvalid ? '' : this._isRelative ?\n          '/' + this._path.join('/') : this._schemeData;\n    },\n    set pathname(pathname) {\n      if (this._isInvalid || !this._isRelative)\n        return;\n      this._path = [];\n      parse.call(this, pathname, 'relative path start');\n    },\n\n    get search() {\n      return this._isInvalid || !this._query || '?' == this._query ?\n          '' : this._query;\n    },\n    set search(search) {\n      if (this._isInvalid || !this._isRelative)\n        return;\n      this._query = '?';\n      if ('?' == search[0])\n        search = search.slice(1);\n      parse.call(this, search, 'query');\n    },\n\n    get hash() {\n      return this._isInvalid || !this._fragment || '#' == this._fragment ?\n          '' : this._fragment;\n    },\n    set hash(hash) {\n      if (this._isInvalid)\n        return;\n      this._fragment = '#';\n      if ('#' == hash[0])\n        hash = hash.slice(1);\n      parse.call(this, hash, 'fragment');\n    }\n  };\n\n  // Copy over the static methods\n  var OriginalURL = scope.URL;\n  if (OriginalURL) {\n    jURL.createObjectURL = function(blob) {\n      // IE extension allows a second optional options argument.\n      // http://msdn.microsoft.com/en-us/library/ie/hh772302(v=vs.85).aspx\n      return OriginalURL.createObjectURL.apply(OriginalURL, arguments);\n    };\n    jURL.revokeObjectURL = function(url) {\n      OriginalURL.revokeObjectURL(url);\n    };\n  }\n\n  scope.URL = jURL;\n\n})(this);\n","/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n// Old versions of iOS do not have bind.\n\nif (!Function.prototype.bind) {\n  Function.prototype.bind = function(scope) {\n    var self = this;\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function() {\n      var args2 = args.slice();\n      args2.push.apply(args2, arguments);\n      return self.apply(scope, args2);\n    };\n  };\n}\n\n})(window.Platform);\n","/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n  'use strict';\n\n  // polyfill performance.now\n\n  if (!window.performance) {\n    var start = Date.now();\n    // only at millisecond precision\n    window.performance = {now: function(){ return Date.now() - start }};\n  }\n\n  // polyfill for requestAnimationFrame\n\n  if (!window.requestAnimationFrame) {\n    window.requestAnimationFrame = (function() {\n      var nativeRaf = window.webkitRequestAnimationFrame ||\n        window.mozRequestAnimationFrame;\n\n      return nativeRaf ?\n        function(callback) {\n          return nativeRaf(function() {\n            callback(performance.now());\n          });\n        } :\n        function( callback ){\n          return window.setTimeout(callback, 1000 / 60);\n        };\n    })();\n  }\n\n  if (!window.cancelAnimationFrame) {\n    window.cancelAnimationFrame = (function() {\n      return  window.webkitCancelAnimationFrame ||\n        window.mozCancelAnimationFrame ||\n        function(id) {\n          clearTimeout(id);\n        };\n    })();\n  }\n\n  // Make a stub for Polymer() for polyfill purposes; under the HTMLImports\n  // polyfill, scripts in the main document run before imports. That means\n  // if (1) polymer is imported and (2) Polymer() is called in the main document\n  // in a script after the import, 2 occurs before 1. We correct this here\n  // by specfiically patching Polymer(); this is not necessary under native\n  // HTMLImports.\n  var elementDeclarations = [];\n\n  var polymerStub = function(name, dictionary) {\n    Array.prototype.push.call(arguments, document._currentScript);\n    elementDeclarations.push(arguments);\n  };\n  window.Polymer = polymerStub;\n\n  // deliver queued delcarations\n  scope.consumeDeclarations = function(callback) {\n    scope.consumeDeclarations = function() {\n     throw 'Possible attempt to load Polymer twice';\n    };\n    if (callback) {\n      callback(elementDeclarations);\n    }\n    elementDeclarations = null;\n  };\n\n  // Once DOMContent has loaded, any main document scripts that depend on\n  // Polymer() should have run. Calling Polymer() now is an error until\n  // polymer is imported.\n  window.addEventListener('DOMContentLoaded', function() {\n    if (window.Polymer === polymerStub) {\n      window.Polymer = function() {\n        console.error('You tried to use polymer without loading it first. To ' +\n          'load polymer, <link rel=\"import\" href=\"' + \n          'components/polymer/polymer.html\">');\n      };\n    }\n  });\n\n})(window.Platform);\n","/*\n * Copyright 2012 The Polymer Authors. All rights reserved.\n * Use of this source code is goverened by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\n(function(global) {\n\n  var registrationsTable = new WeakMap();\n\n  // We use setImmediate or postMessage for our future callback.\n  var setImmediate = window.msSetImmediate;\n\n  // Use post message to emulate setImmediate.\n  if (!setImmediate) {\n    var setImmediateQueue = [];\n    var sentinel = String(Math.random());\n    window.addEventListener('message', function(e) {\n      if (e.data === sentinel) {\n        var queue = setImmediateQueue;\n        setImmediateQueue = [];\n        queue.forEach(function(func) {\n          func();\n        });\n      }\n    });\n    setImmediate = function(func) {\n      setImmediateQueue.push(func);\n      window.postMessage(sentinel, '*');\n    };\n  }\n\n  // This is used to ensure that we never schedule 2 callas to setImmediate\n  var isScheduled = false;\n\n  // Keep track of observers that needs to be notified next time.\n  var scheduledObservers = [];\n\n  /**\n   * Schedules |dispatchCallback| to be called in the future.\n   * @param {MutationObserver} observer\n   */\n  function scheduleCallback(observer) {\n    scheduledObservers.push(observer);\n    if (!isScheduled) {\n      isScheduled = true;\n      setImmediate(dispatchCallbacks);\n    }\n  }\n\n  function wrapIfNeeded(node) {\n    return window.ShadowDOMPolyfill &&\n        window.ShadowDOMPolyfill.wrapIfNeeded(node) ||\n        node;\n  }\n\n  function dispatchCallbacks() {\n    // http://dom.spec.whatwg.org/#mutation-observers\n\n    isScheduled = false; // Used to allow a new setImmediate call above.\n\n    var observers = scheduledObservers;\n    scheduledObservers = [];\n    // Sort observers based on their creation UID (incremental).\n    observers.sort(function(o1, o2) {\n      return o1.uid_ - o2.uid_;\n    });\n\n    var anyNonEmpty = false;\n    observers.forEach(function(observer) {\n\n      // 2.1, 2.2\n      var queue = observer.takeRecords();\n      // 2.3. Remove all transient registered observers whose observer is mo.\n      removeTransientObserversFor(observer);\n\n      // 2.4\n      if (queue.length) {\n        observer.callback_(queue, observer);\n        anyNonEmpty = true;\n      }\n    });\n\n    // 3.\n    if (anyNonEmpty)\n      dispatchCallbacks();\n  }\n\n  function removeTransientObserversFor(observer) {\n    observer.nodes_.forEach(function(node) {\n      var registrations = registrationsTable.get(node);\n      if (!registrations)\n        return;\n      registrations.forEach(function(registration) {\n        if (registration.observer === observer)\n          registration.removeTransientObservers();\n      });\n    });\n  }\n\n  /**\n   * This function is used for the \"For each registered observer observer (with\n   * observer's options as options) in target's list of registered observers,\n   * run these substeps:\" and the \"For each ancestor ancestor of target, and for\n   * each registered observer observer (with options options) in ancestor's list\n   * of registered observers, run these substeps:\" part of the algorithms. The\n   * |options.subtree| is checked to ensure that the callback is called\n   * correctly.\n   *\n   * @param {Node} target\n   * @param {function(MutationObserverInit):MutationRecord} callback\n   */\n  function forEachAncestorAndObserverEnqueueRecord(target, callback) {\n    for (var node = target; node; node = node.parentNode) {\n      var registrations = registrationsTable.get(node);\n\n      if (registrations) {\n        for (var j = 0; j < registrations.length; j++) {\n          var registration = registrations[j];\n          var options = registration.options;\n\n          // Only target ignores subtree.\n          if (node !== target && !options.subtree)\n            continue;\n\n          var record = callback(options);\n          if (record)\n            registration.enqueue(record);\n        }\n      }\n    }\n  }\n\n  var uidCounter = 0;\n\n  /**\n   * The class that maps to the DOM MutationObserver interface.\n   * @param {Function} callback.\n   * @constructor\n   */\n  function JsMutationObserver(callback) {\n    this.callback_ = callback;\n    this.nodes_ = [];\n    this.records_ = [];\n    this.uid_ = ++uidCounter;\n  }\n\n  JsMutationObserver.prototype = {\n    observe: function(target, options) {\n      target = wrapIfNeeded(target);\n\n      // 1.1\n      if (!options.childList && !options.attributes && !options.characterData ||\n\n          // 1.2\n          options.attributeOldValue && !options.attributes ||\n\n          // 1.3\n          options.attributeFilter && options.attributeFilter.length &&\n              !options.attributes ||\n\n          // 1.4\n          options.characterDataOldValue && !options.characterData) {\n\n        throw new SyntaxError();\n      }\n\n      var registrations = registrationsTable.get(target);\n      if (!registrations)\n        registrationsTable.set(target, registrations = []);\n\n      // 2\n      // If target's list of registered observers already includes a registered\n      // observer associated with the context object, replace that registered\n      // observer's options with options.\n      var registration;\n      for (var i = 0; i < registrations.length; i++) {\n        if (registrations[i].observer === this) {\n          registration = registrations[i];\n          registration.removeListeners();\n          registration.options = options;\n          break;\n        }\n      }\n\n      // 3.\n      // Otherwise, add a new registered observer to target's list of registered\n      // observers with the context object as the observer and options as the\n      // options, and add target to context object's list of nodes on which it\n      // is registered.\n      if (!registration) {\n        registration = new Registration(this, target, options);\n        registrations.push(registration);\n        this.nodes_.push(target);\n      }\n\n      registration.addListeners();\n    },\n\n    disconnect: function() {\n      this.nodes_.forEach(function(node) {\n        var registrations = registrationsTable.get(node);\n        for (var i = 0; i < registrations.length; i++) {\n          var registration = registrations[i];\n          if (registration.observer === this) {\n            registration.removeListeners();\n            registrations.splice(i, 1);\n            // Each node can only have one registered observer associated with\n            // this observer.\n            break;\n          }\n        }\n      }, this);\n      this.records_ = [];\n    },\n\n    takeRecords: function() {\n      var copyOfRecords = this.records_;\n      this.records_ = [];\n      return copyOfRecords;\n    }\n  };\n\n  /**\n   * @param {string} type\n   * @param {Node} target\n   * @constructor\n   */\n  function MutationRecord(type, target) {\n    this.type = type;\n    this.target = target;\n    this.addedNodes = [];\n    this.removedNodes = [];\n    this.previousSibling = null;\n    this.nextSibling = null;\n    this.attributeName = null;\n    this.attributeNamespace = null;\n    this.oldValue = null;\n  }\n\n  function copyMutationRecord(original) {\n    var record = new MutationRecord(original.type, original.target);\n    record.addedNodes = original.addedNodes.slice();\n    record.removedNodes = original.removedNodes.slice();\n    record.previousSibling = original.previousSibling;\n    record.nextSibling = original.nextSibling;\n    record.attributeName = original.attributeName;\n    record.attributeNamespace = original.attributeNamespace;\n    record.oldValue = original.oldValue;\n    return record;\n  };\n\n  // We keep track of the two (possibly one) records used in a single mutation.\n  var currentRecord, recordWithOldValue;\n\n  /**\n   * Creates a record without |oldValue| and caches it as |currentRecord| for\n   * later use.\n   * @param {string} oldValue\n   * @return {MutationRecord}\n   */\n  function getRecord(type, target) {\n    return currentRecord = new MutationRecord(type, target);\n  }\n\n  /**\n   * Gets or creates a record with |oldValue| based in the |currentRecord|\n   * @param {string} oldValue\n   * @return {MutationRecord}\n   */\n  function getRecordWithOldValue(oldValue) {\n    if (recordWithOldValue)\n      return recordWithOldValue;\n    recordWithOldValue = copyMutationRecord(currentRecord);\n    recordWithOldValue.oldValue = oldValue;\n    return recordWithOldValue;\n  }\n\n  function clearRecords() {\n    currentRecord = recordWithOldValue = undefined;\n  }\n\n  /**\n   * @param {MutationRecord} record\n   * @return {boolean} Whether the record represents a record from the current\n   * mutation event.\n   */\n  function recordRepresentsCurrentMutation(record) {\n    return record === recordWithOldValue || record === currentRecord;\n  }\n\n  /**\n   * Selects which record, if any, to replace the last record in the queue.\n   * This returns |null| if no record should be replaced.\n   *\n   * @param {MutationRecord} lastRecord\n   * @param {MutationRecord} newRecord\n   * @param {MutationRecord}\n   */\n  function selectRecord(lastRecord, newRecord) {\n    if (lastRecord === newRecord)\n      return lastRecord;\n\n    // Check if the the record we are adding represents the same record. If\n    // so, we keep the one with the oldValue in it.\n    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord))\n      return recordWithOldValue;\n\n    return null;\n  }\n\n  /**\n   * Class used to represent a registered observer.\n   * @param {MutationObserver} observer\n   * @param {Node} target\n   * @param {MutationObserverInit} options\n   * @constructor\n   */\n  function Registration(observer, target, options) {\n    this.observer = observer;\n    this.target = target;\n    this.options = options;\n    this.transientObservedNodes = [];\n  }\n\n  Registration.prototype = {\n    enqueue: function(record) {\n      var records = this.observer.records_;\n      var length = records.length;\n\n      // There are cases where we replace the last record with the new record.\n      // For example if the record represents the same mutation we need to use\n      // the one with the oldValue. If we get same record (this can happen as we\n      // walk up the tree) we ignore the new record.\n      if (records.length > 0) {\n        var lastRecord = records[length - 1];\n        var recordToReplaceLast = selectRecord(lastRecord, record);\n        if (recordToReplaceLast) {\n          records[length - 1] = recordToReplaceLast;\n          return;\n        }\n      } else {\n        scheduleCallback(this.observer);\n      }\n\n      records[length] = record;\n    },\n\n    addListeners: function() {\n      this.addListeners_(this.target);\n    },\n\n    addListeners_: function(node) {\n      var options = this.options;\n      if (options.attributes)\n        node.addEventListener('DOMAttrModified', this, true);\n\n      if (options.characterData)\n        node.addEventListener('DOMCharacterDataModified', this, true);\n\n      if (options.childList)\n        node.addEventListener('DOMNodeInserted', this, true);\n\n      if (options.childList || options.subtree)\n        node.addEventListener('DOMNodeRemoved', this, true);\n    },\n\n    removeListeners: function() {\n      this.removeListeners_(this.target);\n    },\n\n    removeListeners_: function(node) {\n      var options = this.options;\n      if (options.attributes)\n        node.removeEventListener('DOMAttrModified', this, true);\n\n      if (options.characterData)\n        node.removeEventListener('DOMCharacterDataModified', this, true);\n\n      if (options.childList)\n        node.removeEventListener('DOMNodeInserted', this, true);\n\n      if (options.childList || options.subtree)\n        node.removeEventListener('DOMNodeRemoved', this, true);\n    },\n\n    /**\n     * Adds a transient observer on node. The transient observer gets removed\n     * next time we deliver the change records.\n     * @param {Node} node\n     */\n    addTransientObserver: function(node) {\n      // Don't add transient observers on the target itself. We already have all\n      // the required listeners set up on the target.\n      if (node === this.target)\n        return;\n\n      this.addListeners_(node);\n      this.transientObservedNodes.push(node);\n      var registrations = registrationsTable.get(node);\n      if (!registrations)\n        registrationsTable.set(node, registrations = []);\n\n      // We know that registrations does not contain this because we already\n      // checked if node === this.target.\n      registrations.push(this);\n    },\n\n    removeTransientObservers: function() {\n      var transientObservedNodes = this.transientObservedNodes;\n      this.transientObservedNodes = [];\n\n      transientObservedNodes.forEach(function(node) {\n        // Transient observers are never added to the target.\n        this.removeListeners_(node);\n\n        var registrations = registrationsTable.get(node);\n        for (var i = 0; i < registrations.length; i++) {\n          if (registrations[i] === this) {\n            registrations.splice(i, 1);\n            // Each node can only have one registered observer associated with\n            // this observer.\n            break;\n          }\n        }\n      }, this);\n    },\n\n    handleEvent: function(e) {\n      // Stop propagation since we are managing the propagation manually.\n      // This means that other mutation events on the page will not work\n      // correctly but that is by design.\n      e.stopImmediatePropagation();\n\n      switch (e.type) {\n        case 'DOMAttrModified':\n          // http://dom.spec.whatwg.org/#concept-mo-queue-attributes\n\n          var name = e.attrName;\n          var namespace = e.relatedNode.namespaceURI;\n          var target = e.target;\n\n          // 1.\n          var record = new getRecord('attributes', target);\n          record.attributeName = name;\n          record.attributeNamespace = namespace;\n\n          // 2.\n          var oldValue =\n              e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;\n\n          forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n            // 3.1, 4.2\n            if (!options.attributes)\n              return;\n\n            // 3.2, 4.3\n            if (options.attributeFilter && options.attributeFilter.length &&\n                options.attributeFilter.indexOf(name) === -1 &&\n                options.attributeFilter.indexOf(namespace) === -1) {\n              return;\n            }\n            // 3.3, 4.4\n            if (options.attributeOldValue)\n              return getRecordWithOldValue(oldValue);\n\n            // 3.4, 4.5\n            return record;\n          });\n\n          break;\n\n        case 'DOMCharacterDataModified':\n          // http://dom.spec.whatwg.org/#concept-mo-queue-characterdata\n          var target = e.target;\n\n          // 1.\n          var record = getRecord('characterData', target);\n\n          // 2.\n          var oldValue = e.prevValue;\n\n\n          forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n            // 3.1, 4.2\n            if (!options.characterData)\n              return;\n\n            // 3.2, 4.3\n            if (options.characterDataOldValue)\n              return getRecordWithOldValue(oldValue);\n\n            // 3.3, 4.4\n            return record;\n          });\n\n          break;\n\n        case 'DOMNodeRemoved':\n          this.addTransientObserver(e.target);\n          // Fall through.\n        case 'DOMNodeInserted':\n          // http://dom.spec.whatwg.org/#concept-mo-queue-childlist\n          var target = e.relatedNode;\n          var changedNode = e.target;\n          var addedNodes, removedNodes;\n          if (e.type === 'DOMNodeInserted') {\n            addedNodes = [changedNode];\n            removedNodes = [];\n          } else {\n\n            addedNodes = [];\n            removedNodes = [changedNode];\n          }\n          var previousSibling = changedNode.previousSibling;\n          var nextSibling = changedNode.nextSibling;\n\n          // 1.\n          var record = getRecord('childList', target);\n          record.addedNodes = addedNodes;\n          record.removedNodes = removedNodes;\n          record.previousSibling = previousSibling;\n          record.nextSibling = nextSibling;\n\n          forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n            // 2.1, 3.2\n            if (!options.childList)\n              return;\n\n            // 2.2, 3.3\n            return record;\n          });\n\n      }\n\n      clearRecords();\n    }\n  };\n\n  global.JsMutationObserver = JsMutationObserver;\n\n  if (!global.MutationObserver)\n    global.MutationObserver = JsMutationObserver;\n\n\n})(this);\n","/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\nwindow.HTMLImports = window.HTMLImports || {flags:{}};","/*\r\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n */\r\n\r\n(function(scope) {\r\n\r\nvar hasNative = ('import' in document.createElement('link'));\r\nvar useNative = hasNative;\r\n\r\nisIE = /Trident/.test(navigator.userAgent);\r\n\r\n// TODO(sorvell): SD polyfill intrusion\r\nvar hasShadowDOMPolyfill = Boolean(window.ShadowDOMPolyfill);\r\nvar wrap = function(node) {\r\n  return hasShadowDOMPolyfill ? ShadowDOMPolyfill.wrapIfNeeded(node) : node;\r\n};\r\nvar mainDoc = wrap(document);\r\n    \r\n// NOTE: We cannot polyfill document.currentScript because it's not possible\r\n// both to override and maintain the ability to capture the native value;\r\n// therefore we choose to expose _currentScript both when native imports\r\n// and the polyfill are in use.\r\nvar currentScriptDescriptor = {\r\n  get: function() {\r\n    var script = HTMLImports.currentScript || document.currentScript ||\r\n        // NOTE: only works when called in synchronously executing code.\r\n        // readyState should check if `loading` but IE10 is \r\n        // interactive when scripts run so we cheat.\r\n        (document.readyState !== 'complete' ? \r\n        document.scripts[document.scripts.length - 1] : null);\r\n    return wrap(script);\r\n  },\r\n  configurable: true\r\n};\r\n\r\nObject.defineProperty(document, '_currentScript', currentScriptDescriptor);\r\nObject.defineProperty(mainDoc, '_currentScript', currentScriptDescriptor);\r\n\r\n// call a callback when all HTMLImports in the document at call (or at least\r\n//  document ready) time have loaded.\r\n// 1. ensure the document is in a ready state (has dom), then \r\n// 2. watch for loading of imports and call callback when done\r\nfunction whenImportsReady(callback, doc) {\r\n  doc = doc || mainDoc;\r\n  // if document is loading, wait and try again\r\n  whenDocumentReady(function() {\r\n    watchImportsLoad(callback, doc);\r\n  }, doc);\r\n}\r\n\r\n// call the callback when the document is in a ready state (has dom)\r\nvar requiredReadyState = isIE ? 'complete' : 'interactive';\r\nvar READY_EVENT = 'readystatechange';\r\nfunction isDocumentReady(doc) {\r\n  return (doc.readyState === 'complete' ||\r\n      doc.readyState === requiredReadyState);\r\n}\r\n\r\n// call <callback> when we ensure the document is in a ready state\r\nfunction whenDocumentReady(callback, doc) {\r\n  if (!isDocumentReady(doc)) {\r\n    var checkReady = function() {\r\n      if (doc.readyState === 'complete' || \r\n          doc.readyState === requiredReadyState) {\r\n        doc.removeEventListener(READY_EVENT, checkReady);\r\n        whenDocumentReady(callback, doc);\r\n      }\r\n    };\r\n    doc.addEventListener(READY_EVENT, checkReady);\r\n  } else if (callback) {\r\n    callback();\r\n  }\r\n}\r\n\r\nfunction markTargetLoaded(event) {\r\n  event.target.__loaded = true;\r\n}\r\n\r\n// call <callback> when we ensure all imports have loaded\r\nfunction watchImportsLoad(callback, doc) {\r\n  var imports = doc.querySelectorAll('link[rel=import]');\r\n  var loaded = 0, l = imports.length;\r\n  function checkDone(d) { \r\n    if (loaded == l) {\r\n      callback && callback();\r\n    }\r\n  }\r\n  function loadedImport(e) {\r\n    markTargetLoaded(e);\r\n    loaded++;\r\n    checkDone();\r\n  }\r\n  if (l) {\r\n    for (var i=0, imp; (i<l) && (imp=imports[i]); i++) {\r\n      if (isImportLoaded(imp)) {\r\n        loadedImport.call(imp, {target: imp});\r\n      } else {\r\n        imp.addEventListener('load', loadedImport);\r\n        imp.addEventListener('error', loadedImport);\r\n      }\r\n    }\r\n  } else {\r\n    checkDone();\r\n  }\r\n}\r\n\r\n// NOTE: test for native imports loading is based on explicitly watching\r\n// all imports (see below).\r\nfunction isImportLoaded(link) {\r\n  return useNative ? link.__loaded : link.__importParsed;\r\n}\r\n\r\n// TODO(sorvell): Workaround for \r\n// https://www.w3.org/Bugs/Public/show_bug.cgi?id=25007, should be removed when\r\n// this bug is addressed.\r\n// (1) Install a mutation observer to see when HTMLImports have loaded\r\n// (2) if this script is run during document load it will watch any existing\r\n// imports for loading.\r\n//\r\n// NOTE: The workaround has restricted functionality: (1) it's only compatible\r\n// with imports that are added to document.head since the mutation observer \r\n// watches only head for perf reasons, (2) it requires this script\r\n// to run before any imports have completed loading.\r\nif (useNative) {\r\n  new MutationObserver(function(mxns) {\r\n    for (var i=0, l=mxns.length, m; (i < l) && (m=mxns[i]); i++) {\r\n      if (m.addedNodes) {\r\n        handleImports(m.addedNodes);\r\n      }\r\n    }\r\n  }).observe(document.head, {childList: true});\r\n\r\n  function handleImports(nodes) {\r\n    for (var i=0, l=nodes.length, n; (i<l) && (n=nodes[i]); i++) {\r\n      if (isImport(n)) {\r\n        handleImport(n);  \r\n      }\r\n    }\r\n  }\r\n\r\n  function isImport(element) {\r\n    return element.localName === 'link' && element.rel === 'import';\r\n  }\r\n\r\n  function handleImport(element) {\r\n    var loaded = element.import;\r\n    if (loaded) {\r\n      markTargetLoaded({target: element});\r\n    } else {\r\n      element.addEventListener('load', markTargetLoaded);\r\n      element.addEventListener('error', markTargetLoaded);\r\n    }\r\n  }\r\n\r\n  // make sure to catch any imports that are in the process of loading\r\n  // when this script is run.\r\n  (function() {\r\n    if (document.readyState === 'loading') {\r\n      var imports = document.querySelectorAll('link[rel=import]');\r\n      for (var i=0, l=imports.length, imp; (i<l) && (imp=imports[i]); i++) {\r\n        handleImport(imp);\r\n      }\r\n    }\r\n  })();\r\n\r\n}\r\n\r\n// Fire the 'HTMLImportsLoaded' event when imports in document at load time \r\n// have loaded. This event is required to simulate the script blocking \r\n// behavior of native imports. A main document script that needs to be sure\r\n// imports have loaded should wait for this event.\r\nwhenImportsReady(function() {\r\n  HTMLImports.ready = true;\r\n  HTMLImports.readyTime = new Date().getTime();\r\n  mainDoc.dispatchEvent(\r\n    new CustomEvent('HTMLImportsLoaded', {bubbles: true})\r\n  );\r\n});\r\n\r\n// exports\r\nscope.useNative = useNative;\r\nscope.isImportLoaded = isImportLoaded;\r\nscope.whenReady = whenImportsReady;\r\nscope.isIE = isIE;\r\n\r\n// deprecated\r\nscope.whenImportsReady = whenImportsReady;\r\n\r\n})(window.HTMLImports);","/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n(function(scope) {\n\n  // imports\n  var path = scope.path;\n  var xhr = scope.xhr;\n  var flags = scope.flags;\n\n  // TODO(sorvell): this loader supports a dynamic list of urls\n  // and an oncomplete callback that is called when the loader is done.\n  // The polyfill currently does *not* need this dynamism or the onComplete\n  // concept. Because of this, the loader could be simplified quite a bit.\n  var Loader = function(onLoad, onComplete) {\n    this.cache = {};\n    this.onload = onLoad;\n    this.oncomplete = onComplete;\n    this.inflight = 0;\n    this.pending = {};\n  };\n\n  Loader.prototype = {\n    addNodes: function(nodes) {\n      // number of transactions to complete\n      this.inflight += nodes.length;\n      // commence transactions\n      for (var i=0, l=nodes.length, n; (i<l) && (n=nodes[i]); i++) {\n        this.require(n);\n      }\n      // anything to do?\n      this.checkDone();\n    },\n    addNode: function(node) {\n      // number of transactions to complete\n      this.inflight++;\n      // commence transactions\n      this.require(node);\n      // anything to do?\n      this.checkDone();\n    },\n    require: function(elt) {\n      var url = elt.src || elt.href;\n      // ensure we have a standard url that can be used\n      // reliably for deduping.\n      // TODO(sjmiles): ad-hoc\n      elt.__nodeUrl = url;\n      // deduplication\n      if (!this.dedupe(url, elt)) {\n        // fetch this resource\n        this.fetch(url, elt);\n      }\n    },\n    dedupe: function(url, elt) {\n      if (this.pending[url]) {\n        // add to list of nodes waiting for inUrl\n        this.pending[url].push(elt);\n        // don't need fetch\n        return true;\n      }\n      var resource;\n      if (this.cache[url]) {\n        this.onload(url, elt, this.cache[url]);\n        // finished this transaction\n        this.tail();\n        // don't need fetch\n        return true;\n      }\n      // first node waiting for inUrl\n      this.pending[url] = [elt];\n      // need fetch (not a dupe)\n      return false;\n    },\n    fetch: function(url, elt) {\n      flags.load && console.log('fetch', url, elt);\n      if (url.match(/^data:/)) {\n        // Handle Data URI Scheme\n        var pieces = url.split(',');\n        var header = pieces[0];\n        var body = pieces[1];\n        if(header.indexOf(';base64') > -1) {\n          body = atob(body);\n        } else {\n          body = decodeURIComponent(body);\n        }\n        setTimeout(function() {\n            this.receive(url, elt, null, body);\n        }.bind(this), 0);\n      } else {\n        var receiveXhr = function(err, resource, redirectedUrl) {\n          this.receive(url, elt, err, resource, redirectedUrl);\n        }.bind(this);\n        xhr.load(url, receiveXhr);\n        // TODO(sorvell): blocked on)\n        // https://code.google.com/p/chromium/issues/detail?id=257221\n        // xhr'ing for a document makes scripts in imports runnable; otherwise\n        // they are not; however, it requires that we have doctype=html in\n        // the import which is unacceptable. This is only needed on Chrome\n        // to avoid the bug above.\n        /*\n        if (isDocumentLink(elt)) {\n          xhr.loadDocument(url, receiveXhr);\n        } else {\n          xhr.load(url, receiveXhr);\n        }\n        */\n      }\n    },\n    receive: function(url, elt, err, resource, redirectedUrl) {\n      this.cache[url] = resource;\n      var $p = this.pending[url];\n      for (var i=0, l=$p.length, p; (i<l) && (p=$p[i]); i++) {\n        // If url was redirected, use the redirected location so paths are\n        // calculated relative to that.\n        this.onload(url, p, resource, err, redirectedUrl);\n        this.tail();\n      }\n      this.pending[url] = null;\n    },\n    tail: function() {\n      --this.inflight;\n      this.checkDone();\n    },\n    checkDone: function() {\n      if (!this.inflight) {\n        this.oncomplete();\n      }\n    }\n  };\n\n  xhr = xhr || {\n    async: true,\n    ok: function(request) {\n      return (request.status >= 200 && request.status < 300)\n          || (request.status === 304)\n          || (request.status === 0);\n    },\n    load: function(url, next, nextContext) {\n      var request = new XMLHttpRequest();\n      if (scope.flags.debug || scope.flags.bust) {\n        url += '?' + Math.random();\n      }\n      request.open('GET', url, xhr.async);\n      request.addEventListener('readystatechange', function(e) {\n        if (request.readyState === 4) {\n          // Servers redirecting an import can add a Location header to help us\n          // polyfill correctly.\n          var locationHeader = request.getResponseHeader(\"Location\");\n          var redirectedUrl = null;\n          if (locationHeader) {\n            var redirectedUrl = (locationHeader.substr( 0, 1 ) === \"/\")\n              ? location.origin + locationHeader  // Location is a relative path\n              : locationHeader;                    // Full path\n          }\n          next.call(nextContext, !xhr.ok(request) && request,\n              request.response || request.responseText, redirectedUrl);\n        }\n      });\n      request.send();\n      return request;\n    },\n    loadDocument: function(url, next, nextContext) {\n      this.load(url, next, nextContext).responseType = 'document';\n    }\n  };\n\n  // exports\n  scope.xhr = xhr;\n  scope.Loader = Loader;\n\n})(window.HTMLImports);\n","/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n(function(scope) {\n\nvar IMPORT_LINK_TYPE = 'import';\nvar flags = scope.flags;\nvar isIE = scope.isIE;\n// TODO(sorvell): SD polyfill intrusion\nvar mainDoc = window.ShadowDOMPolyfill ? \n    window.ShadowDOMPolyfill.wrapIfNeeded(document) : document;\n\n// importParser\n// highlander object to manage parsing of imports\n// parses import related elements\n// and ensures proper parse order\n// parse order is enforced by crawling the tree and monitoring which elements\n// have been parsed; async parsing is also supported.\n\n// highlander object for parsing a document tree\nvar importParser = {\n  // parse selectors for main document elements\n  documentSelectors: 'link[rel=' + IMPORT_LINK_TYPE + ']',\n  // parse selectors for import document elements\n  importsSelectors: [\n    'link[rel=' + IMPORT_LINK_TYPE + ']',\n    'link[rel=stylesheet]',\n    'style',\n    'script:not([type])',\n    'script[type=\"text/javascript\"]'\n  ].join(','),\n  map: {\n    link: 'parseLink',\n    script: 'parseScript',\n    style: 'parseStyle'\n  },\n  // try to parse the next import in the tree\n  parseNext: function() {\n    var next = this.nextToParse();\n    if (next) {\n      this.parse(next);\n    }\n  },\n  parse: function(elt) {\n    if (this.isParsed(elt)) {\n      flags.parse && console.log('[%s] is already parsed', elt.localName);\n      return;\n    }\n    var fn = this[this.map[elt.localName]];\n    if (fn) {\n      this.markParsing(elt);\n      fn.call(this, elt);\n    }\n  },\n  // only 1 element may be parsed at a time; parsing is async so each\n  // parsing implementation must inform the system that parsing is complete\n  // via markParsingComplete.\n  // To prompt the system to parse the next element, parseNext should then be\n  // called.\n  // Note, parseNext used to be included at the end of markParsingComplete, but\n  // we must not do this so that, for example, we can (1) mark parsing complete \n  // then (2) fire an import load event, and then (3) parse the next resource.\n  markParsing: function(elt) {\n    flags.parse && console.log('parsing', elt);\n    this.parsingElement = elt;\n  },\n  markParsingComplete: function(elt) {\n    elt.__importParsed = true;\n    if (elt.__importElement) {\n      elt.__importElement.__importParsed = true;\n    }\n    this.parsingElement = null;\n    flags.parse && console.log('completed', elt);\n  },\n  invalidateParse: function(doc) {\n    if (doc && doc.__importLink) {\n      doc.__importParsed = doc.__importLink.__importParsed = false;\n      this.parseSoon();\n    }\n  },\n  parseSoon: function() {\n    if (this._parseSoon) {\n      cancelAnimationFrame(this._parseDelay);\n    }\n    var parser = this;\n    this._parseSoon = requestAnimationFrame(function() {\n      parser.parseNext();\n    });\n  },\n  parseImport: function(elt) {\n    // TODO(sorvell): consider if there's a better way to do this;\n    // expose an imports parsing hook; this is needed, for example, by the\n    // CustomElements polyfill.\n    if (HTMLImports.__importsParsingHook) {\n      HTMLImports.__importsParsingHook(elt);\n    }\n    if (elt.import) {\n      elt.import.__importParsed = true;\n    }\n    this.markParsingComplete(elt);\n    // fire load event\n    if (elt.__resource && !elt.__error) {\n      elt.dispatchEvent(new CustomEvent('load', {bubbles: false}));    \n    } else {\n      elt.dispatchEvent(new CustomEvent('error', {bubbles: false}));\n    }\n    // TODO(sorvell): workaround for Safari addEventListener not working\n    // for elements not in the main document.\n    if (elt.__pending) {\n      var fn;\n      while (elt.__pending.length) {\n        fn = elt.__pending.shift();\n        if (fn) {\n          fn({target: elt});\n        }\n      }\n    }\n    this.parseNext();\n  },\n  parseLink: function(linkElt) {\n    if (nodeIsImport(linkElt)) {\n      this.parseImport(linkElt);\n    } else {\n      // make href absolute\n      linkElt.href = linkElt.href;\n      this.parseGeneric(linkElt);\n    }\n  },\n  parseStyle: function(elt) {\n    // TODO(sorvell): style element load event can just not fire so clone styles\n    var src = elt;\n    elt = cloneStyle(elt);\n    elt.__importElement = src;\n    this.parseGeneric(elt);\n  },\n  parseGeneric: function(elt) {\n    this.trackElement(elt);\n    this.addElementToDocument(elt);\n  },\n  rootImportForElement: function(elt) {\n    var n = elt;\n    while (n.ownerDocument.__importLink) {\n      n = n.ownerDocument.__importLink;\n    }\n    return n;\n  },\n  addElementToDocument: function(elt) {\n    var port = this.rootImportForElement(elt.__importElement || elt);\n    var l = port.__insertedElements = port.__insertedElements || 0;\n    var refNode = port.nextElementSibling;\n    for (var i=0; i < l; i++) {\n      refNode = refNode && refNode.nextElementSibling;\n    }\n    port.parentNode.insertBefore(elt, refNode);\n  },\n  // tracks when a loadable element has loaded\n  trackElement: function(elt, callback) {\n    var self = this;\n    var done = function(e) {\n      if (callback) {\n        callback(e);\n      }\n      self.markParsingComplete(elt);\n      self.parseNext();\n    };\n    elt.addEventListener('load', done);\n    elt.addEventListener('error', done);\n\n    // NOTE: IE does not fire \"load\" event for styles that have already loaded\n    // This is in violation of the spec, so we try our hardest to work around it\n    if (isIE && elt.localName === 'style') {\n      var fakeLoad = false;\n      // If there's not @import in the textContent, assume it has loaded\n      if (elt.textContent.indexOf('@import') == -1) {\n        fakeLoad = true;\n      // if we have a sheet, we have been parsed\n      } else if (elt.sheet) {\n        fakeLoad = true;\n        var csr = elt.sheet.cssRules;\n        var len = csr ? csr.length : 0;\n        // search the rules for @import's\n        for (var i = 0, r; (i < len) && (r = csr[i]); i++) {\n          if (r.type === CSSRule.IMPORT_RULE) {\n            // if every @import has resolved, fake the load\n            fakeLoad = fakeLoad && Boolean(r.styleSheet);\n          }\n        }\n      }\n      // dispatch a fake load event and continue parsing\n      if (fakeLoad) {\n        elt.dispatchEvent(new CustomEvent('load', {bubbles: false}));\n      }\n    }\n  },\n  // NOTE: execute scripts by injecting them and watching for the load/error\n  // event. Inline scripts are handled via dataURL's because browsers tend to\n  // provide correct parsing errors in this case. If this has any compatibility\n  // issues, we can switch to injecting the inline script with textContent.\n  // Scripts with dataURL's do not appear to generate load events and therefore\n  // we assume they execute synchronously.\n  parseScript: function(scriptElt) {\n    var script = document.createElement('script');\n    script.__importElement = scriptElt;\n    script.src = scriptElt.src ? scriptElt.src : \n        generateScriptDataUrl(scriptElt);\n    scope.currentScript = scriptElt;\n    this.trackElement(script, function(e) {\n      script.parentNode.removeChild(script);\n      scope.currentScript = null;  \n    });\n    this.addElementToDocument(script);\n  },\n  // determine the next element in the tree which should be parsed\n  nextToParse: function() {\n    return !this.parsingElement && this.nextToParseInDoc(mainDoc);\n  },\n  nextToParseInDoc: function(doc, link) {\n    if (doc) {\n      var nodes = doc.querySelectorAll(this.parseSelectorsForNode(doc));\n      for (var i=0, l=nodes.length, p=0, n; (i<l) && (n=nodes[i]); i++) {\n        if (!this.isParsed(n)) {\n          if (this.hasResource(n)) {\n            return nodeIsImport(n) ? this.nextToParseInDoc(n.import, n) : n;\n          } else {\n            return;\n          }\n        }\n      }\n    }\n    // all nodes have been parsed, ready to parse import, if any\n    return link;\n  },\n  // return the set of parse selectors relevant for this node.\n  parseSelectorsForNode: function(node) {\n    var doc = node.ownerDocument || node;\n    return doc === mainDoc ? this.documentSelectors : this.importsSelectors;\n  },\n  isParsed: function(node) {\n    return node.__importParsed;\n  },\n  hasResource: function(node) {\n    if (nodeIsImport(node) && (node.import === undefined)) {\n      return false;\n    }\n    return true;\n  }\n};\n\nfunction nodeIsImport(elt) {\n  return (elt.localName === 'link') && (elt.rel === IMPORT_LINK_TYPE);\n}\n\nfunction generateScriptDataUrl(script) {\n  var scriptContent = generateScriptContent(script);\n  return 'data:text/javascript;charset=utf-8,' + encodeURIComponent(scriptContent);\n}\n\nfunction generateScriptContent(script) {\n  return script.textContent + generateSourceMapHint(script);\n}\n\n// calculate source map hint\nfunction generateSourceMapHint(script) {\n  var moniker = script.__nodeUrl;\n  if (!moniker) {\n    moniker = script.ownerDocument.baseURI;\n    // there could be more than one script this url\n    var tag = '[' + Math.floor((Math.random()+1)*1000) + ']';\n    // TODO(sjmiles): Polymer hack, should be pluggable if we need to allow \n    // this sort of thing\n    var matches = script.textContent.match(/Polymer\\(['\"]([^'\"]*)/);\n    tag = matches && matches[1] || tag;\n    // tag the moniker\n    moniker += '/' + tag + '.js';\n  }\n  return '\\n//# sourceURL=' + moniker + '\\n';\n}\n\n// style/stylesheet handling\n\n// clone style with proper path resolution for main document\n// NOTE: styles are the only elements that require direct path fixup.\nfunction cloneStyle(style) {\n  var clone = style.ownerDocument.createElement('style');\n  clone.textContent = style.textContent;\n  path.resolveUrlsInStyle(clone);\n  return clone;\n}\n\n// path fixup: style elements in imports must be made relative to the main \n// document. We fixup url's in url() and @import.\nvar CSS_URL_REGEXP = /(url\\()([^)]*)(\\))/g;\nvar CSS_IMPORT_REGEXP = /(@import[\\s]+(?!url\\())([^;]*)(;)/g;\n\nvar path = {\n  resolveUrlsInStyle: function(style) {\n    var doc = style.ownerDocument;\n    var resolver = doc.createElement('a');\n    style.textContent = this.resolveUrlsInCssText(style.textContent, resolver);\n    return style;  \n  },\n  resolveUrlsInCssText: function(cssText, urlObj) {\n    var r = this.replaceUrls(cssText, urlObj, CSS_URL_REGEXP);\n    r = this.replaceUrls(r, urlObj, CSS_IMPORT_REGEXP);\n    return r;\n  },\n  replaceUrls: function(text, urlObj, regexp) {\n    return text.replace(regexp, function(m, pre, url, post) {\n      var urlPath = url.replace(/[\"']/g, '');\n      urlObj.href = urlPath;\n      urlPath = urlObj.href;\n      return pre + '\\'' + urlPath + '\\'' + post;\n    });    \n  }\n}\n\n// exports\nscope.parser = importParser;\nscope.path = path;\n\n})(HTMLImports);\n","/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n (function(scope) {\n\nvar useNative = scope.useNative;\nvar flags = scope.flags;\nvar IMPORT_LINK_TYPE = 'import';\n\n// TODO(sorvell): SD polyfill intrusion\nvar mainDoc = window.ShadowDOMPolyfill ? \n    ShadowDOMPolyfill.wrapIfNeeded(document) : document;\n\nif (!useNative) {\n\n  // imports\n  var xhr = scope.xhr;\n  var Loader = scope.Loader;\n  var parser = scope.parser;\n\n  // importer\n  // highlander object to manage loading of imports\n\n  // for any document, importer:\n  // - loads any linked import documents (with deduping)\n\n  var importer = {\n    documents: {},\n    // nodes to load in the mian document\n    documentPreloadSelectors: 'link[rel=' + IMPORT_LINK_TYPE + ']',\n    // nodes to load in imports\n    importsPreloadSelectors: [\n      'link[rel=' + IMPORT_LINK_TYPE + ']'\n    ].join(','),\n    loadNode: function(node) {\n      importLoader.addNode(node);\n    },\n    // load all loadable elements within the parent element\n    loadSubtree: function(parent) {\n      var nodes = this.marshalNodes(parent);\n      // add these nodes to loader's queue\n      importLoader.addNodes(nodes);\n    },\n    marshalNodes: function(parent) {\n      // all preloadable nodes in inDocument\n      return parent.querySelectorAll(this.loadSelectorsForNode(parent));\n    },\n    // find the proper set of load selectors for a given node\n    loadSelectorsForNode: function(node) {\n      var doc = node.ownerDocument || node;\n      return doc === mainDoc ? this.documentPreloadSelectors :\n          this.importsPreloadSelectors;\n    },\n    loaded: function(url, elt, resource, err, redirectedUrl) {\n      flags.load && console.log('loaded', url, elt);\n      // store generic resource\n      // TODO(sorvell): fails for nodes inside <template>.content\n      // see https://code.google.com/p/chromium/issues/detail?id=249381.\n      elt.__resource = resource;\n      elt.__error = err;\n      if (isDocumentLink(elt)) {\n        var doc = this.documents[url];\n        // if we've never seen a document at this url\n        if (doc === undefined) {\n          // generate an HTMLDocument from data\n          doc = err ? null : makeDocument(resource, redirectedUrl || url);\n          if (doc) {\n            doc.__importLink = elt;\n            // note, we cannot use MO to detect parsed nodes because\n            // SD polyfill does not report these as mutations.\n            this.bootDocument(doc);\n          }\n          // cache document\n          this.documents[url] = doc;\n        }\n        // don't store import record until we're actually loaded\n        // store document resource\n        elt.import = doc;\n      }\n      parser.parseNext();\n    },\n    bootDocument: function(doc) {\n      this.loadSubtree(doc);\n      this.observe(doc);\n      parser.parseNext();\n    },\n    loadedAll: function() {\n      parser.parseNext();\n    }\n  };\n\n  // loader singleton\n  var importLoader = new Loader(importer.loaded.bind(importer), \n      importer.loadedAll.bind(importer));\n\n  function isDocumentLink(elt) {\n    return isLinkRel(elt, IMPORT_LINK_TYPE);\n  }\n\n  function isLinkRel(elt, rel) {\n    return elt.localName === 'link' && elt.getAttribute('rel') === rel;\n  }\n\n  function isScript(elt) {\n    return elt.localName === 'script';\n  }\n\n  function makeDocument(resource, url) {\n    // create a new HTML document\n    var doc = resource;\n    if (!(doc instanceof Document)) {\n      doc = document.implementation.createHTMLDocument(IMPORT_LINK_TYPE);\n    }\n    // cache the new document's source url\n    doc._URL = url;\n    // establish a relative path via <base>\n    var base = doc.createElement('base');\n    base.setAttribute('href', url);\n    // add baseURI support to browsers (IE) that lack it.\n    if (!doc.baseURI) {\n      doc.baseURI = url;\n    }\n    // ensure UTF-8 charset\n    var meta = doc.createElement('meta');\n    meta.setAttribute('charset', 'utf-8');\n\n    doc.head.appendChild(meta);\n    doc.head.appendChild(base);\n    // install HTML last as it may trigger CustomElement upgrades\n    // TODO(sjmiles): problem wrt to template boostrapping below,\n    // template bootstrapping must (?) come before element upgrade\n    // but we cannot bootstrap templates until they are in a document\n    // which is too late\n    if (!(resource instanceof Document)) {\n      // install html\n      doc.body.innerHTML = resource;\n    }\n    // TODO(sorvell): ideally this code is not aware of Template polyfill,\n    // but for now the polyfill needs help to bootstrap these templates\n    if (window.HTMLTemplateElement && HTMLTemplateElement.bootstrap) {\n      HTMLTemplateElement.bootstrap(doc);\n    }\n    return doc;\n  }\n\n  // Polyfill document.baseURI for browsers without it.\n  if (!document.baseURI) {\n    var baseURIDescriptor = {\n      get: function() {\n        var base = document.querySelector('base');\n        return base ? base.href : window.location.href;\n      },\n      configurable: true\n    };\n\n    Object.defineProperty(document, 'baseURI', baseURIDescriptor);\n    Object.defineProperty(mainDoc, 'baseURI', baseURIDescriptor);\n  }\n\n  // IE shim for CustomEvent\n  if (typeof window.CustomEvent !== 'function') {\n    window.CustomEvent = function(inType, dictionary) {\n       var e = document.createEvent('HTMLEvents');\n       e.initEvent(inType,\n          dictionary.bubbles === false ? false : true,\n          dictionary.cancelable === false ? false : true,\n          dictionary.detail);\n       return e;\n    };\n  }\n\n} else {\n  // do nothing if using native imports\n  var importer = {};\n}\n\n// exports\nscope.importer = importer;\nscope.IMPORT_LINK_TYPE = IMPORT_LINK_TYPE;\nscope.importLoader = importLoader;\n\n\n})(window.HTMLImports);\n","/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n(function(scope){\n\nvar IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;\nvar importSelector = 'link[rel=' + IMPORT_LINK_TYPE + ']';\nvar importer = scope.importer;\nvar parser = scope.parser;\n\n// we track mutations for addedNodes, looking for imports\nfunction handler(mutations) {\n  for (var i=0, l=mutations.length, m; (i<l) && (m=mutations[i]); i++) {\n    if (m.type === 'childList' && m.addedNodes.length) {\n      addedNodes(m.addedNodes);\n    }\n  }\n}\n\n// find loadable elements and add them to the importer\nfunction addedNodes(nodes) {\n  var owner;\n  for (var i=0, l=nodes.length, n; (i<l) && (n=nodes[i]); i++) {\n    owner = owner || n.ownerDocument;\n    if (shouldLoadNode(n)) {\n      importer.loadNode(n);\n    }\n    if (n.children && n.children.length) {\n      addedNodes(n.children);\n    }\n  }\n  // TODO(sorvell): This is not the right approach here. We shouldn't need to\n  // invalidate parsing when an element is added. Disabling this code \n  // until a better approach is found.\n  /*\n  if (owner) {\n    parser.invalidateParse(owner);\n  }\n  */\n}\n\nfunction shouldLoadNode(node) {\n  return (node.nodeType === 1) && matches.call(node,\n      importer.loadSelectorsForNode(node));\n}\n\n// x-plat matches\nvar matches = HTMLElement.prototype.matches || \n    HTMLElement.prototype.matchesSelector || \n    HTMLElement.prototype.webkitMatchesSelector ||\n    HTMLElement.prototype.mozMatchesSelector ||\n    HTMLElement.prototype.msMatchesSelector;\n\nvar observer = new MutationObserver(handler);\n\n// observe the given root for loadable elements\nfunction observe(root) {\n  observer.observe(root, {childList: true, subtree: true});\n}\n\n// exports\n// TODO(sorvell): factor so can put on scope\nscope.observe = observe;\nimporter.observe = observe;\n\n})(HTMLImports);\n","/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n(function(){\n\n// bootstrap\n\n// TODO(sorvell): SD polyfill intrusion\nvar doc = window.ShadowDOMPolyfill ? \n    window.ShadowDOMPolyfill.wrapIfNeeded(document) : document;\n\n// no need to bootstrap the polyfill when native imports is available.\nif (!HTMLImports.useNative) {\n  function bootstrap() {\n    HTMLImports.importer.bootDocument(doc);\n  }\n    \n  // TODO(sorvell): SD polyfill does *not* generate mutations for nodes added\n  // by the parser. For this reason, we must wait until the dom exists to \n  // bootstrap.\n  if (document.readyState === 'complete' ||\n      (document.readyState === 'interactive' && !window.attachEvent)) {\n    bootstrap();\n  } else {\n    document.addEventListener('DOMContentLoaded', bootstrap);\n  }\n}\n\n})();\n","/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\nwindow.CustomElements = window.CustomElements || {flags:{}};","/*\r\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n */\r\n\r\n(function(scope){\r\n\r\nvar logFlags = window.logFlags || {};\r\nvar IMPORT_LINK_TYPE = window.HTMLImports ? HTMLImports.IMPORT_LINK_TYPE : 'none';\r\n\r\n// walk the subtree rooted at node, applying 'find(element, data)' function\r\n// to each element\r\n// if 'find' returns true for 'element', do not search element's subtree\r\nfunction findAll(node, find, data) {\r\n  var e = node.firstElementChild;\r\n  if (!e) {\r\n    e = node.firstChild;\r\n    while (e && e.nodeType !== Node.ELEMENT_NODE) {\r\n      e = e.nextSibling;\r\n    }\r\n  }\r\n  while (e) {\r\n    if (find(e, data) !== true) {\r\n      findAll(e, find, data);\r\n    }\r\n    e = e.nextElementSibling;\r\n  }\r\n  return null;\r\n}\r\n\r\n// walk all shadowRoots on a given node.\r\nfunction forRoots(node, cb) {\r\n  var root = node.shadowRoot;\r\n  while(root) {\r\n    forSubtree(root, cb);\r\n    root = root.olderShadowRoot;\r\n  }\r\n}\r\n\r\n// walk the subtree rooted at node, including descent into shadow-roots,\r\n// applying 'cb' to each element\r\nfunction forSubtree(node, cb) {\r\n  //logFlags.dom && node.childNodes && node.childNodes.length && console.group('subTree: ', node);\r\n  findAll(node, function(e) {\r\n    if (cb(e)) {\r\n      return true;\r\n    }\r\n    forRoots(e, cb);\r\n  });\r\n  forRoots(node, cb);\r\n  //logFlags.dom && node.childNodes && node.childNodes.length && console.groupEnd();\r\n}\r\n\r\n// manage lifecycle on added node\r\nfunction added(node) {\r\n  if (upgrade(node)) {\r\n    insertedNode(node);\r\n    return true;\r\n  }\r\n  inserted(node);\r\n}\r\n\r\n// manage lifecycle on added node's subtree only\r\nfunction addedSubtree(node) {\r\n  forSubtree(node, function(e) {\r\n    if (added(e)) {\r\n      return true;\r\n    }\r\n  });\r\n}\r\n\r\n// manage lifecycle on added node and it's subtree\r\nfunction addedNode(node) {\r\n  return added(node) || addedSubtree(node);\r\n}\r\n\r\n// upgrade custom elements at node, if applicable\r\nfunction upgrade(node) {\r\n  if (!node.__upgraded__ && node.nodeType === Node.ELEMENT_NODE) {\r\n    var type = node.getAttribute('is') || node.localName;\r\n    var definition = scope.registry[type];\r\n    if (definition) {\r\n      logFlags.dom && console.group('upgrade:', node.localName);\r\n      scope.upgrade(node);\r\n      logFlags.dom && console.groupEnd();\r\n      return true;\r\n    }\r\n  }\r\n}\r\n\r\nfunction insertedNode(node) {\r\n  inserted(node);\r\n  if (inDocument(node)) {\r\n    forSubtree(node, function(e) {\r\n      inserted(e);\r\n    });\r\n  }\r\n}\r\n\r\n// TODO(sorvell): on platforms without MutationObserver, mutations may not be\r\n// reliable and therefore attached/detached are not reliable.\r\n// To make these callbacks less likely to fail, we defer all inserts and removes\r\n// to give a chance for elements to be inserted into dom.\r\n// This ensures attachedCallback fires for elements that are created and\r\n// immediately added to dom.\r\nvar hasPolyfillMutations = (!window.MutationObserver ||\r\n    (window.MutationObserver === window.JsMutationObserver));\r\nscope.hasPolyfillMutations = hasPolyfillMutations;\r\n\r\nvar isPendingMutations = false;\r\nvar pendingMutations = [];\r\nfunction deferMutation(fn) {\r\n  pendingMutations.push(fn);\r\n  if (!isPendingMutations) {\r\n    isPendingMutations = true;\r\n    var async = (window.Platform && window.Platform.endOfMicrotask) ||\r\n        setTimeout;\r\n    async(takeMutations);\r\n  }\r\n}\r\n\r\nfunction takeMutations() {\r\n  isPendingMutations = false;\r\n  var $p = pendingMutations;\r\n  for (var i=0, l=$p.length, p; (i<l) && (p=$p[i]); i++) {\r\n    p();\r\n  }\r\n  pendingMutations = [];\r\n}\r\n\r\nfunction inserted(element) {\r\n  if (hasPolyfillMutations) {\r\n    deferMutation(function() {\r\n      _inserted(element);\r\n    });\r\n  } else {\r\n    _inserted(element);\r\n  }\r\n}\r\n\r\n// TODO(sjmiles): if there are descents into trees that can never have inDocument(*) true, fix this\r\nfunction _inserted(element) {\r\n  // TODO(sjmiles): it's possible we were inserted and removed in the space\r\n  // of one microtask, in which case we won't be 'inDocument' here\r\n  // But there are other cases where we are testing for inserted without\r\n  // specific knowledge of mutations, and must test 'inDocument' to determine\r\n  // whether to call inserted\r\n  // If we can factor these cases into separate code paths we can have\r\n  // better diagnostics.\r\n  // TODO(sjmiles): when logging, do work on all custom elements so we can\r\n  // track behavior even when callbacks not defined\r\n  //console.log('inserted: ', element.localName);\r\n  if (element.attachedCallback || element.detachedCallback || (element.__upgraded__ && logFlags.dom)) {\r\n    logFlags.dom && console.group('inserted:', element.localName);\r\n    if (inDocument(element)) {\r\n      element.__inserted = (element.__inserted || 0) + 1;\r\n      // if we are in a 'removed' state, bluntly adjust to an 'inserted' state\r\n      if (element.__inserted < 1) {\r\n        element.__inserted = 1;\r\n      }\r\n      // if we are 'over inserted', squelch the callback\r\n      if (element.__inserted > 1) {\r\n        logFlags.dom && console.warn('inserted:', element.localName,\r\n          'insert/remove count:', element.__inserted)\r\n      } else if (element.attachedCallback) {\r\n        logFlags.dom && console.log('inserted:', element.localName);\r\n        element.attachedCallback();\r\n      }\r\n    }\r\n    logFlags.dom && console.groupEnd();\r\n  }\r\n}\r\n\r\nfunction removedNode(node) {\r\n  removed(node);\r\n  forSubtree(node, function(e) {\r\n    removed(e);\r\n  });\r\n}\r\n\r\nfunction removed(element) {\r\n  if (hasPolyfillMutations) {\r\n    deferMutation(function() {\r\n      _removed(element);\r\n    });\r\n  } else {\r\n    _removed(element);\r\n  }\r\n}\r\n\r\nfunction _removed(element) {\r\n  // TODO(sjmiles): temporary: do work on all custom elements so we can track\r\n  // behavior even when callbacks not defined\r\n  if (element.attachedCallback || element.detachedCallback || (element.__upgraded__ && logFlags.dom)) {\r\n    logFlags.dom && console.group('removed:', element.localName);\r\n    if (!inDocument(element)) {\r\n      element.__inserted = (element.__inserted || 0) - 1;\r\n      // if we are in a 'inserted' state, bluntly adjust to an 'removed' state\r\n      if (element.__inserted > 0) {\r\n        element.__inserted = 0;\r\n      }\r\n      // if we are 'over removed', squelch the callback\r\n      if (element.__inserted < 0) {\r\n        logFlags.dom && console.warn('removed:', element.localName,\r\n            'insert/remove count:', element.__inserted)\r\n      } else if (element.detachedCallback) {\r\n        element.detachedCallback();\r\n      }\r\n    }\r\n    logFlags.dom && console.groupEnd();\r\n  }\r\n}\r\n\r\n// SD polyfill intrustion due mainly to the fact that 'document'\r\n// is not entirely wrapped\r\nfunction wrapIfNeeded(node) {\r\n  return window.ShadowDOMPolyfill ? ShadowDOMPolyfill.wrapIfNeeded(node)\r\n      : node;\r\n}\r\n\r\nfunction inDocument(element) {\r\n  var p = element;\r\n  var doc = wrapIfNeeded(document);\r\n  while (p) {\r\n    if (p == doc) {\r\n      return true;\r\n    }\r\n    p = p.parentNode || p.host;\r\n  }\r\n}\r\n\r\nfunction watchShadow(node) {\r\n  if (node.shadowRoot && !node.shadowRoot.__watched) {\r\n    logFlags.dom && console.log('watching shadow-root for: ', node.localName);\r\n    // watch all unwatched roots...\r\n    var root = node.shadowRoot;\r\n    while (root) {\r\n      watchRoot(root);\r\n      root = root.olderShadowRoot;\r\n    }\r\n  }\r\n}\r\n\r\nfunction watchRoot(root) {\r\n  if (!root.__watched) {\r\n    observe(root);\r\n    root.__watched = true;\r\n  }\r\n}\r\n\r\nfunction handler(mutations) {\r\n  //\r\n  if (logFlags.dom) {\r\n    var mx = mutations[0];\r\n    if (mx && mx.type === 'childList' && mx.addedNodes) {\r\n        if (mx.addedNodes) {\r\n          var d = mx.addedNodes[0];\r\n          while (d && d !== document && !d.host) {\r\n            d = d.parentNode;\r\n          }\r\n          var u = d && (d.URL || d._URL || (d.host && d.host.localName)) || '';\r\n          u = u.split('/?').shift().split('/').pop();\r\n        }\r\n    }\r\n    console.group('mutations (%d) [%s]', mutations.length, u || '');\r\n  }\r\n  //\r\n  mutations.forEach(function(mx) {\r\n    //logFlags.dom && console.group('mutation');\r\n    if (mx.type === 'childList') {\r\n      forEach(mx.addedNodes, function(n) {\r\n        //logFlags.dom && console.log(n.localName);\r\n        if (!n.localName) {\r\n          return;\r\n        }\r\n        // nodes added may need lifecycle management\r\n        addedNode(n);\r\n      });\r\n      // removed nodes may need lifecycle management\r\n      forEach(mx.removedNodes, function(n) {\r\n        //logFlags.dom && console.log(n.localName);\r\n        if (!n.localName) {\r\n          return;\r\n        }\r\n        removedNode(n);\r\n      });\r\n    }\r\n    //logFlags.dom && console.groupEnd();\r\n  });\r\n  logFlags.dom && console.groupEnd();\r\n};\r\n\r\nvar observer = new MutationObserver(handler);\r\n\r\nfunction takeRecords() {\r\n  // TODO(sjmiles): ask Raf why we have to call handler ourselves\r\n  handler(observer.takeRecords());\r\n  takeMutations();\r\n}\r\n\r\nvar forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);\r\n\r\nfunction observe(inRoot) {\r\n  observer.observe(inRoot, {childList: true, subtree: true});\r\n}\r\n\r\nfunction observeDocument(doc) {\r\n  observe(doc);\r\n}\r\n\r\nfunction upgradeDocument(doc) {\r\n  logFlags.dom && console.group('upgradeDocument: ', (doc.baseURI).split('/').pop());\r\n  addedNode(doc);\r\n  logFlags.dom && console.groupEnd();\r\n}\r\n\r\nfunction upgradeDocumentTree(doc) {\r\n  doc = wrapIfNeeded(doc);\r\n  //console.log('upgradeDocumentTree: ', (doc.baseURI).split('/').pop());\r\n  // upgrade contained imported documents\r\n  var imports = doc.querySelectorAll('link[rel=' + IMPORT_LINK_TYPE + ']');\r\n  for (var i=0, l=imports.length, n; (i<l) && (n=imports[i]); i++) {\r\n    if (n.import && n.import.__parsed) {\r\n      upgradeDocumentTree(n.import);\r\n    }\r\n  }\r\n  upgradeDocument(doc);\r\n}\r\n\r\n// exports\r\nscope.IMPORT_LINK_TYPE = IMPORT_LINK_TYPE;\r\nscope.watchShadow = watchShadow;\r\nscope.upgradeDocumentTree = upgradeDocumentTree;\r\nscope.upgradeAll = addedNode;\r\nscope.upgradeSubtree = addedSubtree;\r\nscope.insertedNode = insertedNode;\r\n\r\nscope.observeDocument = observeDocument;\r\nscope.upgradeDocument = upgradeDocument;\r\n\r\nscope.takeRecords = takeRecords;\r\n\r\n})(window.CustomElements);\r\n","/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * Implements `document.registerElement`\n * @module CustomElements\n*/\n\n/**\n * Polyfilled extensions to the `document` object.\n * @class Document\n*/\n\n(function(scope) {\n\n// imports\n\nif (!scope) {\n  scope = window.CustomElements = {flags:{}};\n}\nvar flags = scope.flags;\n\n// native document.registerElement?\n\nvar hasNative = Boolean(document.registerElement);\n// For consistent timing, use native custom elements only when not polyfilling\n// other key related web components features.\nvar useNative = !flags.register && hasNative && !window.ShadowDOMPolyfill && (!window.HTMLImports || HTMLImports.useNative);\n\nif (useNative) {\n\n  // stub\n  var nop = function() {};\n\n  // exports\n  scope.registry = {};\n  scope.upgradeElement = nop;\n\n  scope.watchShadow = nop;\n  scope.upgrade = nop;\n  scope.upgradeAll = nop;\n  scope.upgradeSubtree = nop;\n  scope.observeDocument = nop;\n  scope.upgradeDocument = nop;\n  scope.upgradeDocumentTree = nop;\n  scope.takeRecords = nop;\n  scope.reservedTagList = [];\n\n} else {\n\n  /**\n   * Registers a custom tag name with the document.\n   *\n   * When a registered element is created, a `readyCallback` method is called\n   * in the scope of the element. The `readyCallback` method can be specified on\n   * either `options.prototype` or `options.lifecycle` with the latter taking\n   * precedence.\n   *\n   * @method register\n   * @param {String} name The tag name to register. Must include a dash ('-'),\n   *    for example 'x-component'.\n   * @param {Object} options\n   *    @param {String} [options.extends]\n   *      (_off spec_) Tag name of an element to extend (or blank for a new\n   *      element). This parameter is not part of the specification, but instead\n   *      is a hint for the polyfill because the extendee is difficult to infer.\n   *      Remember that the input prototype must chain to the extended element's\n   *      prototype (or HTMLElement.prototype) regardless of the value of\n   *      `extends`.\n   *    @param {Object} options.prototype The prototype to use for the new\n   *      element. The prototype must inherit from HTMLElement.\n   *    @param {Object} [options.lifecycle]\n   *      Callbacks that fire at important phases in the life of the custom\n   *      element.\n   *\n   * @example\n   *      FancyButton = document.registerElement(\"fancy-button\", {\n   *        extends: 'button',\n   *        prototype: Object.create(HTMLButtonElement.prototype, {\n   *          readyCallback: {\n   *            value: function() {\n   *              console.log(\"a fancy-button was created\",\n   *            }\n   *          }\n   *        })\n   *      });\n   * @return {Function} Constructor for the newly registered type.\n   */\n  function register(name, options) {\n    //console.warn('document.registerElement(\"' + name + '\", ', options, ')');\n    // construct a defintion out of options\n    // TODO(sjmiles): probably should clone options instead of mutating it\n    var definition = options || {};\n    if (!name) {\n      // TODO(sjmiles): replace with more appropriate error (EricB can probably\n      // offer guidance)\n      throw new Error('document.registerElement: first argument `name` must not be empty');\n    }\n    if (name.indexOf('-') < 0) {\n      // TODO(sjmiles): replace with more appropriate error (EricB can probably\n      // offer guidance)\n      throw new Error('document.registerElement: first argument (\\'name\\') must contain a dash (\\'-\\'). Argument provided was \\'' + String(name) + '\\'.');\n    }\n    // prevent registering reserved names\n    if (isReservedTag(name)) {\n      throw new Error('Failed to execute \\'registerElement\\' on \\'Document\\': Registration failed for type \\'' + String(name) + '\\'. The type name is invalid.');\n    }\n    // elements may only be registered once\n    if (getRegisteredDefinition(name)) {\n      throw new Error('DuplicateDefinitionError: a type with name \\'' + String(name) + '\\' is already registered');\n    }\n    // must have a prototype, default to an extension of HTMLElement\n    // TODO(sjmiles): probably should throw if no prototype, check spec\n    if (!definition.prototype) {\n      // TODO(sjmiles): replace with more appropriate error (EricB can probably\n      // offer guidance)\n      throw new Error('Options missing required prototype property');\n    }\n    // record name\n    definition.__name = name.toLowerCase();\n    // ensure a lifecycle object so we don't have to null test it\n    definition.lifecycle = definition.lifecycle || {};\n    // build a list of ancestral custom elements (for native base detection)\n    // TODO(sjmiles): we used to need to store this, but current code only\n    // uses it in 'resolveTagName': it should probably be inlined\n    definition.ancestry = ancestry(definition.extends);\n    // extensions of native specializations of HTMLElement require localName\n    // to remain native, and use secondary 'is' specifier for extension type\n    resolveTagName(definition);\n    // some platforms require modifications to the user-supplied prototype\n    // chain\n    resolvePrototypeChain(definition);\n    // overrides to implement attributeChanged callback\n    overrideAttributeApi(definition.prototype);\n    // 7.1.5: Register the DEFINITION with DOCUMENT\n    registerDefinition(definition.__name, definition);\n    // 7.1.7. Run custom element constructor generation algorithm with PROTOTYPE\n    // 7.1.8. Return the output of the previous step.\n    definition.ctor = generateConstructor(definition);\n    definition.ctor.prototype = definition.prototype;\n    // force our .constructor to be our actual constructor\n    definition.prototype.constructor = definition.ctor;\n    // if initial parsing is complete\n    if (scope.ready) {\n      // upgrade any pre-existing nodes of this type\n      scope.upgradeDocumentTree(document);\n    }\n    return definition.ctor;\n  }\n\n  function isReservedTag(name) {\n    for (var i = 0; i < reservedTagList.length; i++) {\n      if (name === reservedTagList[i]) {\n        return true;\n      }\n    }\n  }\n\n  var reservedTagList = [\n    'annotation-xml', 'color-profile', 'font-face', 'font-face-src',\n    'font-face-uri', 'font-face-format', 'font-face-name', 'missing-glyph'\n  ];\n\n  function ancestry(extnds) {\n    var extendee = getRegisteredDefinition(extnds);\n    if (extendee) {\n      return ancestry(extendee.extends).concat([extendee]);\n    }\n    return [];\n  }\n\n  function resolveTagName(definition) {\n    // if we are explicitly extending something, that thing is our\n    // baseTag, unless it represents a custom component\n    var baseTag = definition.extends;\n    // if our ancestry includes custom components, we only have a\n    // baseTag if one of them does\n    for (var i=0, a; (a=definition.ancestry[i]); i++) {\n      baseTag = a.is && a.tag;\n    }\n    // our tag is our baseTag, if it exists, and otherwise just our name\n    definition.tag = baseTag || definition.__name;\n    if (baseTag) {\n      // if there is a base tag, use secondary 'is' specifier\n      definition.is = definition.__name;\n    }\n  }\n\n  function resolvePrototypeChain(definition) {\n    // if we don't support __proto__ we need to locate the native level\n    // prototype for precise mixing in\n    if (!Object.__proto__) {\n      // default prototype\n      var nativePrototype = HTMLElement.prototype;\n      // work out prototype when using type-extension\n      if (definition.is) {\n        var inst = document.createElement(definition.tag);\n        var expectedPrototype = Object.getPrototypeOf(inst);\n        // only set nativePrototype if it will actually appear in the definition's chain\n        if (expectedPrototype === definition.prototype) {\n          nativePrototype = expectedPrototype;\n        }\n      }\n      // ensure __proto__ reference is installed at each point on the prototype\n      // chain.\n      // NOTE: On platforms without __proto__, a mixin strategy is used instead\n      // of prototype swizzling. In this case, this generated __proto__ provides\n      // limited support for prototype traversal.\n      var proto = definition.prototype, ancestor;\n      while (proto && (proto !== nativePrototype)) {\n        ancestor = Object.getPrototypeOf(proto);\n        proto.__proto__ = ancestor;\n        proto = ancestor;\n      }\n      // cache this in case of mixin\n      definition.native = nativePrototype;\n    }\n  }\n\n  // SECTION 4\n\n  function instantiate(definition) {\n    // 4.a.1. Create a new object that implements PROTOTYPE\n    // 4.a.2. Let ELEMENT by this new object\n    //\n    // the custom element instantiation algorithm must also ensure that the\n    // output is a valid DOM element with the proper wrapper in place.\n    //\n    return upgrade(domCreateElement(definition.tag), definition);\n  }\n\n  function upgrade(element, definition) {\n    // some definitions specify an 'is' attribute\n    if (definition.is) {\n      element.setAttribute('is', definition.is);\n    }\n    // make 'element' implement definition.prototype\n    implement(element, definition);\n    // flag as upgraded\n    element.__upgraded__ = true;\n    // lifecycle management\n    created(element);\n    // attachedCallback fires in tree order, call before recursing\n    scope.insertedNode(element);\n    // there should never be a shadow root on element at this point\n    scope.upgradeSubtree(element);\n    // OUTPUT\n    return element;\n  }\n\n  function implement(element, definition) {\n    // prototype swizzling is best\n    if (Object.__proto__) {\n      element.__proto__ = definition.prototype;\n    } else {\n      // where above we can re-acquire inPrototype via\n      // getPrototypeOf(Element), we cannot do so when\n      // we use mixin, so we install a magic reference\n      customMixin(element, definition.prototype, definition.native);\n      element.__proto__ = definition.prototype;\n    }\n  }\n\n  function customMixin(inTarget, inSrc, inNative) {\n    // TODO(sjmiles): 'used' allows us to only copy the 'youngest' version of\n    // any property. This set should be precalculated. We also need to\n    // consider this for supporting 'super'.\n    var used = {};\n    // start with inSrc\n    var p = inSrc;\n    // The default is HTMLElement.prototype, so we add a test to avoid mixing in\n    // native prototypes\n    while (p !== inNative && p !== HTMLElement.prototype) {\n      var keys = Object.getOwnPropertyNames(p);\n      for (var i=0, k; k=keys[i]; i++) {\n        if (!used[k]) {\n          Object.defineProperty(inTarget, k,\n              Object.getOwnPropertyDescriptor(p, k));\n          used[k] = 1;\n        }\n      }\n      p = Object.getPrototypeOf(p);\n    }\n  }\n\n  function created(element) {\n    // invoke createdCallback\n    if (element.createdCallback) {\n      element.createdCallback();\n    }\n  }\n\n  // attribute watching\n\n  function overrideAttributeApi(prototype) {\n    // overrides to implement callbacks\n    // TODO(sjmiles): should support access via .attributes NamedNodeMap\n    // TODO(sjmiles): preserves user defined overrides, if any\n    if (prototype.setAttribute._polyfilled) {\n      return;\n    }\n    var setAttribute = prototype.setAttribute;\n    prototype.setAttribute = function(name, value) {\n      changeAttribute.call(this, name, value, setAttribute);\n    }\n    var removeAttribute = prototype.removeAttribute;\n    prototype.removeAttribute = function(name) {\n      changeAttribute.call(this, name, null, removeAttribute);\n    }\n    prototype.setAttribute._polyfilled = true;\n  }\n\n  // https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/custom/\n  // index.html#dfn-attribute-changed-callback\n  function changeAttribute(name, value, operation) {\n    name = name.toLowerCase();\n    var oldValue = this.getAttribute(name);\n    operation.apply(this, arguments);\n    var newValue = this.getAttribute(name);\n    if (this.attributeChangedCallback\n        && (newValue !== oldValue)) {\n      this.attributeChangedCallback(name, oldValue, newValue);\n    }\n  }\n\n  // element registry (maps tag names to definitions)\n\n  var registry = {};\n\n  function getRegisteredDefinition(name) {\n    if (name) {\n      return registry[name.toLowerCase()];\n    }\n  }\n\n  function registerDefinition(name, definition) {\n    registry[name] = definition;\n  }\n\n  function generateConstructor(definition) {\n    return function() {\n      return instantiate(definition);\n    };\n  }\n\n  var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n  function createElementNS(namespace, tag, typeExtension) {\n    // NOTE: we do not support non-HTML elements,\n    // just call createElementNS for non HTML Elements\n    if (namespace === HTML_NAMESPACE) {\n      return createElement(tag, typeExtension);\n    } else {\n      return domCreateElementNS(namespace, tag);\n    }\n  }\n\n  function createElement(tag, typeExtension) {\n    // TODO(sjmiles): ignore 'tag' when using 'typeExtension', we could\n    // error check it, or perhaps there should only ever be one argument\n    var definition = getRegisteredDefinition(typeExtension || tag);\n    if (definition) {\n      if (tag == definition.tag && typeExtension == definition.is) {\n        return new definition.ctor();\n      }\n      // Handle empty string for type extension.\n      if (!typeExtension && !definition.is) {\n        return new definition.ctor();\n      }\n    }\n\n    if (typeExtension) {\n      var element = createElement(tag);\n      element.setAttribute('is', typeExtension);\n      return element;\n    }\n    var element = domCreateElement(tag);\n    // Custom tags should be HTMLElements even if not upgraded.\n    if (tag.indexOf('-') >= 0) {\n      implement(element, HTMLElement);\n    }\n    return element;\n  }\n\n  function upgradeElement(element) {\n    if (!element.__upgraded__ && (element.nodeType === Node.ELEMENT_NODE)) {\n      var is = element.getAttribute('is');\n      var definition = getRegisteredDefinition(is || element.localName);\n      if (definition) {\n        if (is && definition.tag == element.localName) {\n          return upgrade(element, definition);\n        } else if (!is && !definition.extends) {\n          return upgrade(element, definition);\n        }\n      }\n    }\n  }\n\n  function cloneNode(deep) {\n    // call original clone\n    var n = domCloneNode.call(this, deep);\n    // upgrade the element and subtree\n    scope.upgradeAll(n);\n    // return the clone\n    return n;\n  }\n  // capture native createElement before we override it\n\n  var domCreateElement = document.createElement.bind(document);\n  var domCreateElementNS = document.createElementNS.bind(document);\n\n  // capture native cloneNode before we override it\n\n  var domCloneNode = Node.prototype.cloneNode;\n\n  // exports\n\n  document.registerElement = register;\n  document.createElement = createElement; // override\n  document.createElementNS = createElementNS; // override\n  Node.prototype.cloneNode = cloneNode; // override\n\n  scope.registry = registry;\n\n  /**\n   * Upgrade an element to a custom element. Upgrading an element\n   * causes the custom prototype to be applied, an `is` attribute\n   * to be attached (as needed), and invocation of the `readyCallback`.\n   * `upgrade` does nothing if the element is already upgraded, or\n   * if it matches no registered custom tag name.\n   *\n   * @method ugprade\n   * @param {Element} element The element to upgrade.\n   * @return {Element} The upgraded element.\n   */\n  scope.upgrade = upgradeElement;\n}\n\n// Create a custom 'instanceof'. This is necessary when CustomElements\n// are implemented via a mixin strategy, as for example on IE10.\nvar isInstance;\nif (!Object.__proto__ && !useNative) {\n  isInstance = function(obj, ctor) {\n    var p = obj;\n    while (p) {\n      // NOTE: this is not technically correct since we're not checking if\n      // an object is an instance of a constructor; however, this should\n      // be good enough for the mixin strategy.\n      if (p === ctor.prototype) {\n        return true;\n      }\n      p = p.__proto__;\n    }\n    return false;\n  }\n} else {\n  isInstance = function(obj, base) {\n    return obj instanceof base;\n  }\n}\n\n// exports\nscope.instanceof = isInstance;\nscope.reservedTagList = reservedTagList;\n\n// bc\ndocument.register = document.registerElement;\n\nscope.hasNative = hasNative;\nscope.useNative = useNative;\n\n})(window.CustomElements);\n","/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n// import\n\nvar IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;\n\n// highlander object for parsing a document tree\n\nvar parser = {\n  selectors: [\n    'link[rel=' + IMPORT_LINK_TYPE + ']'\n  ],\n  map: {\n    link: 'parseLink'\n  },\n  parse: function(inDocument) {\n    if (!inDocument.__parsed) {\n      // only parse once\n      inDocument.__parsed = true;\n      // all parsable elements in inDocument (depth-first pre-order traversal)\n      var elts = inDocument.querySelectorAll(parser.selectors);\n      // for each parsable node type, call the mapped parsing method\n      forEach(elts, function(e) {\n        parser[parser.map[e.localName]](e);\n      });\n      // upgrade all upgradeable static elements, anything dynamically\n      // created should be caught by observer\n      CustomElements.upgradeDocument(inDocument);\n      // observe document for dom changes\n      CustomElements.observeDocument(inDocument);\n    }\n  },\n  parseLink: function(linkElt) {\n    // imports\n    if (isDocumentLink(linkElt)) {\n      this.parseImport(linkElt);\n    }\n  },\n  parseImport: function(linkElt) {\n    if (linkElt.import) {\n      parser.parse(linkElt.import);\n    }\n  }\n};\n\nfunction isDocumentLink(inElt) {\n  return (inElt.localName === 'link'\n      && inElt.getAttribute('rel') === IMPORT_LINK_TYPE);\n}\n\nvar forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);\n\n// exports\n\nscope.parser = parser;\nscope.IMPORT_LINK_TYPE = IMPORT_LINK_TYPE;\n\n})(window.CustomElements);","/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n(function(scope){\n\n// bootstrap parsing\nfunction bootstrap() {\n  // parse document\n  CustomElements.parser.parse(document);\n  // one more pass before register is 'live'\n  CustomElements.upgradeDocument(document);\n  // install upgrade hook if HTMLImports are available\n  if (window.HTMLImports) {\n    HTMLImports.__importsParsingHook = function(elt) {\n      CustomElements.parser.parse(elt.import);\n    }\n  }\n  // set internal 'ready' flag, now document.registerElement will trigger \n  // synchronous upgrades\n  CustomElements.ready = true;\n  // async to ensure *native* custom elements upgrade prior to this\n  // DOMContentLoaded can fire before elements upgrade (e.g. when there's\n  // an external script)\n  setTimeout(function() {\n    // capture blunt profiling data\n    CustomElements.readyTime = Date.now();\n    if (window.HTMLImports) {\n      CustomElements.elapsed = CustomElements.readyTime - HTMLImports.readyTime;\n    }\n    // notify the system that we are bootstrapped\n    document.dispatchEvent(\n      new CustomEvent('WebComponentsReady', {bubbles: true})\n    );\n  });\n}\n\n// CustomEvent shim for IE\nif (typeof window.CustomEvent !== 'function') {\n  window.CustomEvent = function(inType, params) {\n    params = params || {};\n    var e = document.createEvent('CustomEvent');\n    e.initCustomEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);\n    return e;\n  };\n  window.CustomEvent.prototype = window.Event.prototype;\n}\n\n// When loading at readyState complete time (or via flag), boot custom elements\n// immediately.\n// If relevant, HTMLImports must already be loaded.\nif (document.readyState === 'complete' || scope.flags.eager) {\n  bootstrap();\n// When loading at readyState interactive time, bootstrap only if HTMLImports\n// are not pending. Also avoid IE as the semantics of this state are unreliable.\n} else if (document.readyState === 'interactive' && !window.attachEvent &&\n    (!window.HTMLImports || window.HTMLImports.ready)) {\n  bootstrap();\n// When loading at other readyStates, wait for the appropriate DOM event to \n// bootstrap.\n} else {\n  var loadEvent = window.HTMLImports && !HTMLImports.ready ?\n      'HTMLImportsLoaded' : 'DOMContentLoaded';\n  window.addEventListener(loadEvent, bootstrap);\n}\n\n})(window.CustomElements);\n","/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function() {\n\nif (window.ShadowDOMPolyfill) {\n\n  // ensure wrapped inputs for these functions\n  var fns = ['upgradeAll', 'upgradeSubtree', 'observeDocument',\n      'upgradeDocument'];\n\n  // cache originals\n  var original = {};\n  fns.forEach(function(fn) {\n    original[fn] = CustomElements[fn];\n  });\n\n  // override\n  fns.forEach(function(fn) {\n    CustomElements[fn] = function(inNode) {\n      return original[fn](wrap(inNode));\n    };\n  });\n\n}\n\n})();\n","/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n  // TODO(sorvell): It's desireable to provide a default stylesheet \n  // that's convenient for styling unresolved elements, but\n  // it's cumbersome to have to include this manually in every page.\n  // It would make sense to put inside some HTMLImport but \n  // the HTMLImports polyfill does not allow loading of stylesheets \n  // that block rendering. Therefore this injection is tolerated here.\n\n  var style = document.createElement('style');\n  style.textContent = ''\n      + 'body {'\n      + 'transition: opacity ease-in 0.2s;' \n      + ' } \\n'\n      + 'body[unresolved] {'\n      + 'opacity: 0; display: block; overflow: hidden;' \n      + ' } \\n'\n      ;\n  var head = document.querySelector('head');\n  head.insertBefore(style, head.firstChild);\n\n})(Platform);\n","/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n  function withDependencies(task, depends) {\n    depends = depends || [];\n    if (!depends.map) {\n      depends = [depends];\n    }\n    return task.apply(this, depends.map(marshal));\n  }\n\n  function module(name, dependsOrFactory, moduleFactory) {\n    var module;\n    switch (arguments.length) {\n      case 0:\n        return;\n      case 1:\n        module = null;\n        break;\n      case 2:\n        // dependsOrFactory is `factory` in this case\n        module = dependsOrFactory.apply(this);\n        break;\n      default:\n        // dependsOrFactory is `depends` in this case\n        module = withDependencies(moduleFactory, dependsOrFactory);\n        break;\n    }\n    modules[name] = module;\n  };\n\n  function marshal(name) {\n    return modules[name];\n  }\n\n  var modules = {};\n\n  function using(depends, task) {\n    HTMLImports.whenImportsReady(function() {\n      withDependencies(task, depends);\n    });\n  };\n\n  // exports\n\n  scope.marshal = marshal;\n  // `module` confuses commonjs detectors\n  scope.modularize = module;\n  scope.using = using;\n\n})(window);\n"]}
;
</script>

  
  
  
  
  

  

  <style shim-shadowdom="">
    body {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-size: 14px;
    }

    html, body {
      height: 100%;
      margin: 0;
    }

    body /deep/ .toolbar drop-down {
      background-color: transparent;
    }

    body /deep/ core-popup-menu::shadow #menu {
      border: 1px solid #ccc;
    }

    body /deep/ :not(.toolbar) core-popup-menu::shadow #menu {
      background-color: #eee;
      border: 1px solid #ccc;
    }

    body /deep/ core-item {
      padding: 0 12px;
    }

    body /deep/ .maxh-500 /deep/ #menu {
      max-height: 500px !important;
    }

  </style>




  <polymer-element name="menu-button" attributes="icon opened halign valign">
  <template>

    <style>
      :host {
        display: inline-block;
      }
    </style>

    <core-icon-button id="btn" icon="{{icon}}" on-tap="{{tapAction}}"></core-icon-button>

    <core-popup-menu id="menu" relatedtarget="{{$.btn}}" opened="{{opened}}" halign="{{halign}}" valign="{{valign}}">
      <content></content>
    </core-popup-menu>

  </template>
  <script>

    Polymer('menu-button', {

      tapAction: function() {
        this.$.menu.opened = true;
      }

    });

  </script>
  </polymer-element>

  <polymer-element name="drop-down" attributes="label opened selected selectedItem halign valign">
  <template>

    <style>
      :host {
        display: inline-block;
        background-color: #eee;
        margin: 0 12px;
      }
    </style>

    <core-item id="item" label="{{selectedItem ? selectedItem.label : label}}" on-tap="{{tapAction}}">
      <div flex=""></div>
      <core-icon icon="{{opened ? 'arrow-drop-up' : 'arrow-drop-down'}}"></core-icon>
    </core-item>

    <core-popup-menu id="menu" relatedtarget="{{$.item}}" opened="{{opened}}" selected="{{selected}}" selecteditem="{{selectedItem}}" halign="{{halign}}" valign="{{valign}}">
      <content/>
    </core-popup-menu>

  </template>
  <script>

    Polymer('drop-down', {

      tapAction: function() {
        this.$.menu.opened = true;
      }

    });

  </script>
  </polymer-element>

  <polymer-element name="popup-menu-demo">
  <template>

    <style>
      :host {
        display: block;
      }

      .toolbar {
        background-color: #91a7ff;
        color: #fff;
        font-size: 16px;
      }

      .toolbar > * {
        padding: 8px;
      }

      .middle > * {
        padding: 8px;
      }
    </style>

    <div class="toolbar" layout="" horizontal="" center="">

      <menu-button icon="menu">
        <core-item label="Cut"></core-item>
        <core-item label="Copy"></core-item>
        <core-item label="Paste"></core-item>
      </menu-button>

      <div flex="">
        
        <drop-down selected="15">
          <template repeat="{{countries}}">
            <core-item label="{{name}}"/>
          </template>
        </drop-down>

      </div>

      <menu-button icon="more-vert">
        <core-item icon="favorite" label="Favorite"></core-item>
        <core-item icon="social:share" label="Share"></core-item>
        <core-item icon="settings" label="Settings"></core-item>
        <core-item icon="help" label="Help"></core-item>
      </menu-button>

    </div>

    <div flex="" class="middle" layout="" vertical="">

      <div>halign="auto" valign="auto":</div>

      <div layout="" horizontal="" center="">

        <drop-down label="Choose a country">
          <template repeat="{{countries}}">
            <core-item label="{{name}}"></core-item>
          </template>
        </drop-down>

        <drop-down label="Choose a country">
          <template repeat="{{countries}}">
            <core-item label="{{code}}"></core-item>
          </template>
        </drop-down>

        <div flex=""></div>

        <drop-down label="Your favorite pastry" selected="3">
          <template repeat="{{pastries}}">
            <core-item label="{{}}"/>
          </template>
        </drop-down>

      </div>

      <div layout="" horizontal="" center="">
        in flexbox:

        <drop-down label="Choose a country" flex="">
          <template repeat="{{countries}}">
            <core-item label="{{name}}"></core-item>
          </template>
        </drop-down>

        <drop-down class="maxh-500" label="max-height: 500px" flex="">
          <template repeat="{{countries}}">
            <core-item label="{{name}}"></core-item>
          </template>
        </drop-down>
      </div>

      <div flex=""></div>

      <div layout="" horizontal="" center="">

        <drop-down label="valign=auto">
          <template repeat="{{countries}}">
            <core-item label="{{name}}"></core-item>
          </template>
        </drop-down>

        <div flex=""></div>

        <drop-down label="valign=top">
          <template repeat="{{pastries}}">
            <core-item label="{{}}"></core-item>
          </template>
        </drop-down>

        <drop-down label="valign=top" valign="top">
          <template repeat="{{countries}}">
            <core-item label="{{code}}"></core-item>
          </template>
        </drop-down>

      </div>

    </div>

    <div class="toolbar" layout="" horizontal="" center="">

      <menu-button icon="menu">
        <core-item label="Paste"></core-item>
        <core-item label="Copy"></core-item>
        <core-item label="Cut"></core-item>
      </menu-button>

      <div flex=""></div>

      <menu-button icon="more-vert">
        <core-item icon="help" label="Help"></core-item>
        <core-item icon="settings" label="Settings"></core-item>
        <core-item icon="social:share" label="Share"></core-item>
        <core-item icon="favorite" label="Favorite"></core-item>
      </menu-button>

    </div>

  </template>

  <script>

    Polymer('popup-menu-demo', {

      countries: [
        {name: 'Afghanistan', code: 'AF'},
        {name: '&Aring;land Islands', code: 'AX'},
        {name: 'Albania', code: 'AL'},
        {name: 'Algeria', code: 'DZ'},
        {name: 'American Samoa', code: 'AS'},
        {name: 'Andorra', code: 'AD'},
        {name: 'Angola', code: 'AO'},
        {name: 'Anguilla', code: 'AI'},
        {name: 'Antarctica', code: 'AQ'},
        {name: 'Antigua and Barbuda', code: 'AG'},
        {name: 'Argentina', code: 'AR'},
        {name: 'Armenia', code: 'AM'},
        {name: 'Aruba', code: 'AW'},
        {name: 'Australia', code: 'AU'},
        {name: 'Austria', code: 'AT'},
        {name: 'Azerbaijan', code: 'AZ'},
        {name: 'Bahamas', code: 'BS'},
        {name: 'Bahrain', code: 'BH'},
        {name: 'Bangladesh', code: 'BD'},
        {name: 'Barbados', code: 'BB'},
        {name: 'Belarus', code: 'BY'},
        {name: 'Belgium', code: 'BE'},
        {name: 'Belize', code: 'BZ'},
        {name: 'Benin', code: 'BJ'},
        {name: 'Bermuda', code: 'BM'},
        {name: 'Bhutan', code: 'BT'},
        {name: 'Bolivia', code: 'BO'},
        {name: 'Bosnia and Herzegovina', code: 'BA'},
        {name: 'Botswana', code: 'BW'},
        {name: 'Bouvet Island', code: 'BV'},
        {name: 'Brazil', code: 'BR'},
        {name: 'British Indian Ocean Territory', code: 'IO'},
        {name: 'Brunei Darussalam', code: 'BN'},
        {name: 'Bulgaria', code: 'BG'},
        {name: 'Burkina Faso', code: 'BF'},
        {name: 'Burundi', code: 'BI'},
        {name: 'Cambodia', code: 'KH'},
        {name: 'Cameroon', code: 'CM'},
        {name: 'Canada', code: 'CA'},
        {name: 'Cape Verde', code: 'CV'},
        {name: 'Cayman Islands', code: 'KY'},
        {name: 'Central African Republic', code: 'CF'},
        {name: 'Chad', code: 'TD'},
        {name: 'Chile', code: 'CL'},
        {name: 'China', code: 'CN'},
        {name: 'Christmas Island', code: 'CX'},
        {name: 'Cocos (Keeling) Islands', code: 'CC'},
        {name: 'Colombia', code: 'CO'},
        {name: 'Comoros', code: 'KM'},
        {name: 'Congo', code: 'CG'},
        {name: 'Congo, The Democratic Republic of the', code: 'CD'},
        {name: 'Cook Islands', code: 'CK'},
        {name: 'Costa Rica', code: 'CR'},
        {name: 'Cote D\'Ivoire', code: 'CI'},
        {name: 'Croatia', code: 'HR'},
        {name: 'Cuba', code: 'CU'},
        {name: 'Cyprus', code: 'CY'},
        {name: 'Czech Republic', code: 'CZ'},
        {name: 'Denmark', code: 'DK'},
        {name: 'Djibouti', code: 'DJ'},
        {name: 'Dominica', code: 'DM'},
        {name: 'Dominican Republic', code: 'DO'},
        {name: 'Ecuador', code: 'EC'},
        {name: 'Egypt', code: 'EG'},
        {name: 'El Salvador', code: 'SV'},
        {name: 'Equatorial Guinea', code: 'GQ'},
        {name: 'Eritrea', code: 'ER'},
        {name: 'Estonia', code: 'EE'},
        {name: 'Ethiopia', code: 'ET'},
        {name: 'Falkland Islands (Malvinas)', code: 'FK'},
        {name: 'Faroe Islands', code: 'FO'},
        {name: 'Fiji', code: 'FJ'},
        {name: 'Finland', code: 'FI'},
        {name: 'France', code: 'FR'},
        {name: 'French Guiana', code: 'GF'},
        {name: 'French Polynesia', code: 'PF'},
        {name: 'French Southern Territories', code: 'TF'},
        {name: 'Gabon', code: 'GA'},
        {name: 'Gambia', code: 'GM'},
        {name: 'Georgia', code: 'GE'},
        {name: 'Germany', code: 'DE'},
        {name: 'Ghana', code: 'GH'},
        {name: 'Gibraltar', code: 'GI'},
        {name: 'Greece', code: 'GR'},
        {name: 'Greenland', code: 'GL'},
        {name: 'Grenada', code: 'GD'},
        {name: 'Guadeloupe', code: 'GP'},
        {name: 'Guam', code: 'GU'},
        {name: 'Guatemala', code: 'GT'},
        {name: 'Guernsey', code: 'GG'},
        {name: 'Guinea', code: 'GN'},
        {name: 'Guinea-Bissau', code: 'GW'},
        {name: 'Guyana', code: 'GY'},
        {name: 'Haiti', code: 'HT'},
        {name: 'Heard Island and Mcdonald Islands', code: 'HM'},
        {name: 'Holy See (Vatican City State)', code: 'VA'},
        {name: 'Honduras', code: 'HN'},
        {name: 'Hong Kong', code: 'HK'},
        {name: 'Hungary', code: 'HU'},
        {name: 'Iceland', code: 'IS'},
        {name: 'India', code: 'IN'},
        {name: 'Indonesia', code: 'ID'},
        {name: 'Iran, Islamic Republic Of', code: 'IR'},
        {name: 'Iraq', code: 'IQ'},
        {name: 'Ireland', code: 'IE'},
        {name: 'Isle of Man', code: 'IM'},
        {name: 'Israel', code: 'IL'},
        {name: 'Italy', code: 'IT'},
        {name: 'Jamaica', code: 'JM'},
        {name: 'Japan', code: 'JP'},
        {name: 'Jersey', code: 'JE'},
        {name: 'Jordan', code: 'JO'},
        {name: 'Kazakhstan', code: 'KZ'},
        {name: 'Kenya', code: 'KE'},
        {name: 'Kiribati', code: 'KI'},
        {name: 'Korea, Democratic People\'S Republic of', code: 'KP'},
        {name: 'Korea, Republic of', code: 'KR'},
        {name: 'Kuwait', code: 'KW'},
        {name: 'Kyrgyzstan', code: 'KG'},
        {name: 'Lao People\'S Democratic Republic', code: 'LA'},
        {name: 'Latvia', code: 'LV'},
        {name: 'Lebanon', code: 'LB'},
        {name: 'Lesotho', code: 'LS'},
        {name: 'Liberia', code: 'LR'},
        {name: 'Libyan Arab Jamahiriya', code: 'LY'},
        {name: 'Liechtenstein', code: 'LI'},
        {name: 'Lithuania', code: 'LT'},
        {name: 'Luxembourg', code: 'LU'},
        {name: 'Macao', code: 'MO'},
        {name: 'Macedonia, The Former Yugoslav Republic of', code: 'MK'},
        {name: 'Madagascar', code: 'MG'},
        {name: 'Malawi', code: 'MW'},
        {name: 'Malaysia', code: 'MY'},
        {name: 'Maldives', code: 'MV'},
        {name: 'Mali', code: 'ML'},
        {name: 'Malta', code: 'MT'},
        {name: 'Marshall Islands', code: 'MH'},
        {name: 'Martinique', code: 'MQ'},
        {name: 'Mauritania', code: 'MR'},
        {name: 'Mauritius', code: 'MU'},
        {name: 'Mayotte', code: 'YT'},
        {name: 'Mexico', code: 'MX'},
        {name: 'Micronesia, Federated States of', code: 'FM'},
        {name: 'Moldova, Republic of', code: 'MD'},
        {name: 'Monaco', code: 'MC'},
        {name: 'Mongolia', code: 'MN'},
        {name: 'Montserrat', code: 'MS'},
        {name: 'Morocco', code: 'MA'},
        {name: 'Mozambique', code: 'MZ'},
        {name: 'Myanmar', code: 'MM'},
        {name: 'Namibia', code: 'NA'},
        {name: 'Nauru', code: 'NR'},
        {name: 'Nepal', code: 'NP'},
        {name: 'Netherlands', code: 'NL'},
        {name: 'Netherlands Antilles', code: 'AN'},
        {name: 'New Caledonia', code: 'NC'},
        {name: 'New Zealand', code: 'NZ'},
        {name: 'Nicaragua', code: 'NI'},
        {name: 'Niger', code: 'NE'},
        {name: 'Nigeria', code: 'NG'},
        {name: 'Niue', code: 'NU'},
        {name: 'Norfolk Island', code: 'NF'},
        {name: 'Northern Mariana Islands', code: 'MP'},
        {name: 'Norway', code: 'NO'},
        {name: 'Oman', code: 'OM'},
        {name: 'Pakistan', code: 'PK'},
        {name: 'Palau', code: 'PW'},
        {name: 'Palestinian Territory, Occupied', code: 'PS'},
        {name: 'Panama', code: 'PA'},
        {name: 'Papua New Guinea', code: 'PG'},
        {name: 'Paraguay', code: 'PY'},
        {name: 'Peru', code: 'PE'},
        {name: 'Philippines', code: 'PH'},
        {name: 'Pitcairn', code: 'PN'},
        {name: 'Poland', code: 'PL'},
        {name: 'Portugal', code: 'PT'},
        {name: 'Puerto Rico', code: 'PR'},
        {name: 'Qatar', code: 'QA'},
        {name: 'Reunion', code: 'RE'},
        {name: 'Romania', code: 'RO'},
        {name: 'Russian Federation', code: 'RU'},
        {name: 'RWANDA', code: 'RW'},
        {name: 'Saint Helena', code: 'SH'},
        {name: 'Saint Kitts and Nevis', code: 'KN'},
        {name: 'Saint Lucia', code: 'LC'},
        {name: 'Saint Pierre and Miquelon', code: 'PM'},
        {name: 'Saint Vincent and the Grenadines', code: 'VC'},
        {name: 'Samoa', code: 'WS'},
        {name: 'San Marino', code: 'SM'},
        {name: 'Sao Tome and Principe', code: 'ST'},
        {name: 'Saudi Arabia', code: 'SA'},
        {name: 'Senegal', code: 'SN'},
        {name: 'Serbia and Montenegro', code: 'CS'},
        {name: 'Seychelles', code: 'SC'},
        {name: 'Sierra Leone', code: 'SL'},
        {name: 'Singapore', code: 'SG'},
        {name: 'Slovakia', code: 'SK'},
        {name: 'Slovenia', code: 'SI'},
        {name: 'Solomon Islands', code: 'SB'},
        {name: 'Somalia', code: 'SO'},
        {name: 'South Africa', code: 'ZA'},
        {name: 'South Georgia and the South Sandwich Islands', code: 'GS'},
        {name: 'Spain', code: 'ES'},
        {name: 'Sri Lanka', code: 'LK'},
        {name: 'Sudan', code: 'SD'},
        {name: 'Suriname', code: 'SR'},
        {name: 'Svalbard and Jan Mayen', code: 'SJ'},
        {name: 'Swaziland', code: 'SZ'},
        {name: 'Sweden', code: 'SE'},
        {name: 'Switzerland', code: 'CH'},
        {name: 'Syrian Arab Republic', code: 'SY'},
        {name: 'Taiwan, Province of China', code: 'TW'},
        {name: 'Tajikistan', code: 'TJ'},
        {name: 'Tanzania, United Republic of', code: 'TZ'},
        {name: 'Thailand', code: 'TH'},
        {name: 'Timor-Leste', code: 'TL'},
        {name: 'Togo', code: 'TG'},
        {name: 'Tokelau', code: 'TK'},
        {name: 'Tonga', code: 'TO'},
        {name: 'Trinidad and Tobago', code: 'TT'},
        {name: 'Tunisia', code: 'TN'},
        {name: 'Turkey', code: 'TR'},
        {name: 'Turkmenistan', code: 'TM'},
        {name: 'Turks and Caicos Islands', code: 'TC'},
        {name: 'Tuvalu', code: 'TV'},
        {name: 'Uganda', code: 'UG'},
        {name: 'Ukraine', code: 'UA'},
        {name: 'United Arab Emirates', code: 'AE'},
        {name: 'United Kingdom', code: 'GB'},
        {name: 'United States', code: 'US'},
        {name: 'United States Minor Outlying Islands', code: 'UM'},
        {name: 'Uruguay', code: 'UY'},
        {name: 'Uzbekistan', code: 'UZ'},
        {name: 'Vanuatu', code: 'VU'},
        {name: 'Venezuela', code: 'VE'},
        {name: 'Viet Nam', code: 'VN'},
        {name: 'Virgin Islands, British', code: 'VG'},
        {name: 'Virgin Islands, U.S.', code: 'VI'},
        {name: 'Wallis and Futuna', code: 'WF'},
        {name: 'Western Sahara', code: 'EH'},
        {name: 'Yemen', code: 'YE'},
        {name: 'Zambia', code: 'ZM'},
        {name: 'Zimbabwe', code: 'ZW'}
      ],

      pastries: [
        'Apple fritter',
        'Croissant',
        'Donut',
        'Financier',
        'Jello',
        'Madeleine',
        'Pound cake',
        'Pretzel',
        'Sfogliatelle'
      ]

    });

  </script>
  </polymer-element>

  <popup-menu-demo fit="" layout="" vertical=""></popup-menu-demo>



